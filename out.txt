diff --git a/osl-common/src/main/java/org/openspotlight/common/util/PatternMatcher.java b/osl-common/src/main/java/org/openspotlight/common/util/PatternMatcher.java
index e19b041..fcfe035 100644
--- a/osl-common/src/main/java/org/openspotlight/common/util/PatternMatcher.java
+++ b/osl-common/src/main/java/org/openspotlight/common/util/PatternMatcher.java
@@ -55,11 +55,9 @@ import static org.openspotlight.common.util.Assertions.checkNotNull;
 import static org.openspotlight.common.util.Exceptions.logAndThrow;
 
 import java.io.Serializable;
-import java.lang.reflect.Constructor;
 import java.util.HashSet;
 import java.util.Set;
 
-import org.apache.tools.ant.types.selectors.SelectorUtils;
 import org.openspotlight.common.MutableType;
 
 // TODO: Auto-generated Javadoc
diff --git a/osl-common/src/main/java/org/openspotlight/common/util/StringBuilderUtil.java b/osl-common/src/main/java/org/openspotlight/common/util/StringBuilderUtil.java
index 8f7fb4a..4b81d39 100644
--- a/osl-common/src/main/java/org/openspotlight/common/util/StringBuilderUtil.java
+++ b/osl-common/src/main/java/org/openspotlight/common/util/StringBuilderUtil.java
@@ -48,6 +48,7 @@
  */
 package org.openspotlight.common.util;
 
+import java.util.List;
 
 /**
  * The Class StringBuilderUtil.
@@ -55,54 +56,85 @@ package org.openspotlight.common.util;
  * @author Vitor Hugo Chagas
  */
 public class StringBuilderUtil {
-	
-	/**
-	 * Append values if value is not null.
-	 * 
-	 * @param buffer the buffer
-	 * @param value the value
-	 * @param values the values
-	 * 
-	 * @return true, if successful
-	 */
-	public static StringBuilder appendIfNotNull(StringBuilder buffer, Object value, Object...values) {
-		if (value != null) {
-			for (Object current : values) {
-				if (current != null) {
-					buffer.append(current);
-				}
-			}
-		}
-		return buffer;
-	}
 
-	/**
-	 * Append value if not null.
-	 * 
-	 * @param buffer the buffer
-	 * @param value the value
-	 * 
-	 * @return the string builder
-	 */
-	public static StringBuilder append(StringBuilder buffer, Object value) {
-		if (value != null) {
-			buffer.append(value);
-		}
-		return buffer;
-	}
-	
-	/**
-	 * Append values.
-	 * 
-	 * @param buffer the buffer
-	 * @param values the values
-	 * 
-	 * @return the string builder
-	 */
-	public static StringBuilder append(StringBuilder buffer, Object...values) {
-		for (Object value : values) {
-			buffer.append(value);
-		}
-		return buffer;
-	}
+    /**
+     * Append values if value is not null.
+     * 
+     * @param buffer the buffer
+     * @param value the value
+     * @param values the values
+     * @return true, if successful
+     */
+    public static StringBuilder appendIfNotNull( StringBuilder buffer,
+                                                 Object value,
+                                                 Object... values ) {
+        if (value != null) {
+            for (Object current : values) {
+                if (current != null) {
+                    buffer.append(current);
+                }
+            }
+        }
+        return buffer;
+    }
+
+    /**
+     * Append value if not null.
+     * 
+     * @param buffer the buffer
+     * @param value the value
+     * @return the string builder
+     */
+    public static StringBuilder append( StringBuilder buffer,
+                                        Object value ) {
+        if (value != null) {
+            buffer.append(value);
+        }
+        return buffer;
+    }
+
+    /**
+     * Append values.
+     * 
+     * @param buffer the buffer
+     * @param values the values
+     * @return the string builder
+     */
+    public static StringBuilder append( StringBuilder buffer,
+                                        Object... values ) {
+        for (Object value : values) {
+            buffer.append(value);
+        }
+        return buffer;
+    }
+
+    /**
+     * Append values.
+     * 
+     * @param buffer the buffer
+     * @param values the values
+     * @return the string builder
+     */
+    public static StringBuilder append( StringBuilder buffer,
+                                        List<?> values ) {
+        for (Object value : values) {
+            buffer.append(value);
+        }
+        return buffer;
+    }
+
+    /**
+     * Append values and add a carriage return.
+     * 
+     * @param buffer the buffer
+     * @param values the values
+     * @return the string builder
+     */
+    public static StringBuilder appendLine( StringBuilder buffer,
+                                            List<?> values ) {
+        buffer = append(buffer, values);
+        buffer.append("\n");
+        return buffer;
+    }
+
 }
diff --git a/osl-graph-api/src/main/java/org/openspotlight/graph/SLMetaNodeProperty.java b/osl-graph-api/src/main/java/org/openspotlight/graph/SLMetaNodeProperty.java
index 0fd0b89..33a8a70 100644
--- a/osl-graph-api/src/main/java/org/openspotlight/graph/SLMetaNodeProperty.java
+++ b/osl-graph-api/src/main/java/org/openspotlight/graph/SLMetaNodeProperty.java
@@ -56,32 +56,29 @@ import java.io.Serializable;
  * @author Vitor Hugo Chagas
  */
 public interface SLMetaNodeProperty extends SLMetaElement {
-	
-	/**
-	 * Gets the meta node.
-	 * 
-	 * @return the meta node
-	 * 
-	 * @throws SLGraphSessionException the SL graph session exception
-	 */
-	public SLMetaNodeType getMetaNode() throws SLGraphSessionException;
-	
-	/**
-	 * Gets the name.
-	 * 
-	 * @return the name
-	 * 
-	 * @throws SLGraphSessionException the SL graph session exception
-	 */
-	public String getName() throws SLGraphSessionException;
-	
-	/**
-	 * Gets the type.
-	 * 
-	 * @return the type
-	 * 
-	 * @throws SLGraphSessionException the SL graph session exception
-	 */
-	public Class<? extends Serializable> getType() throws SLGraphSessionException;
+
+    /**
+     * Gets the meta node.
+     * 
+     * @return the meta node
+     * @throws SLGraphSessionException the SL graph session exception
+     */
+    public SLMetaNodeType getMetaNode() throws SLGraphSessionException;
+
+    /**
+     * Gets the name.
+     * 
+     * @return the name
+     * @throws SLGraphSessionException the SL graph session exception
+     */
+    public String getName() throws SLGraphSessionException;
+
+    /**
+     * Gets the type.
+     * 
+     * @return the type
+     * @throws SLGraphSessionException the SL graph session exception
+     */
+    public Class<? extends Serializable> getType() throws SLGraphSessionException;
 
 }
diff --git a/osl-graph/src/main/java/org/openspotlight/graph/SLMetaNodePropertyImpl.java b/osl-graph/src/main/java/org/openspotlight/graph/SLMetaNodePropertyImpl.java
index 24b9b5f..bd3abec 100644
--- a/osl-graph/src/main/java/org/openspotlight/graph/SLMetaNodePropertyImpl.java
+++ b/osl-graph/src/main/java/org/openspotlight/graph/SLMetaNodePropertyImpl.java
@@ -59,89 +59,86 @@ import org.openspotlight.graph.persistence.SLPersistentTreeSessionException;
  * @author Vitor Hugo Chagas
  */
 public class SLMetaNodePropertyImpl implements SLMetaNodeProperty {
-	
-	/** The metadata. */
-	private SLMetadata metadata;
-	
-	/** The meta node. */
-	private SLMetaNodeType metaNode;
-	
-	/** The p property. */
-	private SLPersistentProperty<Serializable> pProperty;
-	
-	/**
-	 * Instantiates a new sL meta node property impl.
-	 * 
-	 * @param metadata the metadata
-	 * @param metaNode the meta node
-	 * @param pProperty the property
-	 */
-	SLMetaNodePropertyImpl(SLMetadata metadata, SLMetaNodeType metaNode, SLPersistentProperty<Serializable> pProperty) {
-		this.metadata = metadata;
-		this.metaNode = metaNode;
-		this.pProperty = pProperty;
-	}
 
-	//@Override
-	/* (non-Javadoc)
-	 * @see org.openspotlight.graph.SLMetaElement#getMetadata()
-	 */
-	public SLMetadata getMetadata() throws SLGraphSessionException {
-		return metadata;
-	}
+    /** The metadata. */
+    private SLMetadata                         metadata;
 
-	//@Override
-	/* (non-Javadoc)
-	 * @see org.openspotlight.graph.SLMetaNodeProperty#getMetaNode()
-	 */
-	public SLMetaNodeType getMetaNode() throws SLGraphSessionException {
-		return metaNode;
-	}
+    /** The meta node. */
+    private SLMetaNodeType                     metaNode;
 
-	//@Override
-	/* (non-Javadoc)
-	 * @see org.openspotlight.graph.SLMetaNodeProperty#getName()
-	 */
-	public String getName() throws SLGraphSessionException {
-		try {
-			return SLCommonSupport.toSimplePropertyName(pProperty.getName());
-		}
-		catch (SLPersistentTreeSessionException e) {
-			throw new SLGraphSessionException("Error on attempt to retrieve meta node property name.", e);
-		}
-	}
-	
-	//@Override
-	/* (non-Javadoc)
-	 * @see org.openspotlight.graph.SLMetaNodeProperty#getType()
-	 */
-	@SuppressWarnings("unchecked")
-	public Class<? extends Serializable> getType() throws SLGraphSessionException {
-		try {
-			return (Class<? extends Serializable>) Class.forName((String) pProperty.getValue());
-		}
-		catch (Exception e) {
-			throw new SLGraphSessionException("Error on attempt to retrieve meta node property type.", e);
-		}
-	}
-	
-	//@Override
-	/* (non-Javadoc)
-	 * @see java.lang.Object#equals(java.lang.Object)
-	 */
-	public boolean equals(Object obj) {
-		if (!(obj instanceof SLMetaNodePropertyImpl)) return false;
-		SLMetaNodePropertyImpl metaProperty = (SLMetaNodePropertyImpl) obj;
-		return pProperty.equals(metaProperty.pProperty);
-	}
-	
-	//@Override
-	/* (non-Javadoc)
-	 * @see java.lang.Object#hashCode()
-	 */
-	public int hashCode() {
-		return pProperty.hashCode();
-	}
+    /** The p property. */
+    private SLPersistentProperty<Serializable> pProperty;
 
-}
+    /**
+     * Instantiates a new sL meta node property impl.
+     * 
+     * @param metadata the metadata
+     * @param metaNode the meta node
+     * @param pProperty the property
+     */
+    SLMetaNodePropertyImpl(
+                            SLMetadata metadata, SLMetaNodeType metaNode, SLPersistentProperty<Serializable> pProperty ) {
+        this.metadata = metadata;
+        this.metaNode = metaNode;
+        this.pProperty = pProperty;
+    }
+
+    //@Override
+    /* (non-Javadoc)
+     * @see org.openspotlight.graph.SLMetaElement#getMetadata()
+     */
+    public SLMetadata getMetadata() throws SLGraphSessionException {
+        return metadata;
+    }
+
+    //@Override
+    /* (non-Javadoc)
+     * @see org.openspotlight.graph.SLMetaNodeProperty#getMetaNode()
+     */
+    public SLMetaNodeType getMetaNode() throws SLGraphSessionException {
+        return metaNode;
+    }
+
+    //@Override
+    /* (non-Javadoc)
+     * @see org.openspotlight.graph.SLMetaNodeProperty#getName()
+     */
+    public String getName() throws SLGraphSessionException {
+        try {
+            return SLCommonSupport.toSimplePropertyName(pProperty.getName());
+        } catch (SLPersistentTreeSessionException e) {
+            throw new SLGraphSessionException("Error on attempt to retrieve meta node property name.", e);
+        }
+    }
 
+    //@Override
+    /* (non-Javadoc)
+     * @see org.openspotlight.graph.SLMetaNodeProperty#getType()
+     */
+    @SuppressWarnings( "unchecked" )
+    public Class<? extends Serializable> getType() throws SLGraphSessionException {
+        try {
+            return (Class<? extends Serializable>)Class.forName((String)pProperty.getValue());
+        } catch (Exception e) {
+            throw new SLGraphSessionException("Error on attempt to retrieve meta node property type.", e);
+        }
+    }
+
+    //@Override
+    /* (non-Javadoc)
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals( Object obj ) {
+        if (!(obj instanceof SLMetaNodePropertyImpl)) return false;
+        SLMetaNodePropertyImpl metaProperty = (SLMetaNodePropertyImpl)obj;
+        return pProperty.equals(metaProperty.pProperty);
+    }
+
+    //@Override
+    /* (non-Javadoc)
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode() {
+        return pProperty.hashCode();
+    }
+}
diff --git a/osl-graph/src/main/java/org/openspotlight/graph/listeners/SLMetadataListener.java b/osl-graph/src/main/java/org/openspotlight/graph/listeners/SLMetadataListener.java
index 5a89d5f..dfc3d00 100644
--- a/osl-graph/src/main/java/org/openspotlight/graph/listeners/SLMetadataListener.java
+++ b/osl-graph/src/main/java/org/openspotlight/graph/listeners/SLMetadataListener.java
@@ -48,7 +48,6 @@
  */
 package org.openspotlight.graph.listeners;
 
-
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -85,10 +84,9 @@ import org.openspotlight.graph.persistence.SLPersistentTreeSession;
 import org.openspotlight.graph.persistence.SLPersistentTreeSessionException;
 
 /**
- * The listener interface for receiving SLMetadata events. The class that is
- * interested in processing a SLMetadata event implements this interface, and
- * the object created with that class is registered with a component using the
- * component's <code>addSLMetadataListener<code> method. When
+ * The listener interface for receiving SLMetadata events. The class that is interested in processing a SLMetadata event
+ * implements this interface, and the object created with that class is registered with a component using the component's
+ * <code>addSLMetadataListener<code> method. When
  * the SLMetadata event occurs, that object's appropriate
  * method is invoked.
  * 
@@ -97,534 +95,526 @@ import org.openspotlight.graph.persistence.SLPersistentTreeSessionException;
  */
 public class SLMetadataListener extends SLAbstractGraphSessionEventListener {
 
-	/** The meta link node cache. */
-	private final Map<LinkKey, SLPersistentNode> metaLinkNodeCache = new HashMap<LinkKey, SLPersistentNode>();
-	
-	/** The type pair node cache. */
-	private final Map<String, SLPersistentNode> typePairNodeCache = new HashMap<String, SLPersistentNode>();
-	
-	/** The session node type cache. */
-	private final Map<String, SLPersistentNode> metaNodeTypeCache = new HashMap<String, SLPersistentNode>();
-	
-	/** The node property name cache. */
-	private final Set<String> nodePropertyNameCache = new HashSet<String>();
-	
-	/** The link property key cache. */
-	private final Set<LinkPropertyKey> linkPropertyKeyCache = new HashSet<LinkPropertyKey>();
-
-	/**
-	 * Adds the description.
-	 * 
-	 * @param type the type
-	 * @param pNode the node
-	 * 
-	 * @throws SLPersistentTreeSessionException the SL persistent tree session
-	 * exception
-	 */
-	private void addDescription(final Class<?> type, final SLPersistentNode pNode) throws SLPersistentTreeSessionException {
-		final SLDescription description = type.getAnnotation(SLDescription.class);
-		if (description != null) {
-			final String propName = SLCommonSupport.toInternalPropertyName(SLConsts.PROPERTY_NAME_DESCRIPTION);
-			final SLPersistentProperty<String> prop = SLCommonSupport.getProperty(pNode, String.class, propName);
-			if (prop == null) {
-				pNode.setProperty(String.class, propName, description.value());
-			}
-		}
-	}
-
-	/**
-	 * Adds the link node.
-	 * 
-	 * @param pairKeyNode the pair key node
-	 * @param direction the direction
-	 * 
-	 * @return the sL persistent node
-	 * 
-	 * @throws SLPersistentTreeSessionException the SL persistent tree session
-	 * exception
-	 */
-	private SLPersistentNode addLinkNode(final SLPersistentNode pairKeyNode, final int direction) throws SLPersistentTreeSessionException {
-		final long linkCount = this.incLinkCount(pairKeyNode);
-		final String name = SLCommonSupport.getLinkIndexNodeName(linkCount);
-		final SLPersistentNode linkNode = pairKeyNode.addNode(name);
-		linkNode.setProperty(Long.class, SLConsts.PROPERTY_NAME_LINK_COUNT, linkCount);
-		linkNode.setProperty(Integer.class, SLConsts.PROPERTY_NAME_DIRECTION, direction);
-		return linkNode;
-	}
-
-	/**
-	 * Adds the render hints.
-	 * 
-	 * @param nodeType the node type
-	 * @param pMetaNode the meta node
-	 * 
-	 * @throws SLPersistentTreeSessionException the SL persistent tree session
-	 * exception
-	 */
-	private void addRenderHints(final Class<? extends SLNode> nodeType, final SLPersistentNode pMetaNode) throws SLPersistentTreeSessionException {
-		final SLRenderHints renderHints = nodeType.getAnnotation(SLRenderHints.class);
-		if (renderHints != null) {
-			final SLRenderHint[] renderHintArr = renderHints.value();
-			for (final SLRenderHint renderHint : renderHintArr) {
-				final String propName = SLCommonSupport.toInternalPropertyName(SLConsts.PROPERTY_NAME_RENDER_HINT + "." + renderHint.name());
-				final SLPersistentProperty<String> prop = SLCommonSupport.getProperty(pMetaNode, String.class, propName);
-				if (prop == null) {
-					pMetaNode.setProperty(String.class, propName, renderHint.value());
-				}
-			}
-		}
-	}
-
-	/**
-	 * Gets the a class.
-	 * 
-	 * @param sourceClass the source class
-	 * @param targetClass the target class
-	 * 
-	 * @return the a class
-	 * 
-	 * @throws SLException the SL exception
-	 */
-	private Class<?> getAClass(final Class<?> sourceClass, final Class<?> targetClass) throws SLException {
-		return sourceClass.getName().compareTo(targetClass.getName()) < 0 ? sourceClass : targetClass;
-	}
-
-	/**
-	 * Gets the b class.
-	 * 
-	 * @param sourceClass the source class
-	 * @param targetClass the target class
-	 * 
-	 * @return the b class
-	 * 
-	 * @throws SLException the SL exception
-	 */
-	private Class<?> getBClass(final Class<?> sourceClass, final Class<?> targetClass) throws SLException {
-		return sourceClass.getName().compareTo(targetClass.getName()) < 0 ? targetClass : sourceClass;
-	}
-
-	/**
-	 * Gets the class pair key node.
-	 * 
-	 * @param treeSession the tree session
-	 * @param linkClass the link class
-	 * @param sourceClass the source class
-	 * @param targetClass the target class
-	 * @param typePairKey the type pair key
-	 * 
-	 * @return the class pair key node
-	 * 
-	 * @throws SLException the SL exception
-	 */
-	private SLPersistentNode getTypePairKeyNode(final SLPersistentTreeSession treeSession, final Class<? extends SLLink> linkClass, final Class<?> sourceClass, final Class<?> targetClass, String typePairKey) throws SLException {
-		
-		SLPersistentNode pairKeyNode = typePairNodeCache.get(typePairKey);
-		
-		if (pairKeyNode == null) {
-
-			final Class<?> aClass = this.getAClass(sourceClass, targetClass);
-			final Class<?> bClass = this.getBClass(sourceClass, targetClass);
-
-			final SLPersistentNode linkClassNode = SLCommonSupport.getMetaLinkClassNode(treeSession, linkClass);
-			pairKeyNode = linkClassNode.getNode(typePairKey);
-
-			if (pairKeyNode == null) {
-				pairKeyNode = linkClassNode.addNode(typePairKey);
-				pairKeyNode.setProperty(String.class, SLConsts.PROPERTY_NAME_A_CLASS_NAME, aClass.getName());
-				pairKeyNode.setProperty(String.class, SLConsts.PROPERTY_NAME_B_CLASS_NAME, bClass.getName());
-				pairKeyNode.setProperty(Long.class, SLConsts.PROPERTY_NAME_LINK_COUNT, 0L);
-			}
-			
-			typePairNodeCache.put(typePairKey, pairKeyNode);
-		}
-		return pairKeyNode;
-	}
-
-	/**
-	 * Gets the meta link direction.
-	 * 
-	 * @param sourceClass the source class
-	 * @param targetClass the target class
-	 * @param bidirecional the bidirecional
-	 * 
-	 * @return the meta link direction
-	 * 
-	 * @throws SLException the SL exception
-	 */
-	private int getMetaLinkDirection(final Class<?> sourceClass, final Class<?> targetClass, final boolean bidirecional) throws SLException {
-		if (bidirecional) {
-			return SLConsts.DIRECTION_BOTH;
-		}
-		else {
-			return this.getAClass(sourceClass, targetClass).equals(sourceClass) ? SLConsts.DIRECTION_AB : SLConsts.DIRECTION_BA;
-		}
-	}
-
-	/**
-	 * Inc link count.
-	 * 
-	 * @param linkKeyPairNode the link key pair node
-	 * 
-	 * @return the long
-	 * 
-	 * @throws SLPersistentTreeSessionException the SL persistent tree session
-	 * exception
-	 */
-	private long incLinkCount(final SLPersistentNode linkKeyPairNode) throws SLPersistentTreeSessionException {
-		final SLPersistentProperty<Long> linkCountProp = linkKeyPairNode.getProperty(Long.class, SLConsts.PROPERTY_NAME_LINK_COUNT);
-		final long linkCount = linkCountProp.getValue() + 1;
-		linkCountProp.setValue(linkCount);
-		return linkCount;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see
-	 * org.openspotlight.graph.SLAbstractGraphSessionEventListener#linkAdded
-	 * (org.openspotlight.graph.SLLinkEvent)
-	 */
-	@SuppressWarnings("unchecked")
-	@Override
-	public void linkAdded(final SLLinkEvent event) throws SLGraphSessionException {
-		try {
-			final SLLink link = event.getLink();
-			final Class<? extends SLLink> linkType = (Class<? extends SLLink>) link.getClass().getInterfaces()[0];
-			
-			final SLNode[] sides = link.getSides();
-			final SLNode source = sides[0];
-			final SLNode target = sides[1];
-			final SLPersistentNode linkNode = event.getLinkNode();
-			final SLPersistentTreeSession treeSession = linkNode.getSession();
-			final Class<?> sourceClass = source.getClass().getInterfaces()[0];
-			final Class<?> targetClass = target.getClass().getInterfaces()[0];
-			String typePairKey = getTypePairKey(sourceClass, targetClass);
-			final int direction = this.getMetaLinkDirection(sourceClass, targetClass, link.isBidirectional());
-			
-			LinkKey linkKey = new LinkKey(linkType.getName(), typePairKey, direction);
-			
-			if (metaLinkNodeCache.get(linkKey) == null) {
-				
-				final SLPersistentNode classPairKeyNode = this.getTypePairKeyNode(treeSession, linkType, sourceClass, targetClass, typePairKey);
-
-				final StringBuilder statement = new StringBuilder();
-				statement.append(classPairKeyNode.getPath()).append("/*[").append(SLConsts.PROPERTY_NAME_DIRECTION).append("=").append(direction).append(']');
-
-				SLPersistentNode metaLinkNode = null;
-				final SLPersistentQuery query = treeSession.createQuery(statement.toString(), SLPersistentQuery.TYPE_XPATH);
-				final SLPersistentQueryResult result = query.execute();
-				if (result.getRowCount() == 0) {
-					metaLinkNode = this.addLinkNode(classPairKeyNode, direction);
-					this.addDescription(linkType, metaLinkNode);
-					this.metaLinkNodeCache.put(linkKey, metaLinkNode);
-				}
-
-			}
-		}
-		catch (final SLException e) {
-			throw new SLGraphSessionException("Error on attempt to add meta link node.", e);
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see
-	 * org.openspotlight.graph.SLAbstractGraphSessionEventListener#linkPropertySet
-	 * (org.openspotlight.graph.SLLinkPropertyEvent)
-	 */
-	@SuppressWarnings("unchecked")
-	@Override
-	public void linkPropertySet(final SLLinkPropertyEvent event) throws SLGraphSessionException {
-
-		try {
-
-			SLLinkProperty<? extends Serializable> linkProperty = event.getProperty();
-			
-			SLLink link = linkProperty.getLink();
-			final Class<? extends SLLink> linkType = (Class<? extends SLLink>) link.getClass().getInterfaces()[0];
-			final SLNode[] sides = link.getSides();
-			final SLNode source = sides[0];
-			final SLNode target = sides[1];
-			final SLPersistentNode linkNode = event.getPersistentProperty().getNode();
-			final SLPersistentTreeSession treeSession = linkNode.getSession();
-			final Class<?> sourceClass = source.getClass().getInterfaces()[0];
-			final Class<?> targetClass = target.getClass().getInterfaces()[0];
-			String typePairKey = getTypePairKey(sourceClass, targetClass);
-			final int direction = this.getMetaLinkDirection(sourceClass, targetClass, link.isBidirectional());
-			
-			LinkKey linkKey = new LinkKey(linkType.getName(), typePairKey, direction);
-			LinkPropertyKey propertyKey = new LinkPropertyKey(linkKey, event.getProperty().getName());
-			
-			if (!linkPropertyKeyCache.contains(propertyKey)) {
-				
-				SLPersistentNode metaLinkNode = metaLinkNodeCache.get(linkKey);
-				if (metaLinkNode == null) {
-					
-					SLPersistentNode classPairKeyNode = getTypePairKeyNode(treeSession, linkType, sourceClass, targetClass, typePairKey);
-					
-					final StringBuilder statement = new StringBuilder();
-					statement.append(classPairKeyNode.getPath()).append("/*[").append(SLConsts.PROPERTY_NAME_DIRECTION).append("=").append(direction).append(']');
-
-					final SLPersistentQuery query = treeSession.createQuery(statement.toString(), SLPersistentQuery.TYPE_XPATH);
-					final SLPersistentQueryResult result = query.execute();
-					if (result.getRowCount() == 1) {
-						metaLinkNode = result.getNodes().iterator().next();
-					}
-				}
-				
-				String propName = SLCommonSupport.toUserPropertyName(linkProperty.getName());
-				metaLinkNode.setProperty(String.class, propName, linkProperty.getValue().getClass().getName());
-				linkPropertyKeyCache.add(propertyKey);
-			}
-		}
-		catch (final SLException e) {
-			throw new SLGraphSessionException("Error on attempt to set meta link property.", e);
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see
-	 * org.openspotlight.graph.SLAbstractGraphSessionEventListener#nodeAdded
-	 * (org.openspotlight.graph.SLNodeEvent)
-	 */
-	@Override
-	@SuppressWarnings("unchecked")
-	public void nodeAdded(final SLNodeEvent event) throws SLGraphSessionException {
-		
-		try {
-			
-			final SLPersistentNode pNode = event.getPersistentNode();
-			String typeName = SLCommonSupport.getNodeTypeName(pNode);
-			
-			final Class<? extends SLNode> nodeType = (Class<? extends SLNode>) event.getNode().getClass().getInterfaces()[0];
-			if (nodeType.equals(SLNode.class) || this.metaNodeTypeCache.get(typeName) != null) {
-				return;
-			}
-			
-			final SLPersistentTreeSession treeSession = pNode.getSession();
-			SLPersistentNode pMetaNodeTypeParent = SLCommonSupport.getMetaTypesNode(treeSession);
-
-			final Collection<Class<? extends SLNode>> nodeTypeHierarchy = this.getNodeTypeHierarchy(nodeType);
-			for (Class<? extends SLNode> currentNodeType : nodeTypeHierarchy) {
-			 	SLPersistentNode pMetaNodeType = pMetaNodeTypeParent.getNode(currentNodeType.getName());
-			 	if (pMetaNodeType == null) {
-			 		pMetaNodeTypeParent = pMetaNodeTypeParent.addNode(currentNodeType.getName());
-			 		pMetaNodeTypeParent.setProperty(String.class, SLConsts.PROPERTY_NAME_NODE_TYPE, currentNodeType.getName());
-					this.addRenderHints(nodeType, pMetaNodeTypeParent);
-					this.addDescription(nodeType, pMetaNodeTypeParent);
-			 	}
-			 	else {
-			 		pMetaNodeTypeParent = pMetaNodeType;
-			 	}
-			 	this.metaNodeTypeCache.put(currentNodeType.getName(), pMetaNodeTypeParent);
-			}
-		}
-		catch (final SLPersistentTreeSessionException e) {
-			throw new SLGraphSessionException("Error on attempt to add node metadata.", e);
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see
-	 * org.openspotlight.graph.SLAbstractGraphSessionEventListener#nodePropertySet
-	 * (org.openspotlight.graph.SLNodePropertyEvent)
-	 */
-	@Override
-	public void nodePropertySet(final SLNodePropertyEvent event) throws SLGraphSessionException {
-		
-		try {
-			final SLPersistentProperty<? extends Serializable> pProperty = event.getPersistentProperty();
-			final SLPersistentNode pNode = pProperty.getNode();
-			String typeName = SLCommonSupport.getNodeTypeName(pNode);
-			String propertyName = pProperty.getName();
-			
-			String fullPropertyName = typeName + "." + propertyName;
-			if (!nodePropertyNameCache.contains(fullPropertyName)) {
-				SLPersistentNode metaNodeType = getMetaNodeType(pNode.getSession(), typeName);
-				if (metaNodeType != null) {
-					metaNodeType.setProperty(String.class, propertyName, pProperty.getValue().getClass().getName());
-					nodePropertyNameCache.add(fullPropertyName);
-				}
-			}
-		}
-		catch (final SLPersistentTreeSessionException e) {
-			throw new SLGraphSessionException("Error on attempt to set meta node property.", e);
-		}
-	}
-
-	/**
-	 * 
-	 * {@inheritDoc}
-	 */
-	public void sessionCleaned() {
-		this.typePairNodeCache.clear();
-		this.metaNodeTypeCache.clear();
-		this.metaLinkNodeCache.clear();
-		this.nodePropertyNameCache.clear();
-		this.linkPropertyKeyCache.clear();
-	}
-	
-	@Override
-	public void beforeSave(SLGraphSessionEvent event) throws SLGraphSessionException {
-		sessionCleaned();
-	}
-	
-	/**
-	 * Gets the node type hierarchy.
-	 * 
-	 * @param nodeType the node type
-	 * 
-	 * @return the node type hierarchy
-	 */
-	private Collection<Class<? extends SLNode>> getNodeTypeHierarchy(Class<? extends SLNode> nodeType) {
-		List<Class<? extends SLNode>> nodeTypes = new ArrayList<Class<? extends SLNode>>();
-		addNodeTypeInHierarchy(nodeTypes, nodeType);
-		return nodeTypes;
-	}
-
-	
-	/**
-	 * Adds the node type in hierarchy.
-	 * 
-	 * @param nodeTypes the node types
-	 * @param nodeType the node type
-	 */
-	@SuppressWarnings("unchecked")
-	private void addNodeTypeInHierarchy(List<Class<? extends SLNode>> nodeTypes, Class<? extends SLNode> nodeType) {
-		nodeTypes.add(0, nodeType);
-		Class<? extends SLNode> superNodeType = (Class<? extends SLNode>) nodeType.getInterfaces()[0];
-		if (superNodeType != null && !superNodeType.equals(SLNode.class)) {
-			addNodeTypeInHierarchy(nodeTypes, superNodeType);
-		}
-	}
-
-	
-	/**
-	 * Gets the meta node type.
-	 * 
-	 * @param typeName the type name
-	 * @param treeSession the tree session
-	 * 
-	 * @return the meta node type
-	 * 
-	 * @throws SLPersistentTreeSessionException the SL persistent tree session exception
-	 */
-	private SLPersistentNode getMetaNodeType(SLPersistentTreeSession treeSession, String typeName) throws SLPersistentTreeSessionException {
-		SLPersistentNode metaNodeType = metaNodeTypeCache.get(typeName);
-		if (metaNodeType == null) {
-			StringBuilder statement = new StringBuilder("//osl/metadata/types//*");
-			StringBuilderUtil.append(statement, '[', SLConsts.PROPERTY_NAME_NODE_TYPE, "='", typeName, "']");
-			SLPersistentQuery query = treeSession.createQuery(statement.toString(), SLPersistentQuery.TYPE_XPATH);
-			SLPersistentQueryResult result = query.execute();
-			if (result.getRowCount() == 1) {
-				metaNodeType = result.getNodes().iterator().next();
-			}
-		}
-		return metaNodeType;
-	}
-	
-	/**
-	 * Gets the type pair key.
-	 * 
-	 * @param sourceClass the source class
-	 * @param targetClass the target class
-	 * 
-	 * @return the type pair key
-	 * 
-	 * @throws SLException the SL exception
-	 */
-	private String getTypePairKey(Class<?> sourceClass, Class<?> targetClass) throws SLException {
-		final Class<?> aClass = this.getAClass(sourceClass, targetClass);
-		final Class<?> bClass = this.getBClass(sourceClass, targetClass);
-		final StringBuilder pairKey = new StringBuilder();
-		pairKey.append(aClass.getName()).append('.').append(bClass.getName());
-		return pairKey.toString();
-	}
+    /** The meta link node cache. */
+    private final Map<LinkKey, SLPersistentNode> metaLinkNodeCache     = new HashMap<LinkKey, SLPersistentNode>();
+
+    /** The type pair node cache. */
+    private final Map<String, SLPersistentNode>  typePairNodeCache     = new HashMap<String, SLPersistentNode>();
+
+    /** The session node type cache. */
+    private final Map<String, SLPersistentNode>  metaNodeTypeCache     = new HashMap<String, SLPersistentNode>();
+
+    /** The node property name cache. */
+    private final Set<String>                    nodePropertyNameCache = new HashSet<String>();
+
+    /** The link property key cache. */
+    private final Set<LinkPropertyKey>           linkPropertyKeyCache  = new HashSet<LinkPropertyKey>();
+
+    /**
+     * Adds the description.
+     * 
+     * @param type the type
+     * @param pNode the node
+     * @throws SLPersistentTreeSessionException the SL persistent tree session exception
+     */
+    private void addDescription( final Class<?> type,
+                                 final SLPersistentNode pNode ) throws SLPersistentTreeSessionException {
+        final SLDescription description = type.getAnnotation(SLDescription.class);
+        if (description != null) {
+            final String propName = SLCommonSupport.toInternalPropertyName(SLConsts.PROPERTY_NAME_DESCRIPTION);
+            final SLPersistentProperty<String> prop = SLCommonSupport.getProperty(pNode, String.class, propName);
+            if (prop == null) {
+                pNode.setProperty(String.class, propName, description.value());
+            }
+        }
+    }
+
+    /**
+     * Adds the link node.
+     * 
+     * @param pairKeyNode the pair key node
+     * @param direction the direction
+     * @return the sL persistent node
+     * @throws SLPersistentTreeSessionException the SL persistent tree session exception
+     */
+    private SLPersistentNode addLinkNode( final SLPersistentNode pairKeyNode,
+                                          final int direction ) throws SLPersistentTreeSessionException {
+        final long linkCount = this.incLinkCount(pairKeyNode);
+        final String name = SLCommonSupport.getLinkIndexNodeName(linkCount);
+        final SLPersistentNode linkNode = pairKeyNode.addNode(name);
+        linkNode.setProperty(Long.class, SLConsts.PROPERTY_NAME_LINK_COUNT, linkCount);
+        linkNode.setProperty(Integer.class, SLConsts.PROPERTY_NAME_DIRECTION, direction);
+        return linkNode;
+    }
+
+    /**
+     * Adds the render hints.
+     * 
+     * @param nodeType the node type
+     * @param pMetaNode the meta node
+     * @throws SLPersistentTreeSessionException the SL persistent tree session exception
+     */
+    private void addRenderHints( final Class<? extends SLNode> nodeType,
+                                 final SLPersistentNode pMetaNode ) throws SLPersistentTreeSessionException {
+        final SLRenderHints renderHints = nodeType.getAnnotation(SLRenderHints.class);
+        if (renderHints != null) {
+            final SLRenderHint[] renderHintArr = renderHints.value();
+            for (final SLRenderHint renderHint : renderHintArr) {
+                final String propName = SLCommonSupport.toInternalPropertyName(SLConsts.PROPERTY_NAME_RENDER_HINT + "." + renderHint.name());
+                final SLPersistentProperty<String> prop = SLCommonSupport.getProperty(pMetaNode, String.class, propName);
+                if (prop == null) {
+                    pMetaNode.setProperty(String.class, propName, renderHint.value());
+                }
+            }
+        }
+    }
+
+    /**
+     * Gets the a class.
+     * 
+     * @param sourceClass the source class
+     * @param targetClass the target class
+     * @return the a class
+     * @throws SLException the SL exception
+     */
+    private Class<?> getAClass( final Class<?> sourceClass,
+                                final Class<?> targetClass ) throws SLException {
+        return sourceClass.getName().compareTo(targetClass.getName()) < 0 ? sourceClass : targetClass;
+    }
+
+    /**
+     * Gets the b class.
+     * 
+     * @param sourceClass the source class
+     * @param targetClass the target class
+     * @return the b class
+     * @throws SLException the SL exception
+     */
+    private Class<?> getBClass( final Class<?> sourceClass,
+                                final Class<?> targetClass ) throws SLException {
+        return sourceClass.getName().compareTo(targetClass.getName()) < 0 ? targetClass : sourceClass;
+    }
+
+    /**
+     * Gets the class pair key node.
+     * 
+     * @param treeSession the tree session
+     * @param linkClass the link class
+     * @param sourceClass the source class
+     * @param targetClass the target class
+     * @param typePairKey the type pair key
+     * @return the class pair key node
+     * @throws SLException the SL exception
+     */
+    private SLPersistentNode getTypePairKeyNode( final SLPersistentTreeSession treeSession,
+                                                 final Class<? extends SLLink> linkClass,
+                                                 final Class<?> sourceClass,
+                                                 final Class<?> targetClass,
+                                                 String typePairKey ) throws SLException {
+
+        SLPersistentNode pairKeyNode = typePairNodeCache.get(typePairKey);
+
+        if (pairKeyNode == null) {
+
+            final Class<?> aClass = this.getAClass(sourceClass, targetClass);
+            final Class<?> bClass = this.getBClass(sourceClass, targetClass);
+
+            final SLPersistentNode linkClassNode = SLCommonSupport.getMetaLinkClassNode(treeSession, linkClass);
+            pairKeyNode = linkClassNode.getNode(typePairKey);
+
+            if (pairKeyNode == null) {
+                pairKeyNode = linkClassNode.addNode(typePairKey);
+                pairKeyNode.setProperty(String.class, SLConsts.PROPERTY_NAME_A_CLASS_NAME, aClass.getName());
+                pairKeyNode.setProperty(String.class, SLConsts.PROPERTY_NAME_B_CLASS_NAME, bClass.getName());
+                pairKeyNode.setProperty(Long.class, SLConsts.PROPERTY_NAME_LINK_COUNT, 0L);
+            }
+
+            typePairNodeCache.put(typePairKey, pairKeyNode);
+        }
+        return pairKeyNode;
+    }
+
+    /**
+     * Gets the meta link direction.
+     * 
+     * @param sourceClass the source class
+     * @param targetClass the target class
+     * @param bidirecional the bidirecional
+     * @return the meta link direction
+     * @throws SLException the SL exception
+     */
+    private int getMetaLinkDirection( final Class<?> sourceClass,
+                                      final Class<?> targetClass,
+                                      final boolean bidirecional ) throws SLException {
+        if (bidirecional) {
+            return SLConsts.DIRECTION_BOTH;
+        } else {
+            return this.getAClass(sourceClass, targetClass).equals(sourceClass) ? SLConsts.DIRECTION_AB : SLConsts.DIRECTION_BA;
+        }
+    }
+
+    /**
+     * Inc link count.
+     * 
+     * @param linkKeyPairNode the link key pair node
+     * @return the long
+     * @throws SLPersistentTreeSessionException the SL persistent tree session exception
+     */
+    private long incLinkCount( final SLPersistentNode linkKeyPairNode ) throws SLPersistentTreeSessionException {
+        final SLPersistentProperty<Long> linkCountProp = linkKeyPairNode.getProperty(Long.class, SLConsts.PROPERTY_NAME_LINK_COUNT);
+        final long linkCount = linkCountProp.getValue() + 1;
+        linkCountProp.setValue(linkCount);
+        return linkCount;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.openspotlight.graph.SLAbstractGraphSessionEventListener#linkAdded
+     * (org.openspotlight.graph.SLLinkEvent)
+     */
+    @SuppressWarnings( "unchecked" )
+    @Override
+    public void linkAdded( final SLLinkEvent event ) throws SLGraphSessionException {
+        try {
+            final SLLink link = event.getLink();
+            final Class<? extends SLLink> linkType = (Class<? extends SLLink>)link.getClass().getInterfaces()[0];
+
+            final SLNode[] sides = link.getSides();
+            final SLNode source = sides[0];
+            final SLNode target = sides[1];
+            final SLPersistentNode linkNode = event.getLinkNode();
+            final SLPersistentTreeSession treeSession = linkNode.getSession();
+            final Class<?> sourceClass = source.getClass().getInterfaces()[0];
+            final Class<?> targetClass = target.getClass().getInterfaces()[0];
+            String typePairKey = getTypePairKey(sourceClass, targetClass);
+            final int direction = this.getMetaLinkDirection(sourceClass, targetClass, link.isBidirectional());
+
+            LinkKey linkKey = new LinkKey(linkType.getName(), typePairKey, direction);
+
+            if (metaLinkNodeCache.get(linkKey) == null) {
+
+                final SLPersistentNode classPairKeyNode = this.getTypePairKeyNode(treeSession, linkType, sourceClass, targetClass, typePairKey);
+
+                final StringBuilder statement = new StringBuilder();
+                statement.append(classPairKeyNode.getPath()).append("/*[").append(SLConsts.PROPERTY_NAME_DIRECTION).append("=").append(direction).append(']');
+
+                SLPersistentNode metaLinkNode = null;
+                final SLPersistentQuery query = treeSession.createQuery(statement.toString(), SLPersistentQuery.TYPE_XPATH);
+                final SLPersistentQueryResult result = query.execute();
+                if (result.getRowCount() == 0) {
+                    metaLinkNode = this.addLinkNode(classPairKeyNode, direction);
+                    this.addDescription(linkType, metaLinkNode);
+                    this.metaLinkNodeCache.put(linkKey, metaLinkNode);
+                }
+
+            }
+        } catch (final SLException e) {
+            throw new SLGraphSessionException("Error on attempt to add meta link node.", e);
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.openspotlight.graph.SLAbstractGraphSessionEventListener#linkPropertySet
+     * (org.openspotlight.graph.SLLinkPropertyEvent)
+     */
+    @SuppressWarnings( "unchecked" )
+    @Override
+    public void linkPropertySet( final SLLinkPropertyEvent event ) throws SLGraphSessionException {
+
+        try {
+
+            SLLinkProperty<? extends Serializable> linkProperty = event.getProperty();
+
+            SLLink link = linkProperty.getLink();
+            final Class<? extends SLLink> linkType = (Class<? extends SLLink>)link.getClass().getInterfaces()[0];
+            final SLNode[] sides = link.getSides();
+            final SLNode source = sides[0];
+            final SLNode target = sides[1];
+            final SLPersistentNode linkNode = event.getPersistentProperty().getNode();
+            final SLPersistentTreeSession treeSession = linkNode.getSession();
+            final Class<?> sourceClass = source.getClass().getInterfaces()[0];
+            final Class<?> targetClass = target.getClass().getInterfaces()[0];
+            String typePairKey = getTypePairKey(sourceClass, targetClass);
+            final int direction = this.getMetaLinkDirection(sourceClass, targetClass, link.isBidirectional());
+
+            LinkKey linkKey = new LinkKey(linkType.getName(), typePairKey, direction);
+            LinkPropertyKey propertyKey = new LinkPropertyKey(linkKey, event.getProperty().getName());
+
+            if (!linkPropertyKeyCache.contains(propertyKey)) {
+
+                SLPersistentNode metaLinkNode = metaLinkNodeCache.get(linkKey);
+                if (metaLinkNode == null) {
+
+                    SLPersistentNode classPairKeyNode = getTypePairKeyNode(treeSession, linkType, sourceClass, targetClass, typePairKey);
+
+                    final StringBuilder statement = new StringBuilder();
+                    statement.append(classPairKeyNode.getPath()).append("/*[").append(SLConsts.PROPERTY_NAME_DIRECTION).append("=").append(direction).append(']');
+
+                    final SLPersistentQuery query = treeSession.createQuery(statement.toString(), SLPersistentQuery.TYPE_XPATH);
+                    final SLPersistentQueryResult result = query.execute();
+                    if (result.getRowCount() == 1) {
+                        metaLinkNode = result.getNodes().iterator().next();
+                    }
+                }
+
+                String propName = SLCommonSupport.toUserPropertyName(linkProperty.getName());
+                metaLinkNode.setProperty(String.class, propName, linkProperty.getValue().getClass().getName());
+                linkPropertyKeyCache.add(propertyKey);
+            }
+        } catch (final SLException e) {
+            throw new SLGraphSessionException("Error on attempt to set meta link property.", e);
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.openspotlight.graph.SLAbstractGraphSessionEventListener#nodeAdded
+     * (org.openspotlight.graph.SLNodeEvent)
+     */
+    @Override
+    @SuppressWarnings( "unchecked" )
+    public void nodeAdded( final SLNodeEvent event ) throws SLGraphSessionException {
+
+        try {
+
+            final SLPersistentNode pNode = event.getPersistentNode();
+            String typeName = SLCommonSupport.getNodeTypeName(pNode);
+
+            final Class<? extends SLNode> nodeType = (Class<? extends SLNode>)event.getNode().getClass().getInterfaces()[0];
+            if (nodeType.equals(SLNode.class) || this.metaNodeTypeCache.get(typeName) != null) {
+                return;
+            }
+
+            final SLPersistentTreeSession treeSession = pNode.getSession();
+            SLPersistentNode pMetaNodeTypeParent = SLCommonSupport.getMetaTypesNode(treeSession);
+
+            final Collection<Class<? extends SLNode>> nodeTypeHierarchy = this.getNodeTypeHierarchy(nodeType);
+            for (Class<? extends SLNode> currentNodeType : nodeTypeHierarchy) {
+                SLPersistentNode pMetaNodeType = pMetaNodeTypeParent.getNode(currentNodeType.getName());
+                if (pMetaNodeType == null) {
+                    pMetaNodeTypeParent = pMetaNodeTypeParent.addNode(currentNodeType.getName());
+                    pMetaNodeTypeParent.setProperty(String.class, SLConsts.PROPERTY_NAME_NODE_TYPE, currentNodeType.getName());
+                    this.addRenderHints(nodeType, pMetaNodeTypeParent);
+                    this.addDescription(nodeType, pMetaNodeTypeParent);
+                } else {
+                    pMetaNodeTypeParent = pMetaNodeType;
+                }
+                this.metaNodeTypeCache.put(currentNodeType.getName(), pMetaNodeTypeParent);
+            }
+        } catch (final SLPersistentTreeSessionException e) {
+            throw new SLGraphSessionException("Error on attempt to add node metadata.", e);
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.openspotlight.graph.SLAbstractGraphSessionEventListener#nodePropertySet
+     * (org.openspotlight.graph.SLNodePropertyEvent)
+     */
+    @Override
+    public void nodePropertySet( final SLNodePropertyEvent event ) throws SLGraphSessionException {
+
+        try {
+            final SLPersistentProperty<? extends Serializable> pProperty = event.getPersistentProperty();
+            final SLPersistentNode pNode = pProperty.getNode();
+            String typeName = SLCommonSupport.getNodeTypeName(pNode);
+            String propertyName = pProperty.getName();
+
+            String fullPropertyName = typeName + "." + propertyName;
+            if (!nodePropertyNameCache.contains(fullPropertyName)) {
+                SLPersistentNode metaNodeType = getMetaNodeType(pNode.getSession(), typeName);
+                if (metaNodeType != null) {
+                    metaNodeType.setProperty(String.class, propertyName, pProperty.getValue().getClass().getName());
+                    nodePropertyNameCache.add(fullPropertyName);
+                }
+            }
+        } catch (final SLPersistentTreeSessionException e) {
+            throw new SLGraphSessionException("Error on attempt to set meta node property.", e);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void sessionCleaned() {
+        this.typePairNodeCache.clear();
+        this.metaNodeTypeCache.clear();
+        this.metaLinkNodeCache.clear();
+        this.nodePropertyNameCache.clear();
+        this.linkPropertyKeyCache.clear();
+    }
+
+    @Override
+    public void beforeSave( SLGraphSessionEvent event ) throws SLGraphSessionException {
+        sessionCleaned();
+    }
+
+    /**
+     * Gets the node type hierarchy.
+     * 
+     * @param nodeType the node type
+     * @return the node type hierarchy
+     */
+    private Collection<Class<? extends SLNode>> getNodeTypeHierarchy( Class<? extends SLNode> nodeType ) {
+        List<Class<? extends SLNode>> nodeTypes = new ArrayList<Class<? extends SLNode>>();
+        addNodeTypeInHierarchy(nodeTypes, nodeType);
+        return nodeTypes;
+    }
+
+    /**
+     * Adds the node type in hierarchy.
+     * 
+     * @param nodeTypes the node types
+     * @param nodeType the node type
+     */
+    @SuppressWarnings( "unchecked" )
+    private void addNodeTypeInHierarchy( List<Class<? extends SLNode>> nodeTypes,
+                                         Class<? extends SLNode> nodeType ) {
+        nodeTypes.add(0, nodeType);
+        Class<? extends SLNode> superNodeType = (Class<? extends SLNode>)nodeType.getInterfaces()[0];
+        if (superNodeType != null && !superNodeType.equals(SLNode.class)) {
+            addNodeTypeInHierarchy(nodeTypes, superNodeType);
+        }
+    }
+
+    /**
+     * Gets the meta node type.
+     * 
+     * @param typeName the type name
+     * @param treeSession the tree session
+     * @return the meta node type
+     * @throws SLPersistentTreeSessionException the SL persistent tree session exception
+     */
+    private SLPersistentNode getMetaNodeType( SLPersistentTreeSession treeSession,
+                                              String typeName ) throws SLPersistentTreeSessionException {
+        SLPersistentNode metaNodeType = metaNodeTypeCache.get(typeName);
+        if (metaNodeType == null) {
+            StringBuilder statement = new StringBuilder("//osl/metadata/types//*");
+            StringBuilderUtil.append(statement, '[', SLConsts.PROPERTY_NAME_NODE_TYPE, "='", typeName, "']");
+            SLPersistentQuery query = treeSession.createQuery(statement.toString(), SLPersistentQuery.TYPE_XPATH);
+            SLPersistentQueryResult result = query.execute();
+            if (result.getRowCount() == 1) {
+                metaNodeType = result.getNodes().iterator().next();
+            }
+        }
+        return metaNodeType;
+    }
+
+    /**
+     * Gets the type pair key.
+     * 
+     * @param sourceClass the source class
+     * @param targetClass the target class
+     * @return the type pair key
+     * @throws SLException the SL exception
+     */
+    private String getTypePairKey( Class<?> sourceClass,
+                                   Class<?> targetClass ) throws SLException {
+        final Class<?> aClass = this.getAClass(sourceClass, targetClass);
+        final Class<?> bClass = this.getBClass(sourceClass, targetClass);
+        final StringBuilder pairKey = new StringBuilder();
+        pairKey.append(aClass.getName()).append('.').append(bClass.getName());
+        return pairKey.toString();
+    }
 }
 
 class LinkKey implements Serializable {
-	
-	private static final long serialVersionUID = 1L;
-	
-	private String linkTypeName;
-	private String typePairKey;
-	private int direction;
-	
-	public LinkKey(String linkTypeName, String typePairKey, int direction) {
-		this.linkTypeName = linkTypeName;
-		this.typePairKey = typePairKey;
-		this.direction = direction;
-	}
-	
-	public String getLinkType() {
-		return linkTypeName;
-	}
-	public void setLinkType(String linkTypeName) {
-		this.linkTypeName = linkTypeName;
-	}
-	public String getTypePairKey() {
-		return typePairKey;
-	}
-	public void setTypePairKey(String typePairKey) {
-		this.typePairKey = typePairKey;
-	}
-	public int getDirection() {
-		return direction;
-	}
-	public void setDirection(int direction) {
-		this.direction = direction;
-	}
-	
-	@Override
-	public int hashCode() {
-		return HashCodes.hashOf(linkTypeName, typePairKey, direction);
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		LinkKey key = (LinkKey) obj;
-		return Equals.eachEquality(new Object[] {linkTypeName, typePairKey, direction}, new Object[] {key.linkTypeName, key.typePairKey, key.direction});
-	}
+
+    private static final long serialVersionUID = 1L;
+
+    private String            linkTypeName;
+    private String            typePairKey;
+    private int               direction;
+
+    public LinkKey(
+                    String linkTypeName, String typePairKey, int direction ) {
+        this.linkTypeName = linkTypeName;
+        this.typePairKey = typePairKey;
+        this.direction = direction;
+    }
+
+    public String getLinkType() {
+        return linkTypeName;
+    }
+
+    public void setLinkType( String linkTypeName ) {
+        this.linkTypeName = linkTypeName;
+    }
+
+    public String getTypePairKey() {
+        return typePairKey;
+    }
+
+    public void setTypePairKey( String typePairKey ) {
+        this.typePairKey = typePairKey;
+    }
+
+    public int getDirection() {
+        return direction;
+    }
+
+    public void setDirection( int direction ) {
+        this.direction = direction;
+    }
+
+    @Override
+    public int hashCode() {
+        return HashCodes.hashOf(linkTypeName, typePairKey, direction);
+    }
+
+    @Override
+    public boolean equals( Object obj ) {
+        LinkKey key = (LinkKey)obj;
+        return Equals.eachEquality(new Object[] {linkTypeName, typePairKey, direction}, new Object[] {key.linkTypeName, key.typePairKey, key.direction});
+    }
 }
 
 class LinkPropertyKey implements Serializable {
 
-	private static final long serialVersionUID = 1L;
-	
-	private LinkKey linkKey;
-	private String name;
-	
-	public LinkPropertyKey(LinkKey linkKey, String name) {
-		this.linkKey = linkKey;
-		this.name = name;
-	}
-	
-	public LinkKey getLinkKey() {
-		return linkKey;
-	}
-	public void setLinkKey(LinkKey linkKey) {
-		this.linkKey = linkKey;
-	}
-	public String getName() {
-		return name;
-	}
-	public void setName(String name) {
-		this.name = name;
-	}
-	
-	@Override
-	public int hashCode() {
-		return HashCodes.hashOf(linkKey.getLinkType(), linkKey.getTypePairKey(), linkKey.getDirection(), name);
-	}
-	
-	@Override
-	public boolean equals(Object obj) {
-		LinkPropertyKey key = (LinkPropertyKey) obj;
-		return Equals.eachEquality(new Object[] {linkKey, name}, new Object[] {key.linkKey, key.name});
-	}
+    private static final long serialVersionUID = 1L;
+
+    private LinkKey           linkKey;
+    private String            name;
+
+    public LinkPropertyKey(
+                            LinkKey linkKey, String name ) {
+        this.linkKey = linkKey;
+        this.name = name;
+    }
+
+    public LinkKey getLinkKey() {
+        return linkKey;
+    }
+
+    public void setLinkKey( LinkKey linkKey ) {
+        this.linkKey = linkKey;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName( String name ) {
+        this.name = name;
+    }
+
+    @Override
+    public int hashCode() {
+        return HashCodes.hashOf(linkKey.getLinkType(), linkKey.getTypePairKey(), linkKey.getDirection(), name);
+    }
+
+    @Override
+    public boolean equals( Object obj ) {
+        LinkPropertyKey key = (LinkPropertyKey)obj;
+        return Equals.eachEquality(new Object[] {linkKey, name}, new Object[] {key.linkKey, key.name});
+    }
 }
