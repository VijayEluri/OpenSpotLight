

// global variables to be reused for each type

import org.junit.Before;
import org.junit.Test;
import org.objectweb.asm.Opcodes;
import org.openspotlight.graph.SLGraph;
import org.openspotlight.graph.SLGraphFactory;
import org.openspotlight.graph.SLGraphFactoryImpl;
import org.openspotlight.graph.SLGraphSession;
import org.openspotlight.graph.SLNode;
import org.openspotlight.bundle.dap.language.java.metamodel.link.*;
import org.openspotlight.bundle.dap.language.java.metamodel.node.*;
import org.openspotlight.bundle.dap.language.java.support.JavaGraphNodeSupport;
import java.util.Map;
import java.util.TreeMap;

SLGraphFactory factory = new SLGraphFactoryImpl();
SLGraph graph = factory.createTempGraph(true);
SLGraphSession session = graph.openSession();
SLNode currentContextRootNode = session.createContext("sample").getRootNode();
SLNode abstractContextRootNode = session.createContext("abstractJavaContext").getRootNode();

JavaGraphNodeSupport helper = new JavaGraphNodeSupport(session, currentContextRootNode,abstractContextRootNode);

// global variables to be reused for each type
JavaType newType;
JavaPackage newPackage;
JavaType newSuperType;
JavaPackage newSuperPackage;
JavaType fieldType;
JavaPackage fieldPackage;
JavaDataField field;
JavaMethod method;
JavaDataParameter parameter;
PackageType packageTypeLink;
PackageType fieldPackageTypeLink;
DataType fieldTypeLink;
boolean isPublic;
boolean isPrivate;
boolean isStatic;
boolean isFinal;
boolean isProtected;
boolean isFieldPublic;
boolean isFieldPrivate;
boolean isFieldStatic;
boolean isFieldFinal;
boolean isFieldProtected;
boolean isFieldTransient;
boolean isFieldVolatile;
boolean isMethodPublic;
boolean isMethodPrivate;
boolean isMethodStatic;
boolean isMethodFinal;
boolean isMethodProtected;
boolean isMethodSynchronized;
PackageType superPackageTypeLink;
TypeDeclares typeDeclaresMethod;
JavaType methodReturnTypeType;
MethodReturns methodReturnsType;
JavaPackage methodParameterTypePackage;
JavaType methodParameterTypeType;
PackageType methodParameterTypePackageTypeLink;
MethodParameterDefinition methodParametersType;
JavaPackage newExceptionPackage;
JavaType newExceptionType;
PackageType exceptionPackageTypeLink;
MethodThrows methodThrowsType;
JavaPackage methodReturnTypePackage;
PackageType methodReturnTypePackageTypeLink;
String arraySquareBrackets;
Extends extendsSuper;
Implements implementsSuper;
boolean isArray = false;
int arrayDimensions = 0;

newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractCollection", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$Itr", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$ListItr", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$1$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$2$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$2", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$SimpleEntry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractQueue", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractSequentialList", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractSet", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ArrayList", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Arrays$ArrayList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Arrays", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "BitSet", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Calendar$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Calendar$CalendarAccessControlContext", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Calendar", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Collection", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedCollection$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedCollection", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedList$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet$CheckedEntry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedRandomAccessList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSortedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSortedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CopiesList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptyList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptyMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptySet$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$ReverseComparator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$ReverseComparator2", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Collections$SelfComparable", 1536);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonMap$ImmutableEntry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonSet$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedCollection", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedRandomAccessList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSortedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSortedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableCollection$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableCollection", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableList$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableRandomAccessList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSortedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSortedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Comparator", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ConcurrentModificationException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Currency$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Currency", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "CurrencyData", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Date", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Dictionary", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "DuplicateFormatFlagsException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EmptyStackException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Enumeration", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EnumMapIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$Values", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumSet$SerializationProxy", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumSet", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "EventListener", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EventListenerProxy", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EventObject", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "FormatFlagsConversionMismatchException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Formattable", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "FormattableFlags", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeEnum.class,"java.util", "Formatter$BigDecimalLayoutForm", 16433);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$Conversion", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$DateTime", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FixedString", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$Flags", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FormatSpecifier$BigDecimalLayout", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FormatSpecifier", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Formatter$FormatString", 1536);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "FormatterClosedException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "GregorianCalendar", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$HashIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$Values", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashSet", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EmptyEnumerator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EmptyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$Enumerator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$ValueCollection", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$IdentityHashMapIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$Values", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatCodePointException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatConversionException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatFlagsException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatPrecisionException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatWidthException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "InputMismatchException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "InvalidPropertiesFormatException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Iterator", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "JumboEnumSet$EnumSetIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "JumboEnumSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$LinkedHashIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashSet", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList$ListItr", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "List", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "ListIterator", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ListResourceBundle", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Locale", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Map$Entry", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Map", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "MissingFormatArgumentException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "MissingFormatWidthException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "MissingResourceException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "NoSuchElementException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Observable", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Observer", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue$Itr", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Properties$LineReader", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Properties", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PropertyPermission", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PropertyPermissionCollection", 48);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PropertyResourceBundle", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Queue", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Random", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "RandomAccess", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "RandomAccessSubList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "RegularEnumSet$EnumSetIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "RegularEnumSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$LoaderReference", 48);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$ResourceCacheKey", 48);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundleEnumeration", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Scanner$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Scanner", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Set", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "SimpleTimeZone", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "SortedMap", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "SortedSet", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Stack", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "StringTokenizer", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "SubList$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "SubList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TaskQueue", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Timer$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Timer", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimerTask", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimerThread", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone$DisplayNames", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TooManyListenersException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$2", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$3", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$PrivateEntryIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMap$EntrySetView", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMapEntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeSet", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "UnknownFormatConversionException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "UnknownFormatFlagsException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "UUID", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Vector$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Vector", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$HashIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$Values", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$EH", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$Resolver", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractCollection", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$Itr", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$ListItr", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$1$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$2$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$2", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$SimpleEntry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractQueue", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractSequentialList", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "AbstractSet", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ArrayList", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Arrays$ArrayList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Arrays", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "BitSet", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Calendar$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Calendar$CalendarAccessControlContext", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Calendar", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Collection", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedCollection$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedCollection", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedList$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet$CheckedEntry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedRandomAccessList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSortedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSortedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CopiesList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptyList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptyMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptySet$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$ReverseComparator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$ReverseComparator2", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Collections$SelfComparable", 1536);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonMap$ImmutableEntry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonSet$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedCollection", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedRandomAccessList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSortedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSortedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableCollection$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableCollection", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableList$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableRandomAccessList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSortedMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSortedSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Collections", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Comparator", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ConcurrentModificationException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Currency$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Currency", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "CurrencyData", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Date", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Dictionary", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "DuplicateFormatFlagsException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EmptyStackException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Enumeration", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EnumMapIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$Values", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumSet$SerializationProxy", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EnumSet", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "EventListener", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EventListenerProxy", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "EventObject", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "FormatFlagsConversionMismatchException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Formattable", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "FormattableFlags", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeEnum.class,"java.util", "Formatter$BigDecimalLayoutForm", 16433);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$Conversion", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$DateTime", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FixedString", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$Flags", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FormatSpecifier$BigDecimalLayout", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FormatSpecifier", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Formatter$FormatString", 1536);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Formatter", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "FormatterClosedException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "GregorianCalendar", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$HashIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$Values", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "HashSet", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EmptyEnumerator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EmptyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$Enumerator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$ValueCollection", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$IdentityHashMapIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$Values", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatCodePointException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatConversionException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatFlagsException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatPrecisionException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatWidthException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "InputMismatchException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "InvalidPropertiesFormatException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Iterator", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "JumboEnumSet$EnumSetIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "JumboEnumSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$LinkedHashIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashSet", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList$ListItr", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "List", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "ListIterator", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ListResourceBundle", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Locale", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Map$Entry", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Map", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "MissingFormatArgumentException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "MissingFormatWidthException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "MissingResourceException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "NoSuchElementException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Observable", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Observer", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue$Itr", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Properties$LineReader", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Properties", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PropertyPermission", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PropertyPermissionCollection", 48);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "PropertyResourceBundle", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Queue", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Random", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "RandomAccess", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "RandomAccessSubList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "RegularEnumSet$EnumSetIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "RegularEnumSet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$LoaderReference", 48);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$ResourceCacheKey", 48);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundleEnumeration", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Scanner$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Scanner", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "Set", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "SimpleTimeZone", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "SortedMap", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeInterface.class,"java.util", "SortedSet", 1537);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Stack", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "StringTokenizer", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "SubList$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "SubList", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TaskQueue", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Timer$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Timer", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimerTask", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimerThread", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone$DisplayNames", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone", 1057);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TooManyListenersException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$2", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$3", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$PrivateEntryIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMap$EntrySetView", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMap", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMapEntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "TreeSet", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "UnknownFormatConversionException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "UnknownFormatFlagsException", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "UUID", 49);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Vector$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "Vector", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$Entry", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$EntryIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$EntrySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$HashIterator", 1056);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$KeyIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$KeySet", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$ValueIterator", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$Values", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap", 33);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$1", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$EH", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$Resolver", 32);
newType = helper.addBeforeTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils", 32);



    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 


    // starting method java.util.AbstractCollection#AbstractCollection()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractCollection()");
    method.setSimpleName("AbstractCollection");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#AbstractCollection()
    // starting method java.util.AbstractCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#iterator()
    // starting method java.util.AbstractCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#size()
    // starting method java.util.AbstractCollection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#isEmpty()
    // starting method java.util.AbstractCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#contains(java.lang.Object)
    // starting method java.util.AbstractCollection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#toArray()
    // starting method java.util.AbstractCollection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#toArray(java.lang.Object[])
    // starting method java.util.AbstractCollection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#add(java.lang.Object)
    // starting method java.util.AbstractCollection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#remove(java.lang.Object)
    // starting method java.util.AbstractCollection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#containsAll(java.util.Collection)
    // starting method java.util.AbstractCollection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#addAll(java.util.Collection)
    // starting method java.util.AbstractCollection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#removeAll(java.util.Collection)
    // starting method java.util.AbstractCollection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#retainAll(java.util.Collection)
    // starting method java.util.AbstractCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#clear()
    // starting method java.util.AbstractCollection#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#toString()

// finishing type java.util.AbstractCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.AbstractList$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$Itr");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$Itr#cursor
	field = newType.addNode(JavaDataField.class,"cursor"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$Itr#cursor

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$Itr#lastRet
	field = newType.addNode(JavaDataField.class,"lastRet"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$Itr#lastRet

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$Itr#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$Itr#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$Itr#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$Itr#this$0


    // ignoring method java.util.AbstractList$Itr#AbstractList$Itr(java.util.AbstractList)
    // starting method java.util.AbstractList$Itr#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#hasNext()
    // starting method java.util.AbstractList$Itr#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#next()
    // starting method java.util.AbstractList$Itr#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#remove()
    // starting method java.util.AbstractList$Itr#checkForComodification()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkForComodification()");
    method.setSimpleName("checkForComodification");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#checkForComodification()
    // starting method java.util.AbstractList$Itr#AbstractList$Itr(java.util.AbstractList, java.util.AbstractList$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractList$Itr(java.util.AbstractList, java.util.AbstractList$1)");
    method.setSimpleName("AbstractList$Itr");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#AbstractList$Itr(java.util.AbstractList, java.util.AbstractList$1)

// finishing type java.util.AbstractList$Itr
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$ListItr");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList$Itr");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$ListItr#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$ListItr#this$0


    // starting method java.util.AbstractList$ListItr#AbstractList$ListItr(java.util.AbstractList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractList$ListItr(java.util.AbstractList, int)");
    method.setSimpleName("AbstractList$ListItr");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#AbstractList$ListItr(java.util.AbstractList, int)
    // starting method java.util.AbstractList$ListItr#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#hasPrevious()
    // starting method java.util.AbstractList$ListItr#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#previous()
    // starting method java.util.AbstractList$ListItr#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#nextIndex()
    // starting method java.util.AbstractList$ListItr#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#previousIndex()
    // starting method java.util.AbstractList$ListItr#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#set(java.lang.Object)
    // starting method java.util.AbstractList$ListItr#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#add(java.lang.Object)

// finishing type java.util.AbstractList$ListItr
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList#modCount
	field = newType.addNode(JavaDataField.class,"modCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 132, isArray, arrayDimensions);
    // finishing field java.util.AbstractList#modCount


    // starting method java.util.AbstractList#AbstractList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractList()");
    method.setSimpleName("AbstractList");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#AbstractList()
    // starting method java.util.AbstractList#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#add(java.lang.Object)
    // starting method java.util.AbstractList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#get(int)
    // starting method java.util.AbstractList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#set(int, java.lang.Object)
    // starting method java.util.AbstractList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#add(int, java.lang.Object)
    // starting method java.util.AbstractList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#remove(int)
    // starting method java.util.AbstractList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#indexOf(java.lang.Object)
    // starting method java.util.AbstractList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#lastIndexOf(java.lang.Object)
    // starting method java.util.AbstractList#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#clear()
    // starting method java.util.AbstractList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#addAll(int, java.util.Collection)
    // starting method java.util.AbstractList#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#iterator()
    // starting method java.util.AbstractList#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#listIterator()
    // starting method java.util.AbstractList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#listIterator(int)
    // starting method java.util.AbstractList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#subList(int, int)
    // starting method java.util.AbstractList#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#equals(java.lang.Object)
    // starting method java.util.AbstractList#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#hashCode()
    // starting method java.util.AbstractList#removeRange(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeRange(int, int)");
    method.setSimpleName("removeRange");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#removeRange(int, int)

// finishing type java.util.AbstractList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$1$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.AbstractMap$1$1#i 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$1$1#this$1
	field = newType.addNode(JavaDataField.class,"this$1"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractMap$1");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$1$1#this$1


    // starting method java.util.AbstractMap$1$1#AbstractMap$1$1(java.util.AbstractMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$1$1(java.util.AbstractMap$1)");
    method.setSimpleName("AbstractMap$1$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1$1#AbstractMap$1$1(java.util.AbstractMap$1)
    // starting method java.util.AbstractMap$1$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1$1#hasNext()
    // starting method java.util.AbstractMap$1$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1$1#next()
    // starting method java.util.AbstractMap$1$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1$1#remove()

// finishing type java.util.AbstractMap$1$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$1#this$0


    // starting method java.util.AbstractMap$1#AbstractMap$1(java.util.AbstractMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$1(java.util.AbstractMap)");
    method.setSimpleName("AbstractMap$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1#AbstractMap$1(java.util.AbstractMap)
    // starting method java.util.AbstractMap$1#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1#iterator()
    // starting method java.util.AbstractMap$1#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1#size()
    // starting method java.util.AbstractMap$1#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1#contains(java.lang.Object)

// finishing type java.util.AbstractMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$2$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.AbstractMap$2$1#i 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$2$1#this$1
	field = newType.addNode(JavaDataField.class,"this$1"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractMap$2");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$2$1#this$1


    // starting method java.util.AbstractMap$2$1#AbstractMap$2$1(java.util.AbstractMap$2)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$2$1(java.util.AbstractMap$2)");
    method.setSimpleName("AbstractMap$2$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2$1#AbstractMap$2$1(java.util.AbstractMap$2)
    // starting method java.util.AbstractMap$2$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2$1#hasNext()
    // starting method java.util.AbstractMap$2$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2$1#next()
    // starting method java.util.AbstractMap$2$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2$1#remove()

// finishing type java.util.AbstractMap$2$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$2");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$2#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$2#this$0


    // starting method java.util.AbstractMap$2#AbstractMap$2(java.util.AbstractMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$2(java.util.AbstractMap)");
    method.setSimpleName("AbstractMap$2");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2#AbstractMap$2(java.util.AbstractMap)
    // starting method java.util.AbstractMap$2#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2#iterator()
    // starting method java.util.AbstractMap$2#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2#size()
    // starting method java.util.AbstractMap$2#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2#contains(java.lang.Object)

// finishing type java.util.AbstractMap$2
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$SimpleEntry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$SimpleEntry#key
	field = newType.addNode(JavaDataField.class,"key"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$SimpleEntry#key

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$SimpleEntry#value
	field = newType.addNode(JavaDataField.class,"value"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$SimpleEntry#value


    // starting method java.util.AbstractMap$SimpleEntry#AbstractMap$SimpleEntry(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$SimpleEntry(java.lang.Object, java.lang.Object)");
    method.setSimpleName("AbstractMap$SimpleEntry");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#AbstractMap$SimpleEntry(java.lang.Object, java.lang.Object)
    // starting method java.util.AbstractMap$SimpleEntry#AbstractMap$SimpleEntry(java.util.Map$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$SimpleEntry(java.util.Map$Entry)");
    method.setSimpleName("AbstractMap$SimpleEntry");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#AbstractMap$SimpleEntry(java.util.Map$Entry)
    // starting method java.util.AbstractMap$SimpleEntry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#getKey()
    // starting method java.util.AbstractMap$SimpleEntry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#getValue()
    // starting method java.util.AbstractMap$SimpleEntry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#setValue(java.lang.Object)
    // starting method java.util.AbstractMap$SimpleEntry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#equals(java.lang.Object)
    // starting method java.util.AbstractMap$SimpleEntry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#hashCode()
    // starting method java.util.AbstractMap$SimpleEntry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#toString()
    // ignoring method java.util.AbstractMap$SimpleEntry#eq(java.lang.Object, java.lang.Object)

// finishing type java.util.AbstractMap$SimpleEntry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap#keySet
	field = newType.addNode(JavaDataField.class,"keySet"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    helper.insertFieldData(field, fieldType, 192, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap#keySet

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap#values
	field = newType.addNode(JavaDataField.class,"values"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 192, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap#values


    // starting method java.util.AbstractMap#AbstractMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap()");
    method.setSimpleName("AbstractMap");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#AbstractMap()
    // starting method java.util.AbstractMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#size()
    // starting method java.util.AbstractMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#isEmpty()
    // starting method java.util.AbstractMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#containsValue(java.lang.Object)
    // starting method java.util.AbstractMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#containsKey(java.lang.Object)
    // starting method java.util.AbstractMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#get(java.lang.Object)
    // starting method java.util.AbstractMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.AbstractMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#remove(java.lang.Object)
    // starting method java.util.AbstractMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#putAll(java.util.Map)
    // starting method java.util.AbstractMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#clear()
    // starting method java.util.AbstractMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#keySet()
    // starting method java.util.AbstractMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#values()
    // starting method java.util.AbstractMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#entrySet()
    // starting method java.util.AbstractMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#equals(java.lang.Object)
    // starting method java.util.AbstractMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#hashCode()
    // starting method java.util.AbstractMap#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#toString()
    // starting method java.util.AbstractMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","CloneNotSupportedException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.CloneNotSupportedException
    
    // finishing method java.util.AbstractMap#clone()

// finishing type java.util.AbstractMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractQueue");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Queue 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Queue");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Queue 


    // starting method java.util.AbstractQueue#AbstractQueue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractQueue()");
    method.setSimpleName("AbstractQueue");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#AbstractQueue()
    // starting method java.util.AbstractQueue#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#add(java.lang.Object)
    // starting method java.util.AbstractQueue#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#remove()
    // starting method java.util.AbstractQueue#element()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"element()");
    method.setSimpleName("element");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#element()
    // starting method java.util.AbstractQueue#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#clear()
    // starting method java.util.AbstractQueue#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#addAll(java.util.Collection)

// finishing type java.util.AbstractQueue
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractSequentialList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.AbstractSequentialList#AbstractSequentialList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractSequentialList()");
    method.setSimpleName("AbstractSequentialList");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#AbstractSequentialList()
    // starting method java.util.AbstractSequentialList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#get(int)
    // starting method java.util.AbstractSequentialList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#set(int, java.lang.Object)
    // starting method java.util.AbstractSequentialList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#add(int, java.lang.Object)
    // starting method java.util.AbstractSequentialList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#remove(int)
    // starting method java.util.AbstractSequentialList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#addAll(int, java.util.Collection)
    // starting method java.util.AbstractSequentialList#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#iterator()
    // starting method java.util.AbstractSequentialList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#listIterator(int)

// finishing type java.util.AbstractSequentialList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 


    // starting method java.util.AbstractSet#AbstractSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractSet()");
    method.setSimpleName("AbstractSet");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSet#AbstractSet()
    // starting method java.util.AbstractSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSet#equals(java.lang.Object)
    // starting method java.util.AbstractSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSet#hashCode()
    // starting method java.util.AbstractSet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSet#removeAll(java.util.Collection)

// finishing type java.util.AbstractSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ArrayList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.ArrayList#serialVersionUID 

// ignoring field java.util.ArrayList#elementData 

// ignoring field java.util.ArrayList#size 


    // starting method java.util.ArrayList#ArrayList(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ArrayList(int)");
    method.setSimpleName("ArrayList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#ArrayList(int)
    // starting method java.util.ArrayList#ArrayList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ArrayList()");
    method.setSimpleName("ArrayList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#ArrayList()
    // starting method java.util.ArrayList#ArrayList(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ArrayList(java.util.Collection)");
    method.setSimpleName("ArrayList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#ArrayList(java.util.Collection)
    // starting method java.util.ArrayList#trimToSize()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"trimToSize()");
    method.setSimpleName("trimToSize");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#trimToSize()
    // starting method java.util.ArrayList#ensureCapacity(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"ensureCapacity(int)");
    method.setSimpleName("ensureCapacity");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#ensureCapacity(int)
    // starting method java.util.ArrayList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#size()
    // starting method java.util.ArrayList#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#isEmpty()
    // starting method java.util.ArrayList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#contains(java.lang.Object)
    // starting method java.util.ArrayList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#indexOf(java.lang.Object)
    // starting method java.util.ArrayList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#lastIndexOf(java.lang.Object)
    // starting method java.util.ArrayList#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#clone()
    // starting method java.util.ArrayList#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#toArray()
    // starting method java.util.ArrayList#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#toArray(java.lang.Object[])
    // starting method java.util.ArrayList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#get(int)
    // starting method java.util.ArrayList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#set(int, java.lang.Object)
    // starting method java.util.ArrayList#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#add(java.lang.Object)
    // starting method java.util.ArrayList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#add(int, java.lang.Object)
    // starting method java.util.ArrayList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#remove(int)
    // starting method java.util.ArrayList#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#remove(java.lang.Object)
    // ignoring method java.util.ArrayList#fastRemove(int)
    // starting method java.util.ArrayList#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#clear()
    // starting method java.util.ArrayList#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#addAll(java.util.Collection)
    // starting method java.util.ArrayList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#addAll(int, java.util.Collection)
    // starting method java.util.ArrayList#removeRange(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeRange(int, int)");
    method.setSimpleName("removeRange");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#removeRange(int, int)
    // ignoring method java.util.ArrayList#RangeCheck(int)
    // ignoring method java.util.ArrayList#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.ArrayList#readObject(java.io.ObjectInputStream)

// finishing type java.util.ArrayList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Arrays$ArrayList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Arrays$ArrayList#serialVersionUID 

// ignoring field java.util.Arrays$ArrayList#a 


    // starting method java.util.Arrays$ArrayList#Arrays$ArrayList(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Arrays$ArrayList(java.lang.Object[])");
    method.setSimpleName("Arrays$ArrayList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#Arrays$ArrayList(java.lang.Object[])
    // starting method java.util.Arrays$ArrayList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#size()
    // starting method java.util.Arrays$ArrayList#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#toArray()
    // starting method java.util.Arrays$ArrayList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#get(int)
    // starting method java.util.Arrays$ArrayList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#set(int, java.lang.Object)
    // starting method java.util.Arrays$ArrayList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#indexOf(java.lang.Object)
    // starting method java.util.Arrays$ArrayList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#contains(java.lang.Object)

// finishing type java.util.Arrays$ArrayList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Arrays");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Arrays#INSERTIONSORT_THRESHOLD 


    // ignoring method java.util.Arrays#Arrays()
    // starting method java.util.Arrays#sort(long[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(long[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(long[])
    // starting method java.util.Arrays#sort(long[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(long[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(long[], int, int)
    // starting method java.util.Arrays#sort(int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(int[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(int[])
    // starting method java.util.Arrays#sort(int[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(int[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(int[], int, int)
    // starting method java.util.Arrays#sort(short[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(short[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(short[])
    // starting method java.util.Arrays#sort(short[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(short[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(short[], int, int)
    // starting method java.util.Arrays#sort(char[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(char[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(char[])
    // starting method java.util.Arrays#sort(char[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(char[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(char[], int, int)
    // starting method java.util.Arrays#sort(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(byte[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(byte[])
    // starting method java.util.Arrays#sort(byte[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(byte[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(byte[], int, int)
    // starting method java.util.Arrays#sort(double[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(double[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(double[])
    // starting method java.util.Arrays#sort(double[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(double[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(double[], int, int)
    // starting method java.util.Arrays#sort(float[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(float[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(float[])
    // starting method java.util.Arrays#sort(float[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(float[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(float[], int, int)
    // ignoring method java.util.Arrays#sort2(double[], int, int)
    // ignoring method java.util.Arrays#sort2(float[], int, int)
    // ignoring method java.util.Arrays#sort1(long[], int, int)
    // ignoring method java.util.Arrays#swap(long[], int, int)
    // ignoring method java.util.Arrays#vecswap(long[], int, int, int)
    // ignoring method java.util.Arrays#med3(long[], int, int, int)
    // ignoring method java.util.Arrays#sort1(int[], int, int)
    // ignoring method java.util.Arrays#swap(int[], int, int)
    // ignoring method java.util.Arrays#vecswap(int[], int, int, int)
    // ignoring method java.util.Arrays#med3(int[], int, int, int)
    // ignoring method java.util.Arrays#sort1(short[], int, int)
    // ignoring method java.util.Arrays#swap(short[], int, int)
    // ignoring method java.util.Arrays#vecswap(short[], int, int, int)
    // ignoring method java.util.Arrays#med3(short[], int, int, int)
    // ignoring method java.util.Arrays#sort1(char[], int, int)
    // ignoring method java.util.Arrays#swap(char[], int, int)
    // ignoring method java.util.Arrays#vecswap(char[], int, int, int)
    // ignoring method java.util.Arrays#med3(char[], int, int, int)
    // ignoring method java.util.Arrays#sort1(byte[], int, int)
    // ignoring method java.util.Arrays#swap(byte[], int, int)
    // ignoring method java.util.Arrays#vecswap(byte[], int, int, int)
    // ignoring method java.util.Arrays#med3(byte[], int, int, int)
    // ignoring method java.util.Arrays#sort1(double[], int, int)
    // ignoring method java.util.Arrays#swap(double[], int, int)
    // ignoring method java.util.Arrays#vecswap(double[], int, int, int)
    // ignoring method java.util.Arrays#med3(double[], int, int, int)
    // ignoring method java.util.Arrays#sort1(float[], int, int)
    // ignoring method java.util.Arrays#swap(float[], int, int)
    // ignoring method java.util.Arrays#vecswap(float[], int, int, int)
    // ignoring method java.util.Arrays#med3(float[], int, int, int)
    // starting method java.util.Arrays#sort(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.lang.Object[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(java.lang.Object[])
    // starting method java.util.Arrays#sort(java.lang.Object[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.lang.Object[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(java.lang.Object[], int, int)
    // ignoring method java.util.Arrays#cloneSubarray(java.lang.Object[], int, int)
    // ignoring method java.util.Arrays#mergeSort(java.lang.Object[], java.lang.Object[], int, int, int)
    // ignoring method java.util.Arrays#swap(java.lang.Object[], int, int)
    // starting method java.util.Arrays#sort(java.lang.Object[], java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.lang.Object[], java.util.Comparator)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(java.lang.Object[], java.util.Comparator)
    // starting method java.util.Arrays#sort(java.lang.Object[], int, int, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.lang.Object[], int, int, java.util.Comparator)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(java.lang.Object[], int, int, java.util.Comparator)
    // ignoring method java.util.Arrays#mergeSort(java.lang.Object[], java.lang.Object[], int, int, int, java.util.Comparator)
    // ignoring method java.util.Arrays#rangeCheck(int, int, int)
    // starting method java.util.Arrays#binarySearch(long[], long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(long[], long)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(long[], long)
    // starting method java.util.Arrays#binarySearch(int[], int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(int[], int)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(int[], int)
    // starting method java.util.Arrays#binarySearch(short[], short)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(short[], short)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(short[], short)
    // starting method java.util.Arrays#binarySearch(char[], char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(char[], char)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(char[], char)
    // starting method java.util.Arrays#binarySearch(byte[], byte)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(byte[], byte)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(byte[], byte)
    // starting method java.util.Arrays#binarySearch(double[], double)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(double[], double)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(double[], double)
    // ignoring method java.util.Arrays#binarySearch(double[], double, int, int)
    // starting method java.util.Arrays#binarySearch(float[], float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(float[], float)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(float[], float)
    // ignoring method java.util.Arrays#binarySearch(float[], float, int, int)
    // starting method java.util.Arrays#binarySearch(java.lang.Object[], java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(java.lang.Object[], java.lang.Object)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(java.lang.Object[], java.lang.Object)
    // starting method java.util.Arrays#binarySearch(java.lang.Object[], java.lang.Object, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(java.lang.Object[], java.lang.Object, java.util.Comparator)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(java.lang.Object[], java.lang.Object, java.util.Comparator)
    // starting method java.util.Arrays#equals(long[], long[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(long[], long[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(long[], long[])
    // starting method java.util.Arrays#equals(int[], int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(int[], int[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(int[], int[])
    // starting method java.util.Arrays#equals(short[], short[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(short[], short[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(short[], short[])
    // starting method java.util.Arrays#equals(char[], char[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(char[], char[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(char[], char[])
    // starting method java.util.Arrays#equals(byte[], byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(byte[], byte[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(byte[], byte[])
    // starting method java.util.Arrays#equals(boolean[], boolean[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(boolean[], boolean[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(boolean[], boolean[])
    // starting method java.util.Arrays#equals(double[], double[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(double[], double[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(double[], double[])
    // starting method java.util.Arrays#equals(float[], float[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(float[], float[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(float[], float[])
    // starting method java.util.Arrays#equals(java.lang.Object[], java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object[], java.lang.Object[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(java.lang.Object[], java.lang.Object[])
    // starting method java.util.Arrays#fill(long[], long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(long[], long)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(long[], long)
    // starting method java.util.Arrays#fill(long[], int, int, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(long[], int, int, long)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(long[], int, int, long)
    // starting method java.util.Arrays#fill(int[], int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(int[], int)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(int[], int)
    // starting method java.util.Arrays#fill(int[], int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(int[], int, int, int)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(int[], int, int, int)
    // starting method java.util.Arrays#fill(short[], short)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(short[], short)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(short[], short)
    // starting method java.util.Arrays#fill(short[], int, int, short)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(short[], int, int, short)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(short[], int, int, short)
    // starting method java.util.Arrays#fill(char[], char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(char[], char)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(char[], char)
    // starting method java.util.Arrays#fill(char[], int, int, char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(char[], int, int, char)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(char[], int, int, char)
    // starting method java.util.Arrays#fill(byte[], byte)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(byte[], byte)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(byte[], byte)
    // starting method java.util.Arrays#fill(byte[], int, int, byte)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(byte[], int, int, byte)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(byte[], int, int, byte)
    // starting method java.util.Arrays#fill(boolean[], boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(boolean[], boolean)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(boolean[], boolean)
    // starting method java.util.Arrays#fill(boolean[], int, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(boolean[], int, int, boolean)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(boolean[], int, int, boolean)
    // starting method java.util.Arrays#fill(double[], double)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(double[], double)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(double[], double)
    // starting method java.util.Arrays#fill(double[], int, int, double)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(double[], int, int, double)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(double[], int, int, double)
    // starting method java.util.Arrays#fill(float[], float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(float[], float)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(float[], float)
    // starting method java.util.Arrays#fill(float[], int, int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(float[], int, int, float)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(float[], int, int, float)
    // starting method java.util.Arrays#fill(java.lang.Object[], java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(java.lang.Object[], java.lang.Object)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(java.lang.Object[], java.lang.Object)
    // starting method java.util.Arrays#fill(java.lang.Object[], int, int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(java.lang.Object[], int, int, java.lang.Object)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(java.lang.Object[], int, int, java.lang.Object)
    // starting method java.util.Arrays#asList(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"asList(java.lang.Object[])");
    method.setSimpleName("asList");
    helper.setMethodData(method,137);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#asList(java.lang.Object[])
    // starting method java.util.Arrays#hashCode(long[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(long[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(long[])
    // starting method java.util.Arrays#hashCode(int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(int[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(int[])
    // starting method java.util.Arrays#hashCode(short[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(short[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(short[])
    // starting method java.util.Arrays#hashCode(char[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(char[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(char[])
    // starting method java.util.Arrays#hashCode(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(byte[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(byte[])
    // starting method java.util.Arrays#hashCode(boolean[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(boolean[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(boolean[])
    // starting method java.util.Arrays#hashCode(float[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(float[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(float[])
    // starting method java.util.Arrays#hashCode(double[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(double[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(double[])
    // starting method java.util.Arrays#hashCode(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(java.lang.Object[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(java.lang.Object[])
    // starting method java.util.Arrays#deepHashCode(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deepHashCode(java.lang.Object[])");
    method.setSimpleName("deepHashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#deepHashCode(java.lang.Object[])
    // starting method java.util.Arrays#deepEquals(java.lang.Object[], java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deepEquals(java.lang.Object[], java.lang.Object[])");
    method.setSimpleName("deepEquals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#deepEquals(java.lang.Object[], java.lang.Object[])
    // starting method java.util.Arrays#toString(long[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(long[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(long[])
    // starting method java.util.Arrays#toString(int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(int[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(int[])
    // starting method java.util.Arrays#toString(short[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(short[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(short[])
    // starting method java.util.Arrays#toString(char[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(char[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(char[])
    // starting method java.util.Arrays#toString(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(byte[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(byte[])
    // starting method java.util.Arrays#toString(boolean[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(boolean[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(boolean[])
    // starting method java.util.Arrays#toString(float[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(float[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(float[])
    // starting method java.util.Arrays#toString(double[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(double[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(double[])
    // starting method java.util.Arrays#toString(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(java.lang.Object[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(java.lang.Object[])
    // starting method java.util.Arrays#deepToString(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deepToString(java.lang.Object[])");
    method.setSimpleName("deepToString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#deepToString(java.lang.Object[])
    // ignoring method java.util.Arrays#deepToString(java.lang.Object[], java.lang.StringBuilder, java.util.Set)

// finishing type java.util.Arrays
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "BitSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.BitSet#ADDRESS_BITS_PER_UNIT 

// ignoring field java.util.BitSet#BITS_PER_UNIT 

// ignoring field java.util.BitSet#BIT_INDEX_MASK 

// ignoring field java.util.BitSet#WORD_MASK 

// ignoring field java.util.BitSet#bits 

// ignoring field java.util.BitSet#unitsInUse 

// ignoring field java.util.BitSet#serialVersionUID 

// ignoring field java.util.BitSet#trailingZeroTable 


    // ignoring method java.util.BitSet#unitIndex(int)
    // ignoring method java.util.BitSet#bit(int)
    // ignoring method java.util.BitSet#recalculateUnitsInUse()
    // starting method java.util.BitSet#BitSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"BitSet()");
    method.setSimpleName("BitSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#BitSet()
    // starting method java.util.BitSet#BitSet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"BitSet(int)");
    method.setSimpleName("BitSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#BitSet(int)
    // ignoring method java.util.BitSet#ensureCapacity(int)
    // starting method java.util.BitSet#flip(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"flip(int)");
    method.setSimpleName("flip");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#flip(int)
    // starting method java.util.BitSet#flip(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"flip(int, int)");
    method.setSimpleName("flip");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#flip(int, int)
    // ignoring method java.util.BitSet#bitsRightOf(int)
    // ignoring method java.util.BitSet#bitsLeftOf(int)
    // starting method java.util.BitSet#set(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#set(int)
    // starting method java.util.BitSet#set(int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, boolean)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#set(int, boolean)
    // starting method java.util.BitSet#set(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#set(int, int)
    // starting method java.util.BitSet#set(int, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int, boolean)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#set(int, int, boolean)
    // starting method java.util.BitSet#clear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear(int)");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#clear(int)
    // starting method java.util.BitSet#clear(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear(int, int)");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#clear(int, int)
    // starting method java.util.BitSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#clear()
    // starting method java.util.BitSet#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#get(int)
    // starting method java.util.BitSet#get(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int, int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","BitSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#get(int, int)
    // ignoring method java.util.BitSet#getBits(int)
    // starting method java.util.BitSet#nextSetBit(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextSetBit(int)");
    method.setSimpleName("nextSetBit");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#nextSetBit(int)
    // ignoring method java.util.BitSet#trailingZeroCnt(long)
    // starting method java.util.BitSet#nextClearBit(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextClearBit(int)");
    method.setSimpleName("nextClearBit");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#nextClearBit(int)
    // starting method java.util.BitSet#length()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"length()");
    method.setSimpleName("length");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#length()
    // ignoring method java.util.BitSet#bitLen(int)
    // starting method java.util.BitSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#isEmpty()
    // starting method java.util.BitSet#intersects(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"intersects(java.util.BitSet)");
    method.setSimpleName("intersects");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#intersects(java.util.BitSet)
    // starting method java.util.BitSet#cardinality()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"cardinality()");
    method.setSimpleName("cardinality");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#cardinality()
    // ignoring method java.util.BitSet#bitCount(long)
    // starting method java.util.BitSet#and(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"and(java.util.BitSet)");
    method.setSimpleName("and");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#and(java.util.BitSet)
    // starting method java.util.BitSet#or(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"or(java.util.BitSet)");
    method.setSimpleName("or");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#or(java.util.BitSet)
    // starting method java.util.BitSet#xor(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"xor(java.util.BitSet)");
    method.setSimpleName("xor");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#xor(java.util.BitSet)
    // starting method java.util.BitSet#andNot(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"andNot(java.util.BitSet)");
    method.setSimpleName("andNot");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#andNot(java.util.BitSet)
    // starting method java.util.BitSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#hashCode()
    // starting method java.util.BitSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#size()
    // starting method java.util.BitSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#equals(java.lang.Object)
    // starting method java.util.BitSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#clone()
    // ignoring method java.util.BitSet#readObject(java.io.ObjectInputStream)
    // starting method java.util.BitSet#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#toString()

// finishing type java.util.BitSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Calendar$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface PrivilegedExceptionAction 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PrivilegedExceptionAction");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface PrivilegedExceptionAction 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar$1#val$input
	field = newType.addNode(JavaDataField.class,"val$input"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.io","ObjectInputStream");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Calendar$1#val$input

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Calendar$1#this$0


    // starting method java.util.Calendar$1#Calendar$1(java.util.Calendar, java.io.ObjectInputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Calendar$1(java.util.Calendar, java.io.ObjectInputStream)");
    method.setSimpleName("Calendar$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","ClassNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.ClassNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Calendar$1#Calendar$1(java.util.Calendar, java.io.ObjectInputStream)
    // starting method java.util.Calendar$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "sun.util.calendar","ZoneInfo");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Exception");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.Exception
    
    // finishing method java.util.Calendar$1#run()
    // starting method java.util.Calendar$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Exception");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.Exception
    
    // finishing method java.util.Calendar$1#run()

// finishing type java.util.Calendar$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Calendar$CalendarAccessControlContext");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Calendar$CalendarAccessControlContext#INSTANCE 


    // ignoring method java.util.Calendar$CalendarAccessControlContext#Calendar$CalendarAccessControlContext()
    // starting method java.util.Calendar$CalendarAccessControlContext#access$000()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000()");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.security","AccessControlContext");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar$CalendarAccessControlContext#access$000()

// finishing type java.util.Calendar$CalendarAccessControlContext
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Calendar");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Comparable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Comparable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ERA
	field = newType.addNode(JavaDataField.class,"ERA"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ERA

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#YEAR
	field = newType.addNode(JavaDataField.class,"YEAR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#YEAR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MONTH
	field = newType.addNode(JavaDataField.class,"MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEEK_OF_YEAR
	field = newType.addNode(JavaDataField.class,"WEEK_OF_YEAR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEEK_OF_YEAR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEEK_OF_MONTH
	field = newType.addNode(JavaDataField.class,"WEEK_OF_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEEK_OF_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DATE
	field = newType.addNode(JavaDataField.class,"DATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DATE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_MONTH
	field = newType.addNode(JavaDataField.class,"DAY_OF_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_YEAR
	field = newType.addNode(JavaDataField.class,"DAY_OF_YEAR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_YEAR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_WEEK
	field = newType.addNode(JavaDataField.class,"DAY_OF_WEEK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_WEEK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_WEEK_IN_MONTH
	field = newType.addNode(JavaDataField.class,"DAY_OF_WEEK_IN_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_WEEK_IN_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#AM_PM
	field = newType.addNode(JavaDataField.class,"AM_PM"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#AM_PM

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#HOUR
	field = newType.addNode(JavaDataField.class,"HOUR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#HOUR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#HOUR_OF_DAY
	field = newType.addNode(JavaDataField.class,"HOUR_OF_DAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#HOUR_OF_DAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MINUTE
	field = newType.addNode(JavaDataField.class,"MINUTE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MINUTE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SECOND
	field = newType.addNode(JavaDataField.class,"SECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MILLISECOND
	field = newType.addNode(JavaDataField.class,"MILLISECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MILLISECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ZONE_OFFSET
	field = newType.addNode(JavaDataField.class,"ZONE_OFFSET"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ZONE_OFFSET

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DST_OFFSET
	field = newType.addNode(JavaDataField.class,"DST_OFFSET"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DST_OFFSET

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#FIELD_COUNT
	field = newType.addNode(JavaDataField.class,"FIELD_COUNT"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#FIELD_COUNT

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SUNDAY
	field = newType.addNode(JavaDataField.class,"SUNDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SUNDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MONDAY
	field = newType.addNode(JavaDataField.class,"MONDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MONDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#TUESDAY
	field = newType.addNode(JavaDataField.class,"TUESDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#TUESDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEDNESDAY
	field = newType.addNode(JavaDataField.class,"WEDNESDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEDNESDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#THURSDAY
	field = newType.addNode(JavaDataField.class,"THURSDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#THURSDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#FRIDAY
	field = newType.addNode(JavaDataField.class,"FRIDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#FRIDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SATURDAY
	field = newType.addNode(JavaDataField.class,"SATURDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SATURDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#JANUARY
	field = newType.addNode(JavaDataField.class,"JANUARY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#JANUARY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#FEBRUARY
	field = newType.addNode(JavaDataField.class,"FEBRUARY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#FEBRUARY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MARCH
	field = newType.addNode(JavaDataField.class,"MARCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MARCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#APRIL
	field = newType.addNode(JavaDataField.class,"APRIL"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#APRIL

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MAY
	field = newType.addNode(JavaDataField.class,"MAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#JUNE
	field = newType.addNode(JavaDataField.class,"JUNE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#JUNE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#JULY
	field = newType.addNode(JavaDataField.class,"JULY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#JULY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#AUGUST
	field = newType.addNode(JavaDataField.class,"AUGUST"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#AUGUST

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SEPTEMBER
	field = newType.addNode(JavaDataField.class,"SEPTEMBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SEPTEMBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#OCTOBER
	field = newType.addNode(JavaDataField.class,"OCTOBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#OCTOBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#NOVEMBER
	field = newType.addNode(JavaDataField.class,"NOVEMBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#NOVEMBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DECEMBER
	field = newType.addNode(JavaDataField.class,"DECEMBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DECEMBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#UNDECIMBER
	field = newType.addNode(JavaDataField.class,"UNDECIMBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#UNDECIMBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#AM
	field = newType.addNode(JavaDataField.class,"AM"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#AM

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#PM
	field = newType.addNode(JavaDataField.class,"PM"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#PM

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#fields
	field = newType.addNode(JavaDataField.class,"fields"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#fields

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#isSet
	field = newType.addNode(JavaDataField.class,"isSet"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#isSet

// ignoring field java.util.Calendar#stamp 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#time
	field = newType.addNode(JavaDataField.class,"time"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#time

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#isTimeSet
	field = newType.addNode(JavaDataField.class,"isTimeSet"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#isTimeSet

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#areFieldsSet
	field = newType.addNode(JavaDataField.class,"areFieldsSet"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#areFieldsSet

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#areAllFieldsSet
	field = newType.addNode(JavaDataField.class,"areAllFieldsSet"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 128, isArray, arrayDimensions);
    // finishing field java.util.Calendar#areAllFieldsSet

// ignoring field java.util.Calendar#lenient 

// ignoring field java.util.Calendar#zone 

// ignoring field java.util.Calendar#sharedZone 

// ignoring field java.util.Calendar#firstDayOfWeek 

// ignoring field java.util.Calendar#minimalDaysInFirstWeek 

// ignoring field java.util.Calendar#cachedLocaleData 

// ignoring field java.util.Calendar#UNSET 

// ignoring field java.util.Calendar#COMPUTED 

// ignoring field java.util.Calendar#MINIMUM_USER_STAMP 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ALL_FIELDS
	field = newType.addNode(JavaDataField.class,"ALL_FIELDS"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ALL_FIELDS

// ignoring field java.util.Calendar#nextStamp 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#currentSerialVersion
	field = newType.addNode(JavaDataField.class,"currentSerialVersion"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#currentSerialVersion

// ignoring field java.util.Calendar#serialVersionOnStream 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ERA_MASK
	field = newType.addNode(JavaDataField.class,"ERA_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ERA_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#YEAR_MASK
	field = newType.addNode(JavaDataField.class,"YEAR_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#YEAR_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MONTH_MASK
	field = newType.addNode(JavaDataField.class,"MONTH_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MONTH_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEEK_OF_YEAR_MASK
	field = newType.addNode(JavaDataField.class,"WEEK_OF_YEAR_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEEK_OF_YEAR_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEEK_OF_MONTH_MASK
	field = newType.addNode(JavaDataField.class,"WEEK_OF_MONTH_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEEK_OF_MONTH_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_MONTH_MASK
	field = newType.addNode(JavaDataField.class,"DAY_OF_MONTH_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_MONTH_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DATE_MASK
	field = newType.addNode(JavaDataField.class,"DATE_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DATE_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_YEAR_MASK
	field = newType.addNode(JavaDataField.class,"DAY_OF_YEAR_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_YEAR_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_WEEK_MASK
	field = newType.addNode(JavaDataField.class,"DAY_OF_WEEK_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_WEEK_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_WEEK_IN_MONTH_MASK
	field = newType.addNode(JavaDataField.class,"DAY_OF_WEEK_IN_MONTH_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_WEEK_IN_MONTH_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#AM_PM_MASK
	field = newType.addNode(JavaDataField.class,"AM_PM_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#AM_PM_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#HOUR_MASK
	field = newType.addNode(JavaDataField.class,"HOUR_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#HOUR_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#HOUR_OF_DAY_MASK
	field = newType.addNode(JavaDataField.class,"HOUR_OF_DAY_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#HOUR_OF_DAY_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MINUTE_MASK
	field = newType.addNode(JavaDataField.class,"MINUTE_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MINUTE_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SECOND_MASK
	field = newType.addNode(JavaDataField.class,"SECOND_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SECOND_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MILLISECOND_MASK
	field = newType.addNode(JavaDataField.class,"MILLISECOND_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MILLISECOND_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ZONE_OFFSET_MASK
	field = newType.addNode(JavaDataField.class,"ZONE_OFFSET_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ZONE_OFFSET_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DST_OFFSET_MASK
	field = newType.addNode(JavaDataField.class,"DST_OFFSET_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DST_OFFSET_MASK

// ignoring field java.util.Calendar#FIELD_NAME 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.Calendar#$assertionsDisabled


    // starting method java.util.Calendar#Calendar()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Calendar()");
    method.setSimpleName("Calendar");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#Calendar()
    // starting method java.util.Calendar#Calendar(java.util.TimeZone, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Calendar(java.util.TimeZone, java.util.Locale)");
    method.setSimpleName("Calendar");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#Calendar(java.util.TimeZone, java.util.Locale)
    // starting method java.util.Calendar#getInstance()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance()");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getInstance()
    // starting method java.util.Calendar#getInstance(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.util.TimeZone)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getInstance(java.util.TimeZone)
    // starting method java.util.Calendar#getInstance(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.util.Locale)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getInstance(java.util.Locale)
    // starting method java.util.Calendar#getInstance(java.util.TimeZone, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.util.TimeZone, java.util.Locale)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getInstance(java.util.TimeZone, java.util.Locale)
    // ignoring method java.util.Calendar#createCalendar(java.util.TimeZone, java.util.Locale)
    // starting method java.util.Calendar#getAvailableLocales()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getAvailableLocales()");
    method.setSimpleName("getAvailableLocales");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getAvailableLocales()
    // starting method java.util.Calendar#computeTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"computeTime()");
    method.setSimpleName("computeTime");
    helper.setMethodData(method,1028);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#computeTime()
    // starting method java.util.Calendar#computeFields()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"computeFields()");
    method.setSimpleName("computeFields");
    helper.setMethodData(method,1028);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#computeFields()
    // starting method java.util.Calendar#getTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTime()");
    method.setSimpleName("getTime");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Date");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getTime()
    // starting method java.util.Calendar#setTime(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTime(java.util.Date)");
    method.setSimpleName("setTime");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setTime(java.util.Date)
    // starting method java.util.Calendar#getTimeInMillis()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimeInMillis()");
    method.setSimpleName("getTimeInMillis");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getTimeInMillis()
    // starting method java.util.Calendar#setTimeInMillis(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTimeInMillis(long)");
    method.setSimpleName("setTimeInMillis");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setTimeInMillis(long)
    // starting method java.util.Calendar#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#get(int)
    // starting method java.util.Calendar#internalGet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"internalGet(int)");
    method.setSimpleName("internalGet");
    helper.setMethodData(method,20);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#internalGet(int)
    // starting method java.util.Calendar#internalSet(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"internalSet(int, int)");
    method.setSimpleName("internalSet");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#internalSet(int, int)
    // starting method java.util.Calendar#set(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#set(int, int)
    // starting method java.util.Calendar#set(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#set(int, int, int)
    // starting method java.util.Calendar#set(int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int, int, int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#set(int, int, int, int, int)
    // starting method java.util.Calendar#set(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int, int, int, int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#set(int, int, int, int, int, int)
    // starting method java.util.Calendar#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#clear()
    // starting method java.util.Calendar#clear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear(int)");
    method.setSimpleName("clear");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#clear(int)
    // starting method java.util.Calendar#isSet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isSet(int)");
    method.setSimpleName("isSet");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isSet(int)
    // starting method java.util.Calendar#complete()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complete()");
    method.setSimpleName("complete");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#complete()
    // starting method java.util.Calendar#isExternallySet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isExternallySet(int)");
    method.setSimpleName("isExternallySet");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isExternallySet(int)
    // starting method java.util.Calendar#getSetStateFields()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSetStateFields()");
    method.setSimpleName("getSetStateFields");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getSetStateFields()
    // starting method java.util.Calendar#setFieldsComputed(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setFieldsComputed(int)");
    method.setSimpleName("setFieldsComputed");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setFieldsComputed(int)
    // starting method java.util.Calendar#setFieldsNormalized(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setFieldsNormalized(int)");
    method.setSimpleName("setFieldsNormalized");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setFieldsNormalized(int)
    // starting method java.util.Calendar#isPartiallyNormalized()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isPartiallyNormalized()");
    method.setSimpleName("isPartiallyNormalized");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isPartiallyNormalized()
    // starting method java.util.Calendar#isFullyNormalized()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isFullyNormalized()");
    method.setSimpleName("isFullyNormalized");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isFullyNormalized()
    // starting method java.util.Calendar#setUnnormalized()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setUnnormalized()");
    method.setSimpleName("setUnnormalized");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setUnnormalized()
    // starting method java.util.Calendar#isFieldSet(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isFieldSet(int, int)");
    method.setSimpleName("isFieldSet");
    helper.setMethodData(method,24);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isFieldSet(int, int)
    // starting method java.util.Calendar#selectFields()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"selectFields()");
    method.setSimpleName("selectFields");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#selectFields()
    // ignoring method java.util.Calendar#aggregateStamp(int, int)
    // starting method java.util.Calendar#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#equals(java.lang.Object)
    // starting method java.util.Calendar#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#hashCode()
    // starting method java.util.Calendar#before(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"before(java.lang.Object)");
    method.setSimpleName("before");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#before(java.lang.Object)
    // starting method java.util.Calendar#after(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"after(java.lang.Object)");
    method.setSimpleName("after");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#after(java.lang.Object)
    // starting method java.util.Calendar#compareTo(java.util.Calendar)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.util.Calendar)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#compareTo(java.util.Calendar)
    // starting method java.util.Calendar#add(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, int)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#add(int, int)
    // starting method java.util.Calendar#roll(int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"roll(int, boolean)");
    method.setSimpleName("roll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#roll(int, boolean)
    // starting method java.util.Calendar#roll(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"roll(int, int)");
    method.setSimpleName("roll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#roll(int, int)
    // starting method java.util.Calendar#setTimeZone(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTimeZone(java.util.TimeZone)");
    method.setSimpleName("setTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setTimeZone(java.util.TimeZone)
    // starting method java.util.Calendar#getTimeZone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimeZone()");
    method.setSimpleName("getTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getTimeZone()
    // starting method java.util.Calendar#getZone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getZone()");
    method.setSimpleName("getZone");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getZone()
    // starting method java.util.Calendar#setZoneShared(boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setZoneShared(boolean)");
    method.setSimpleName("setZoneShared");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setZoneShared(boolean)
    // starting method java.util.Calendar#setLenient(boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setLenient(boolean)");
    method.setSimpleName("setLenient");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setLenient(boolean)
    // starting method java.util.Calendar#isLenient()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isLenient()");
    method.setSimpleName("isLenient");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isLenient()
    // starting method java.util.Calendar#setFirstDayOfWeek(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setFirstDayOfWeek(int)");
    method.setSimpleName("setFirstDayOfWeek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setFirstDayOfWeek(int)
    // starting method java.util.Calendar#getFirstDayOfWeek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFirstDayOfWeek()");
    method.setSimpleName("getFirstDayOfWeek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getFirstDayOfWeek()
    // starting method java.util.Calendar#setMinimalDaysInFirstWeek(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setMinimalDaysInFirstWeek(int)");
    method.setSimpleName("setMinimalDaysInFirstWeek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setMinimalDaysInFirstWeek(int)
    // starting method java.util.Calendar#getMinimalDaysInFirstWeek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMinimalDaysInFirstWeek()");
    method.setSimpleName("getMinimalDaysInFirstWeek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getMinimalDaysInFirstWeek()
    // starting method java.util.Calendar#getMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMinimum(int)");
    method.setSimpleName("getMinimum");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getMinimum(int)
    // starting method java.util.Calendar#getMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMaximum(int)");
    method.setSimpleName("getMaximum");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getMaximum(int)
    // starting method java.util.Calendar#getGreatestMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getGreatestMinimum(int)");
    method.setSimpleName("getGreatestMinimum");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getGreatestMinimum(int)
    // starting method java.util.Calendar#getLeastMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLeastMaximum(int)");
    method.setSimpleName("getLeastMaximum");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getLeastMaximum(int)
    // starting method java.util.Calendar#getActualMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActualMinimum(int)");
    method.setSimpleName("getActualMinimum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getActualMinimum(int)
    // starting method java.util.Calendar#getActualMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActualMaximum(int)");
    method.setSimpleName("getActualMaximum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getActualMaximum(int)
    // starting method java.util.Calendar#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#clone()
    // starting method java.util.Calendar#getFieldName(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFieldName(int)");
    method.setSimpleName("getFieldName");
    helper.setMethodData(method,24);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getFieldName(int)
    // starting method java.util.Calendar#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#toString()
    // ignoring method java.util.Calendar#appendValue(java.lang.StringBuilder, java.lang.String, boolean, long)
    // ignoring method java.util.Calendar#setWeekCountData(java.util.Locale)
    // ignoring method java.util.Calendar#updateTime()
    // ignoring method java.util.Calendar#compareTo(long)
    // ignoring method java.util.Calendar#getMillisOf(java.util.Calendar)
    // ignoring method java.util.Calendar#adjustStamp()
    // ignoring method java.util.Calendar#invalidateWeekFields()
    // ignoring method java.util.Calendar#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.Calendar#readObject(java.io.ObjectInputStream)
    // starting method java.util.Calendar#compareTo(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.lang.Object)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#compareTo(java.lang.Object)

// finishing type java.util.Calendar
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Collection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Iterable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterable 


    // starting method java.util.Collection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#size()
    // starting method java.util.Collection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#isEmpty()
    // starting method java.util.Collection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#contains(java.lang.Object)
    // starting method java.util.Collection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#iterator()
    // starting method java.util.Collection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#toArray()
    // starting method java.util.Collection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#toArray(java.lang.Object[])
    // starting method java.util.Collection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#add(java.lang.Object)
    // starting method java.util.Collection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#remove(java.lang.Object)
    // starting method java.util.Collection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#containsAll(java.util.Collection)
    // starting method java.util.Collection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#addAll(java.util.Collection)
    // starting method java.util.Collection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#removeAll(java.util.Collection)
    // starting method java.util.Collection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#retainAll(java.util.Collection)
    // starting method java.util.Collection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#clear()
    // starting method java.util.Collection#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#equals(java.lang.Object)
    // starting method java.util.Collection#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#hashCode()

// finishing type java.util.Collection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$1#val$c
	field = newType.addNode(JavaDataField.class,"val$c"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$1#val$c


    // starting method java.util.Collections$1#Collections$1(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$1(java.util.Collection)");
    method.setSimpleName("Collections$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$1#Collections$1(java.util.Collection)
    // starting method java.util.Collections$1#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$1#hasMoreElements()
    // starting method java.util.Collections$1#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$1#nextElement()

// finishing type java.util.Collections$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedCollection$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.Collections$CheckedCollection$1#it 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedCollection$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$CheckedCollection");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedCollection$1#this$0


    // starting method java.util.Collections$CheckedCollection$1#Collections$CheckedCollection$1(java.util.Collections$CheckedCollection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedCollection$1(java.util.Collections$CheckedCollection)");
    method.setSimpleName("Collections$CheckedCollection$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection$1#Collections$CheckedCollection$1(java.util.Collections$CheckedCollection)
    // starting method java.util.Collections$CheckedCollection$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection$1#hasNext()
    // starting method java.util.Collections$CheckedCollection$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection$1#next()
    // starting method java.util.Collections$CheckedCollection$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection$1#remove()

// finishing type java.util.Collections$CheckedCollection$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedCollection#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedCollection#c
	field = newType.addNode(JavaDataField.class,"c"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedCollection#c

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedCollection#type
	field = newType.addNode(JavaDataField.class,"type"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedCollection#type

// ignoring field java.util.Collections$CheckedCollection#zeroLengthElementArray 


    // starting method java.util.Collections$CheckedCollection#typeCheck(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"typeCheck(java.lang.Object)");
    method.setSimpleName("typeCheck");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#typeCheck(java.lang.Object)
    // starting method java.util.Collections$CheckedCollection#Collections$CheckedCollection(java.util.Collection, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedCollection(java.util.Collection, java.lang.Class)");
    method.setSimpleName("Collections$CheckedCollection");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#Collections$CheckedCollection(java.util.Collection, java.lang.Class)
    // starting method java.util.Collections$CheckedCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#size()
    // starting method java.util.Collections$CheckedCollection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#isEmpty()
    // starting method java.util.Collections$CheckedCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#contains(java.lang.Object)
    // starting method java.util.Collections$CheckedCollection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#toArray()
    // starting method java.util.Collections$CheckedCollection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#toArray(java.lang.Object[])
    // starting method java.util.Collections$CheckedCollection#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#toString()
    // starting method java.util.Collections$CheckedCollection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#remove(java.lang.Object)
    // starting method java.util.Collections$CheckedCollection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#containsAll(java.util.Collection)
    // starting method java.util.Collections$CheckedCollection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#removeAll(java.util.Collection)
    // starting method java.util.Collections$CheckedCollection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#retainAll(java.util.Collection)
    // starting method java.util.Collections$CheckedCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#clear()
    // starting method java.util.Collections$CheckedCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#iterator()
    // starting method java.util.Collections$CheckedCollection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#add(java.lang.Object)
    // starting method java.util.Collections$CheckedCollection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#addAll(java.util.Collection)
    // starting method java.util.Collections$CheckedCollection#zeroLengthElementArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"zeroLengthElementArray()");
    method.setSimpleName("zeroLengthElementArray");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#zeroLengthElementArray()

// finishing type java.util.Collections$CheckedCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedList$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList$1#val$index
	field = newType.addNode(JavaDataField.class,"val$index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList$1#val$index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$CheckedList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList$1#this$0


    // starting method java.util.Collections$CheckedList$1#Collections$CheckedList$1(java.util.Collections$CheckedList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedList$1(java.util.Collections$CheckedList, int)");
    method.setSimpleName("Collections$CheckedList$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#Collections$CheckedList$1(java.util.Collections$CheckedList, int)
    // starting method java.util.Collections$CheckedList$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#hasNext()
    // starting method java.util.Collections$CheckedList$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#next()
    // starting method java.util.Collections$CheckedList$1#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#hasPrevious()
    // starting method java.util.Collections$CheckedList$1#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#previous()
    // starting method java.util.Collections$CheckedList$1#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#nextIndex()
    // starting method java.util.Collections$CheckedList$1#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#previousIndex()
    // starting method java.util.Collections$CheckedList$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#remove()
    // starting method java.util.Collections$CheckedList$1#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#set(java.lang.Object)
    // starting method java.util.Collections$CheckedList$1#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#add(java.lang.Object)

// finishing type java.util.Collections$CheckedList$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList#list
	field = newType.addNode(JavaDataField.class,"list"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList#list


    // starting method java.util.Collections$CheckedList#Collections$CheckedList(java.util.List, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedList(java.util.List, java.lang.Class)");
    method.setSimpleName("Collections$CheckedList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#Collections$CheckedList(java.util.List, java.lang.Class)
    // starting method java.util.Collections$CheckedList#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#equals(java.lang.Object)
    // starting method java.util.Collections$CheckedList#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#hashCode()
    // starting method java.util.Collections$CheckedList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#get(int)
    // starting method java.util.Collections$CheckedList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#remove(int)
    // starting method java.util.Collections$CheckedList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#indexOf(java.lang.Object)
    // starting method java.util.Collections$CheckedList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#lastIndexOf(java.lang.Object)
    // starting method java.util.Collections$CheckedList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#set(int, java.lang.Object)
    // starting method java.util.Collections$CheckedList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#add(int, java.lang.Object)
    // starting method java.util.Collections$CheckedList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#addAll(int, java.util.Collection)
    // starting method java.util.Collections$CheckedList#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#listIterator()
    // starting method java.util.Collections$CheckedList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#listIterator(int)
    // starting method java.util.Collections$CheckedList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#subList(int, int)

// finishing type java.util.Collections$CheckedList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap$CheckedEntrySet$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap$CheckedEntrySet$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap$CheckedEntrySet$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$CheckedMap$CheckedEntrySet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap$CheckedEntrySet$1#this$0


    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#Collections$CheckedMap$CheckedEntrySet$1(java.util.Collections$CheckedMap$CheckedEntrySet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedMap$CheckedEntrySet$1(java.util.Collections$CheckedMap$CheckedEntrySet)");
    method.setSimpleName("Collections$CheckedMap$CheckedEntrySet$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#Collections$CheckedMap$CheckedEntrySet$1(java.util.Collections$CheckedMap$CheckedEntrySet)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#hasNext()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#remove()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#next()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#next()

// finishing type java.util.Collections$CheckedMap$CheckedEntrySet$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet$CheckedEntry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

// ignoring field java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#e 

// ignoring field java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#valueType 


    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#Collections$CheckedMap$CheckedEntrySet$CheckedEntry(java.util.Map$Entry, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedMap$CheckedEntrySet$CheckedEntry(java.util.Map$Entry, java.lang.Class)");
    method.setSimpleName("Collections$CheckedMap$CheckedEntrySet$CheckedEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#Collections$CheckedMap$CheckedEntrySet$CheckedEntry(java.util.Map$Entry, java.lang.Class)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#getKey()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#getValue()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#hashCode()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#toString()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#setValue(java.lang.Object)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#equals(java.lang.Object)

// finishing type java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap$CheckedEntrySet#s
	field = newType.addNode(JavaDataField.class,"s"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap$CheckedEntrySet#s

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap$CheckedEntrySet#valueType
	field = newType.addNode(JavaDataField.class,"valueType"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap$CheckedEntrySet#valueType


    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#Collections$CheckedMap$CheckedEntrySet(java.util.Set, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedMap$CheckedEntrySet(java.util.Set, java.lang.Class)");
    method.setSimpleName("Collections$CheckedMap$CheckedEntrySet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#Collections$CheckedMap$CheckedEntrySet(java.util.Set, java.lang.Class)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#size()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#isEmpty()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#toString()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#hashCode()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#remove(java.lang.Object)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#removeAll(java.util.Collection)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#retainAll(java.util.Collection)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#clear()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#add(java.util.Map$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.util.Map$Entry)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#add(java.util.Map$Entry)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#addAll(java.util.Collection)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#iterator()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#toArray()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#toArray(java.lang.Object[])
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#contains(java.lang.Object)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#containsAll(java.util.Collection)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#equals(java.lang.Object)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#add(java.lang.Object)

// finishing type java.util.Collections$CheckedMap$CheckedEntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedMap#serialVersionUID 

// ignoring field java.util.Collections$CheckedMap#m 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap#keyType
	field = newType.addNode(JavaDataField.class,"keyType"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap#keyType

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap#valueType
	field = newType.addNode(JavaDataField.class,"valueType"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap#valueType

// ignoring field java.util.Collections$CheckedMap#zeroLengthKeyArray 

// ignoring field java.util.Collections$CheckedMap#zeroLengthValueArray 

// ignoring field java.util.Collections$CheckedMap#entrySet 


    // ignoring method java.util.Collections$CheckedMap#typeCheck(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$CheckedMap#Collections$CheckedMap(java.util.Map, java.lang.Class, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedMap(java.util.Map, java.lang.Class, java.lang.Class)");
    method.setSimpleName("Collections$CheckedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#Collections$CheckedMap(java.util.Map, java.lang.Class, java.lang.Class)
    // starting method java.util.Collections$CheckedMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#size()
    // starting method java.util.Collections$CheckedMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#isEmpty()
    // starting method java.util.Collections$CheckedMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#get(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#remove(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#clear()
    // starting method java.util.Collections$CheckedMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#keySet()
    // starting method java.util.Collections$CheckedMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#values()
    // starting method java.util.Collections$CheckedMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#equals(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#hashCode()
    // starting method java.util.Collections$CheckedMap#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#toString()
    // starting method java.util.Collections$CheckedMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$CheckedMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#putAll(java.util.Map)
    // ignoring method java.util.Collections$CheckedMap#zeroLengthKeyArray()
    // ignoring method java.util.Collections$CheckedMap#zeroLengthValueArray()
    // starting method java.util.Collections$CheckedMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#entrySet()

// finishing type java.util.Collections$CheckedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedRandomAccessList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 

// ignoring field java.util.Collections$CheckedRandomAccessList#serialVersionUID 


    // starting method java.util.Collections$CheckedRandomAccessList#Collections$CheckedRandomAccessList(java.util.List, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedRandomAccessList(java.util.List, java.lang.Class)");
    method.setSimpleName("Collections$CheckedRandomAccessList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedRandomAccessList#Collections$CheckedRandomAccessList(java.util.List, java.lang.Class)
    // starting method java.util.Collections$CheckedRandomAccessList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedRandomAccessList#subList(int, int)

// finishing type java.util.Collections$CheckedRandomAccessList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedSet#serialVersionUID 


    // starting method java.util.Collections$CheckedSet#Collections$CheckedSet(java.util.Set, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedSet(java.util.Set, java.lang.Class)");
    method.setSimpleName("Collections$CheckedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSet#Collections$CheckedSet(java.util.Set, java.lang.Class)
    // starting method java.util.Collections$CheckedSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSet#equals(java.lang.Object)
    // starting method java.util.Collections$CheckedSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSet#hashCode()

// finishing type java.util.Collections$CheckedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSortedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedSortedMap#serialVersionUID 

// ignoring field java.util.Collections$CheckedSortedMap#sm 


    // starting method java.util.Collections$CheckedSortedMap#Collections$CheckedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)");
    method.setSimpleName("Collections$CheckedSortedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#Collections$CheckedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)
    // starting method java.util.Collections$CheckedSortedMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#comparator()
    // starting method java.util.Collections$CheckedSortedMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#firstKey()
    // starting method java.util.Collections$CheckedSortedMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#lastKey()
    // starting method java.util.Collections$CheckedSortedMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$CheckedSortedMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#headMap(java.lang.Object)
    // starting method java.util.Collections$CheckedSortedMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#tailMap(java.lang.Object)

// finishing type java.util.Collections$CheckedSortedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSortedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedSet 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedSet");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedSet 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedSortedSet#serialVersionUID 

// ignoring field java.util.Collections$CheckedSortedSet#ss 


    // starting method java.util.Collections$CheckedSortedSet#Collections$CheckedSortedSet(java.util.SortedSet, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedSortedSet(java.util.SortedSet, java.lang.Class)");
    method.setSimpleName("Collections$CheckedSortedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#Collections$CheckedSortedSet(java.util.SortedSet, java.lang.Class)
    // starting method java.util.Collections$CheckedSortedSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#comparator()
    // starting method java.util.Collections$CheckedSortedSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#first()
    // starting method java.util.Collections$CheckedSortedSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#last()
    // starting method java.util.Collections$CheckedSortedSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$CheckedSortedSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#headSet(java.lang.Object)
    // starting method java.util.Collections$CheckedSortedSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#tailSet(java.lang.Object)

// finishing type java.util.Collections$CheckedSortedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CopiesList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CopiesList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$CopiesList#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CopiesList#n
	field = newType.addNode(JavaDataField.class,"n"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CopiesList#n

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CopiesList#element
	field = newType.addNode(JavaDataField.class,"element"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CopiesList#element


    // starting method java.util.Collections$CopiesList#Collections$CopiesList(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CopiesList(int, java.lang.Object)");
    method.setSimpleName("Collections$CopiesList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CopiesList#Collections$CopiesList(int, java.lang.Object)
    // starting method java.util.Collections$CopiesList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CopiesList#size()
    // starting method java.util.Collections$CopiesList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CopiesList#contains(java.lang.Object)
    // starting method java.util.Collections$CopiesList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CopiesList#get(int)

// finishing type java.util.Collections$CopiesList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptyList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$EmptyList#serialVersionUID 


    // ignoring method java.util.Collections$EmptyList#Collections$EmptyList()
    // starting method java.util.Collections$EmptyList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyList#size()
    // starting method java.util.Collections$EmptyList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyList#contains(java.lang.Object)
    // starting method java.util.Collections$EmptyList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyList#get(int)
    // ignoring method java.util.Collections$EmptyList#readResolve()
    // starting method java.util.Collections$EmptyList#Collections$EmptyList(java.util.Collections$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$EmptyList(java.util.Collections$1)");
    method.setSimpleName("Collections$EmptyList");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyList#Collections$EmptyList(java.util.Collections$1)

// finishing type java.util.Collections$EmptyList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptyMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$EmptyMap#serialVersionUID 


    // ignoring method java.util.Collections$EmptyMap#Collections$EmptyMap()
    // starting method java.util.Collections$EmptyMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#size()
    // starting method java.util.Collections$EmptyMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#isEmpty()
    // starting method java.util.Collections$EmptyMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$EmptyMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$EmptyMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#get(java.lang.Object)
    // starting method java.util.Collections$EmptyMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#keySet()
    // starting method java.util.Collections$EmptyMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#values()
    // starting method java.util.Collections$EmptyMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#entrySet()
    // starting method java.util.Collections$EmptyMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#equals(java.lang.Object)
    // starting method java.util.Collections$EmptyMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#hashCode()
    // ignoring method java.util.Collections$EmptyMap#readResolve()
    // starting method java.util.Collections$EmptyMap#Collections$EmptyMap(java.util.Collections$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$EmptyMap(java.util.Collections$1)");
    method.setSimpleName("Collections$EmptyMap");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#Collections$EmptyMap(java.util.Collections$1)

// finishing type java.util.Collections$EmptyMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptySet$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$EmptySet$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$EmptySet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$EmptySet$1#this$0


    // starting method java.util.Collections$EmptySet$1#Collections$EmptySet$1(java.util.Collections$EmptySet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$EmptySet$1(java.util.Collections$EmptySet)");
    method.setSimpleName("Collections$EmptySet$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet$1#Collections$EmptySet$1(java.util.Collections$EmptySet)
    // starting method java.util.Collections$EmptySet$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet$1#hasNext()
    // starting method java.util.Collections$EmptySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet$1#next()
    // starting method java.util.Collections$EmptySet$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet$1#remove()

// finishing type java.util.Collections$EmptySet$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$EmptySet#serialVersionUID 


    // ignoring method java.util.Collections$EmptySet#Collections$EmptySet()
    // starting method java.util.Collections$EmptySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet#iterator()
    // starting method java.util.Collections$EmptySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet#size()
    // starting method java.util.Collections$EmptySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet#contains(java.lang.Object)
    // ignoring method java.util.Collections$EmptySet#readResolve()
    // starting method java.util.Collections$EmptySet#Collections$EmptySet(java.util.Collections$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$EmptySet(java.util.Collections$1)");
    method.setSimpleName("Collections$EmptySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet#Collections$EmptySet(java.util.Collections$1)

// finishing type java.util.Collections$EmptySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$ReverseComparator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Comparator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Comparator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparator 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$ReverseComparator#serialVersionUID 


    // ignoring method java.util.Collections$ReverseComparator#Collections$ReverseComparator()
    // starting method java.util.Collections$ReverseComparator#compare(java.lang.Comparable, java.lang.Comparable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compare(java.lang.Comparable, java.lang.Comparable)");
    method.setSimpleName("compare");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator#compare(java.lang.Comparable, java.lang.Comparable)
    // starting method java.util.Collections$ReverseComparator#compare(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compare(java.lang.Object, java.lang.Object)");
    method.setSimpleName("compare");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator#compare(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$ReverseComparator#Collections$ReverseComparator(java.util.Collections$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$ReverseComparator(java.util.Collections$1)");
    method.setSimpleName("Collections$ReverseComparator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator#Collections$ReverseComparator(java.util.Collections$1)

// finishing type java.util.Collections$ReverseComparator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$ReverseComparator2");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Comparator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Comparator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparator 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$ReverseComparator2#serialVersionUID 

// ignoring field java.util.Collections$ReverseComparator2#cmp 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$ReverseComparator2#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.Collections$ReverseComparator2#$assertionsDisabled


    // starting method java.util.Collections$ReverseComparator2#Collections$ReverseComparator2(java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$ReverseComparator2(java.util.Comparator)");
    method.setSimpleName("Collections$ReverseComparator2");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator2#Collections$ReverseComparator2(java.util.Comparator)
    // starting method java.util.Collections$ReverseComparator2#compare(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compare(java.lang.Object, java.lang.Object)");
    method.setSimpleName("compare");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator2#compare(java.lang.Object, java.lang.Object)

// finishing type java.util.Collections$ReverseComparator2
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Collections$SelfComparable");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Comparable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Comparable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparable 



// finishing type java.util.Collections$SelfComparable
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SingletonList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$SingletonList#serialVersionUID

// ignoring field java.util.Collections$SingletonList#element 


    // starting method java.util.Collections$SingletonList#Collections$SingletonList(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonList(java.lang.Object)");
    method.setSimpleName("Collections$SingletonList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonList#Collections$SingletonList(java.lang.Object)
    // starting method java.util.Collections$SingletonList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonList#size()
    // starting method java.util.Collections$SingletonList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonList#contains(java.lang.Object)
    // starting method java.util.Collections$SingletonList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonList#get(int)

// finishing type java.util.Collections$SingletonList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonMap$ImmutableEntry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SingletonMap$ImmutableEntry#k
	field = newType.addNode(JavaDataField.class,"k"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$SingletonMap$ImmutableEntry#k

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SingletonMap$ImmutableEntry#v
	field = newType.addNode(JavaDataField.class,"v"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$SingletonMap$ImmutableEntry#v


    // starting method java.util.Collections$SingletonMap$ImmutableEntry#Collections$SingletonMap$ImmutableEntry(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonMap$ImmutableEntry(java.lang.Object, java.lang.Object)");
    method.setSimpleName("Collections$SingletonMap$ImmutableEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#Collections$SingletonMap$ImmutableEntry(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#getKey()
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#getValue()
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#setValue(java.lang.Object)
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#equals(java.lang.Object)
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#hashCode()
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#toString()

// finishing type java.util.Collections$SingletonMap$ImmutableEntry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$SingletonMap#serialVersionUID 

// ignoring field java.util.Collections$SingletonMap#k 

// ignoring field java.util.Collections$SingletonMap#v 

// ignoring field java.util.Collections$SingletonMap#keySet 

// ignoring field java.util.Collections$SingletonMap#entrySet 

// ignoring field java.util.Collections$SingletonMap#values 


    // starting method java.util.Collections$SingletonMap#Collections$SingletonMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("Collections$SingletonMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#Collections$SingletonMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SingletonMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#size()
    // starting method java.util.Collections$SingletonMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#isEmpty()
    // starting method java.util.Collections$SingletonMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$SingletonMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$SingletonMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#get(java.lang.Object)
    // starting method java.util.Collections$SingletonMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#keySet()
    // starting method java.util.Collections$SingletonMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#entrySet()
    // starting method java.util.Collections$SingletonMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#values()

// finishing type java.util.Collections$SingletonMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonSet$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.Collections$SingletonSet$1#hasNext 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SingletonSet$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$SingletonSet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$SingletonSet$1#this$0


    // starting method java.util.Collections$SingletonSet$1#Collections$SingletonSet$1(java.util.Collections$SingletonSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonSet$1(java.util.Collections$SingletonSet)");
    method.setSimpleName("Collections$SingletonSet$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet$1#Collections$SingletonSet$1(java.util.Collections$SingletonSet)
    // starting method java.util.Collections$SingletonSet$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet$1#hasNext()
    // starting method java.util.Collections$SingletonSet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet$1#next()
    // starting method java.util.Collections$SingletonSet$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet$1#remove()

// finishing type java.util.Collections$SingletonSet$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$SingletonSet#serialVersionUID 

// ignoring field java.util.Collections$SingletonSet#element 


    // starting method java.util.Collections$SingletonSet#Collections$SingletonSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonSet(java.lang.Object)");
    method.setSimpleName("Collections$SingletonSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#Collections$SingletonSet(java.lang.Object)
    // starting method java.util.Collections$SingletonSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#iterator()
    // starting method java.util.Collections$SingletonSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#size()
    // starting method java.util.Collections$SingletonSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#contains(java.lang.Object)
    // starting method java.util.Collections$SingletonSet#access$400(java.util.Collections$SingletonSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.Collections$SingletonSet)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#access$400(java.util.Collections$SingletonSet)

// finishing type java.util.Collections$SingletonSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$SynchronizedCollection#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedCollection#c
	field = newType.addNode(JavaDataField.class,"c"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedCollection#c

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedCollection#mutex
	field = newType.addNode(JavaDataField.class,"mutex"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedCollection#mutex


    // starting method java.util.Collections$SynchronizedCollection#Collections$SynchronizedCollection(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedCollection(java.util.Collection)");
    method.setSimpleName("Collections$SynchronizedCollection");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#Collections$SynchronizedCollection(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#Collections$SynchronizedCollection(java.util.Collection, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedCollection(java.util.Collection, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedCollection");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#Collections$SynchronizedCollection(java.util.Collection, java.lang.Object)
    // starting method java.util.Collections$SynchronizedCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#size()
    // starting method java.util.Collections$SynchronizedCollection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#isEmpty()
    // starting method java.util.Collections$SynchronizedCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#contains(java.lang.Object)
    // starting method java.util.Collections$SynchronizedCollection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#toArray()
    // starting method java.util.Collections$SynchronizedCollection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#toArray(java.lang.Object[])
    // starting method java.util.Collections$SynchronizedCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#iterator()
    // starting method java.util.Collections$SynchronizedCollection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#add(java.lang.Object)
    // starting method java.util.Collections$SynchronizedCollection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#remove(java.lang.Object)
    // starting method java.util.Collections$SynchronizedCollection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#containsAll(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#addAll(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#removeAll(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#retainAll(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#clear()
    // starting method java.util.Collections$SynchronizedCollection#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#toString()
    // ignoring method java.util.Collections$SynchronizedCollection#writeObject(java.io.ObjectOutputStream)

// finishing type java.util.Collections$SynchronizedCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedList#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedList#list
	field = newType.addNode(JavaDataField.class,"list"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedList#list


    // starting method java.util.Collections$SynchronizedList#Collections$SynchronizedList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedList(java.util.List)");
    method.setSimpleName("Collections$SynchronizedList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#Collections$SynchronizedList(java.util.List)
    // starting method java.util.Collections$SynchronizedList#Collections$SynchronizedList(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedList(java.util.List, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#Collections$SynchronizedList(java.util.List, java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#equals(java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#hashCode()
    // starting method java.util.Collections$SynchronizedList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#get(int)
    // starting method java.util.Collections$SynchronizedList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#set(int, java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#add(int, java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#remove(int)
    // starting method java.util.Collections$SynchronizedList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#indexOf(java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#lastIndexOf(java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#addAll(int, java.util.Collection)
    // starting method java.util.Collections$SynchronizedList#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#listIterator()
    // starting method java.util.Collections$SynchronizedList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#listIterator(int)
    // starting method java.util.Collections$SynchronizedList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#subList(int, int)
    // ignoring method java.util.Collections$SynchronizedList#readResolve()

// finishing type java.util.Collections$SynchronizedList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$SynchronizedMap#serialVersionUID 

// ignoring field java.util.Collections$SynchronizedMap#m 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedMap#mutex
	field = newType.addNode(JavaDataField.class,"mutex"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedMap#mutex

// ignoring field java.util.Collections$SynchronizedMap#keySet 

// ignoring field java.util.Collections$SynchronizedMap#entrySet 

// ignoring field java.util.Collections$SynchronizedMap#values 


    // starting method java.util.Collections$SynchronizedMap#Collections$SynchronizedMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedMap(java.util.Map)");
    method.setSimpleName("Collections$SynchronizedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#Collections$SynchronizedMap(java.util.Map)
    // starting method java.util.Collections$SynchronizedMap#Collections$SynchronizedMap(java.util.Map, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedMap(java.util.Map, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#Collections$SynchronizedMap(java.util.Map, java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#size()
    // starting method java.util.Collections$SynchronizedMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#isEmpty()
    // starting method java.util.Collections$SynchronizedMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#get(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#remove(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#putAll(java.util.Map)
    // starting method java.util.Collections$SynchronizedMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#clear()
    // starting method java.util.Collections$SynchronizedMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#keySet()
    // starting method java.util.Collections$SynchronizedMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#entrySet()
    // starting method java.util.Collections$SynchronizedMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#values()
    // starting method java.util.Collections$SynchronizedMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#equals(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#hashCode()
    // starting method java.util.Collections$SynchronizedMap#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#toString()
    // ignoring method java.util.Collections$SynchronizedMap#writeObject(java.io.ObjectOutputStream)

// finishing type java.util.Collections$SynchronizedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedRandomAccessList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedRandomAccessList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedRandomAccessList#serialVersionUID


    // starting method java.util.Collections$SynchronizedRandomAccessList#Collections$SynchronizedRandomAccessList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedRandomAccessList(java.util.List)");
    method.setSimpleName("Collections$SynchronizedRandomAccessList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedRandomAccessList#Collections$SynchronizedRandomAccessList(java.util.List)
    // starting method java.util.Collections$SynchronizedRandomAccessList#Collections$SynchronizedRandomAccessList(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedRandomAccessList(java.util.List, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedRandomAccessList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedRandomAccessList#Collections$SynchronizedRandomAccessList(java.util.List, java.lang.Object)
    // starting method java.util.Collections$SynchronizedRandomAccessList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedRandomAccessList#subList(int, int)
    // ignoring method java.util.Collections$SynchronizedRandomAccessList#writeReplace()

// finishing type java.util.Collections$SynchronizedRandomAccessList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 

// ignoring field java.util.Collections$SynchronizedSet#serialVersionUID 


    // starting method java.util.Collections$SynchronizedSet#Collections$SynchronizedSet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSet(java.util.Set)");
    method.setSimpleName("Collections$SynchronizedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSet#Collections$SynchronizedSet(java.util.Set)
    // starting method java.util.Collections$SynchronizedSet#Collections$SynchronizedSet(java.util.Set, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSet(java.util.Set, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSet#Collections$SynchronizedSet(java.util.Set, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSet#equals(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSet#hashCode()

// finishing type java.util.Collections$SynchronizedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSortedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 

// ignoring field java.util.Collections$SynchronizedSortedMap#serialVersionUID 

// ignoring field java.util.Collections$SynchronizedSortedMap#sm 


    // starting method java.util.Collections$SynchronizedSortedMap#Collections$SynchronizedSortedMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSortedMap(java.util.SortedMap)");
    method.setSimpleName("Collections$SynchronizedSortedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#Collections$SynchronizedSortedMap(java.util.SortedMap)
    // starting method java.util.Collections$SynchronizedSortedMap#Collections$SynchronizedSortedMap(java.util.SortedMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSortedMap(java.util.SortedMap, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedSortedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#Collections$SynchronizedSortedMap(java.util.SortedMap, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#comparator()
    // starting method java.util.Collections$SynchronizedSortedMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#headMap(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#tailMap(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#firstKey()
    // starting method java.util.Collections$SynchronizedSortedMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#lastKey()

// finishing type java.util.Collections$SynchronizedSortedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSortedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedSet 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedSet");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedSet 

// ignoring field java.util.Collections$SynchronizedSortedSet#serialVersionUID 

// ignoring field java.util.Collections$SynchronizedSortedSet#ss 


    // starting method java.util.Collections$SynchronizedSortedSet#Collections$SynchronizedSortedSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSortedSet(java.util.SortedSet)");
    method.setSimpleName("Collections$SynchronizedSortedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#Collections$SynchronizedSortedSet(java.util.SortedSet)
    // starting method java.util.Collections$SynchronizedSortedSet#Collections$SynchronizedSortedSet(java.util.SortedSet, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSortedSet(java.util.SortedSet, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedSortedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#Collections$SynchronizedSortedSet(java.util.SortedSet, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#comparator()
    // starting method java.util.Collections$SynchronizedSortedSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#headSet(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#tailSet(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#first()
    // starting method java.util.Collections$SynchronizedSortedSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#last()

// finishing type java.util.Collections$SynchronizedSortedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableCollection$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableCollection$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableCollection$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableCollection$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$UnmodifiableCollection");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableCollection$1#this$0


    // starting method java.util.Collections$UnmodifiableCollection$1#Collections$UnmodifiableCollection$1(java.util.Collections$UnmodifiableCollection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableCollection$1(java.util.Collections$UnmodifiableCollection)");
    method.setSimpleName("Collections$UnmodifiableCollection$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection$1#Collections$UnmodifiableCollection$1(java.util.Collections$UnmodifiableCollection)
    // starting method java.util.Collections$UnmodifiableCollection$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection$1#hasNext()
    // starting method java.util.Collections$UnmodifiableCollection$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection$1#next()
    // starting method java.util.Collections$UnmodifiableCollection$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection$1#remove()

// finishing type java.util.Collections$UnmodifiableCollection$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableCollection#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableCollection#c
	field = newType.addNode(JavaDataField.class,"c"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableCollection#c


    // starting method java.util.Collections$UnmodifiableCollection#Collections$UnmodifiableCollection(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableCollection(java.util.Collection)");
    method.setSimpleName("Collections$UnmodifiableCollection");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#Collections$UnmodifiableCollection(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#size()
    // starting method java.util.Collections$UnmodifiableCollection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#isEmpty()
    // starting method java.util.Collections$UnmodifiableCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#contains(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableCollection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#toArray()
    // starting method java.util.Collections$UnmodifiableCollection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#toArray(java.lang.Object[])
    // starting method java.util.Collections$UnmodifiableCollection#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#toString()
    // starting method java.util.Collections$UnmodifiableCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#iterator()
    // starting method java.util.Collections$UnmodifiableCollection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#add(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableCollection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#remove(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableCollection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#containsAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#addAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#removeAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#retainAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#clear()

// finishing type java.util.Collections$UnmodifiableCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableList$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList$1#val$index
	field = newType.addNode(JavaDataField.class,"val$index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList$1#val$index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$UnmodifiableList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList$1#this$0


    // starting method java.util.Collections$UnmodifiableList$1#Collections$UnmodifiableList$1(java.util.Collections$UnmodifiableList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableList$1(java.util.Collections$UnmodifiableList, int)");
    method.setSimpleName("Collections$UnmodifiableList$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#Collections$UnmodifiableList$1(java.util.Collections$UnmodifiableList, int)
    // starting method java.util.Collections$UnmodifiableList$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#hasNext()
    // starting method java.util.Collections$UnmodifiableList$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#next()
    // starting method java.util.Collections$UnmodifiableList$1#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#hasPrevious()
    // starting method java.util.Collections$UnmodifiableList$1#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#previous()
    // starting method java.util.Collections$UnmodifiableList$1#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#nextIndex()
    // starting method java.util.Collections$UnmodifiableList$1#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#previousIndex()
    // starting method java.util.Collections$UnmodifiableList$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#remove()
    // starting method java.util.Collections$UnmodifiableList$1#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#set(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList$1#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#add(java.lang.Object)

// finishing type java.util.Collections$UnmodifiableList$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList#list
	field = newType.addNode(JavaDataField.class,"list"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList#list


    // starting method java.util.Collections$UnmodifiableList#Collections$UnmodifiableList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableList(java.util.List)");
    method.setSimpleName("Collections$UnmodifiableList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#Collections$UnmodifiableList(java.util.List)
    // starting method java.util.Collections$UnmodifiableList#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#equals(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#hashCode()
    // starting method java.util.Collections$UnmodifiableList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#get(int)
    // starting method java.util.Collections$UnmodifiableList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#set(int, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#add(int, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#remove(int)
    // starting method java.util.Collections$UnmodifiableList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#indexOf(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#lastIndexOf(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#addAll(int, java.util.Collection)
    // starting method java.util.Collections$UnmodifiableList#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#listIterator()
    // starting method java.util.Collections$UnmodifiableList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#listIterator(int)
    // starting method java.util.Collections$UnmodifiableList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#subList(int, int)
    // ignoring method java.util.Collections$UnmodifiableList#readResolve()

// finishing type java.util.Collections$UnmodifiableList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$UnmodifiableMap$UnmodifiableEntrySet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#this$0


    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#Collections$UnmodifiableMap$UnmodifiableEntrySet$1(java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableMap$UnmodifiableEntrySet$1(java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet)");
    method.setSimpleName("Collections$UnmodifiableMap$UnmodifiableEntrySet$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#Collections$UnmodifiableMap$UnmodifiableEntrySet$1(java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#hasNext()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#next()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#remove()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#next()

// finishing type java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

// ignoring field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#e 


    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(java.util.Map$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(java.util.Map$Entry)");
    method.setSimpleName("Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(java.util.Map$Entry)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#getKey()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#getValue()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#setValue(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#hashCode()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#equals(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#toString()

// finishing type java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#serialVersionUID 


    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#Collections$UnmodifiableMap$UnmodifiableEntrySet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableMap$UnmodifiableEntrySet(java.util.Set)");
    method.setSimpleName("Collections$UnmodifiableMap$UnmodifiableEntrySet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#Collections$UnmodifiableMap$UnmodifiableEntrySet(java.util.Set)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#iterator()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#toArray()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#toArray(java.lang.Object[])
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#contains(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#containsAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#equals(java.lang.Object)

// finishing type java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableMap#serialVersionUID 

// ignoring field java.util.Collections$UnmodifiableMap#m 

// ignoring field java.util.Collections$UnmodifiableMap#keySet 

// ignoring field java.util.Collections$UnmodifiableMap#entrySet 

// ignoring field java.util.Collections$UnmodifiableMap#values 


    // starting method java.util.Collections$UnmodifiableMap#Collections$UnmodifiableMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableMap(java.util.Map)");
    method.setSimpleName("Collections$UnmodifiableMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#Collections$UnmodifiableMap(java.util.Map)
    // starting method java.util.Collections$UnmodifiableMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#size()
    // starting method java.util.Collections$UnmodifiableMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#isEmpty()
    // starting method java.util.Collections$UnmodifiableMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#get(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#remove(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#putAll(java.util.Map)
    // starting method java.util.Collections$UnmodifiableMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#clear()
    // starting method java.util.Collections$UnmodifiableMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#keySet()
    // starting method java.util.Collections$UnmodifiableMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#entrySet()
    // starting method java.util.Collections$UnmodifiableMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#values()
    // starting method java.util.Collections$UnmodifiableMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#equals(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#hashCode()
    // starting method java.util.Collections$UnmodifiableMap#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#toString()

// finishing type java.util.Collections$UnmodifiableMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableRandomAccessList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 

// ignoring field java.util.Collections$UnmodifiableRandomAccessList#serialVersionUID 


    // starting method java.util.Collections$UnmodifiableRandomAccessList#Collections$UnmodifiableRandomAccessList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableRandomAccessList(java.util.List)");
    method.setSimpleName("Collections$UnmodifiableRandomAccessList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableRandomAccessList#Collections$UnmodifiableRandomAccessList(java.util.List)
    // starting method java.util.Collections$UnmodifiableRandomAccessList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableRandomAccessList#subList(int, int)
    // ignoring method java.util.Collections$UnmodifiableRandomAccessList#writeReplace()

// finishing type java.util.Collections$UnmodifiableRandomAccessList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableSet#serialVersionUID 


    // starting method java.util.Collections$UnmodifiableSet#Collections$UnmodifiableSet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableSet(java.util.Set)");
    method.setSimpleName("Collections$UnmodifiableSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSet#Collections$UnmodifiableSet(java.util.Set)
    // starting method java.util.Collections$UnmodifiableSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSet#equals(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSet#hashCode()

// finishing type java.util.Collections$UnmodifiableSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSortedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableSortedMap#serialVersionUID 

// ignoring field java.util.Collections$UnmodifiableSortedMap#sm 


    // starting method java.util.Collections$UnmodifiableSortedMap#Collections$UnmodifiableSortedMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableSortedMap(java.util.SortedMap)");
    method.setSimpleName("Collections$UnmodifiableSortedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#Collections$UnmodifiableSortedMap(java.util.SortedMap)
    // starting method java.util.Collections$UnmodifiableSortedMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#comparator()
    // starting method java.util.Collections$UnmodifiableSortedMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#headMap(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#tailMap(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#firstKey()
    // starting method java.util.Collections$UnmodifiableSortedMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#lastKey()

// finishing type java.util.Collections$UnmodifiableSortedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSortedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedSet 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedSet");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedSet 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableSortedSet#serialVersionUID 

// ignoring field java.util.Collections$UnmodifiableSortedSet#ss 


    // starting method java.util.Collections$UnmodifiableSortedSet#Collections$UnmodifiableSortedSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableSortedSet(java.util.SortedSet)");
    method.setSimpleName("Collections$UnmodifiableSortedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#Collections$UnmodifiableSortedSet(java.util.SortedSet)
    // starting method java.util.Collections$UnmodifiableSortedSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#comparator()
    // starting method java.util.Collections$UnmodifiableSortedSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#headSet(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#tailSet(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#first()
    // starting method java.util.Collections$UnmodifiableSortedSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#last()

// finishing type java.util.Collections$UnmodifiableSortedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Collections#BINARYSEARCH_THRESHOLD 

// ignoring field java.util.Collections#REVERSE_THRESHOLD 

// ignoring field java.util.Collections#SHUFFLE_THRESHOLD 

// ignoring field java.util.Collections#FILL_THRESHOLD 

// ignoring field java.util.Collections#ROTATE_THRESHOLD 

// ignoring field java.util.Collections#COPY_THRESHOLD 

// ignoring field java.util.Collections#REPLACEALL_THRESHOLD 

// ignoring field java.util.Collections#INDEXOFSUBLIST_THRESHOLD 

// ignoring field java.util.Collections#r 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections#EMPTY_SET
	field = newType.addNode(JavaDataField.class,"EMPTY_SET"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Collections#EMPTY_SET

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections#EMPTY_LIST
	field = newType.addNode(JavaDataField.class,"EMPTY_LIST"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Collections#EMPTY_LIST

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections#EMPTY_MAP
	field = newType.addNode(JavaDataField.class,"EMPTY_MAP"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Collections#EMPTY_MAP

// ignoring field java.util.Collections#REVERSE_ORDER 


    // ignoring method java.util.Collections#Collections()
    // starting method java.util.Collections#sort(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.util.List)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#sort(java.util.List)
    // starting method java.util.Collections#sort(java.util.List, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.util.List, java.util.Comparator)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#sort(java.util.List, java.util.Comparator)
    // starting method java.util.Collections#binarySearch(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(java.util.List, java.lang.Object)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#binarySearch(java.util.List, java.lang.Object)
    // ignoring method java.util.Collections#indexedBinarySearch(java.util.List, java.lang.Object)
    // ignoring method java.util.Collections#iteratorBinarySearch(java.util.List, java.lang.Object)
    // ignoring method java.util.Collections#get(java.util.ListIterator, int)
    // starting method java.util.Collections#binarySearch(java.util.List, java.lang.Object, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(java.util.List, java.lang.Object, java.util.Comparator)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#binarySearch(java.util.List, java.lang.Object, java.util.Comparator)
    // ignoring method java.util.Collections#indexedBinarySearch(java.util.List, java.lang.Object, java.util.Comparator)
    // ignoring method java.util.Collections#iteratorBinarySearch(java.util.List, java.lang.Object, java.util.Comparator)
    // starting method java.util.Collections#reverse(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"reverse(java.util.List)");
    method.setSimpleName("reverse");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#reverse(java.util.List)
    // starting method java.util.Collections#shuffle(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"shuffle(java.util.List)");
    method.setSimpleName("shuffle");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#shuffle(java.util.List)
    // starting method java.util.Collections#shuffle(java.util.List, java.util.Random)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"shuffle(java.util.List, java.util.Random)");
    method.setSimpleName("shuffle");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#shuffle(java.util.List, java.util.Random)
    // starting method java.util.Collections#swap(java.util.List, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"swap(java.util.List, int, int)");
    method.setSimpleName("swap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#swap(java.util.List, int, int)
    // ignoring method java.util.Collections#swap(java.lang.Object[], int, int)
    // starting method java.util.Collections#fill(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(java.util.List, java.lang.Object)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#fill(java.util.List, java.lang.Object)
    // starting method java.util.Collections#copy(java.util.List, java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"copy(java.util.List, java.util.List)");
    method.setSimpleName("copy");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#copy(java.util.List, java.util.List)
    // starting method java.util.Collections#min(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"min(java.util.Collection)");
    method.setSimpleName("min");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#min(java.util.Collection)
    // starting method java.util.Collections#min(java.util.Collection, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"min(java.util.Collection, java.util.Comparator)");
    method.setSimpleName("min");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#min(java.util.Collection, java.util.Comparator)
    // starting method java.util.Collections#max(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"max(java.util.Collection)");
    method.setSimpleName("max");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#max(java.util.Collection)
    // starting method java.util.Collections#max(java.util.Collection, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"max(java.util.Collection, java.util.Comparator)");
    method.setSimpleName("max");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#max(java.util.Collection, java.util.Comparator)
    // starting method java.util.Collections#rotate(java.util.List, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"rotate(java.util.List, int)");
    method.setSimpleName("rotate");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#rotate(java.util.List, int)
    // ignoring method java.util.Collections#rotate1(java.util.List, int)
    // ignoring method java.util.Collections#rotate2(java.util.List, int)
    // starting method java.util.Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"replaceAll(java.util.List, java.lang.Object, java.lang.Object)");
    method.setSimpleName("replaceAll");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
    // starting method java.util.Collections#indexOfSubList(java.util.List, java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOfSubList(java.util.List, java.util.List)");
    method.setSimpleName("indexOfSubList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#indexOfSubList(java.util.List, java.util.List)
    // starting method java.util.Collections#lastIndexOfSubList(java.util.List, java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOfSubList(java.util.List, java.util.List)");
    method.setSimpleName("lastIndexOfSubList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#lastIndexOfSubList(java.util.List, java.util.List)
    // starting method java.util.Collections#unmodifiableCollection(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableCollection(java.util.Collection)");
    method.setSimpleName("unmodifiableCollection");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableCollection(java.util.Collection)
    // starting method java.util.Collections#unmodifiableSet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableSet(java.util.Set)");
    method.setSimpleName("unmodifiableSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableSet(java.util.Set)
    // starting method java.util.Collections#unmodifiableSortedSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableSortedSet(java.util.SortedSet)");
    method.setSimpleName("unmodifiableSortedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableSortedSet(java.util.SortedSet)
    // starting method java.util.Collections#unmodifiableList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableList(java.util.List)");
    method.setSimpleName("unmodifiableList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableList(java.util.List)
    // starting method java.util.Collections#unmodifiableMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableMap(java.util.Map)");
    method.setSimpleName("unmodifiableMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableMap(java.util.Map)
    // starting method java.util.Collections#unmodifiableSortedMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableSortedMap(java.util.SortedMap)");
    method.setSimpleName("unmodifiableSortedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableSortedMap(java.util.SortedMap)
    // starting method java.util.Collections#synchronizedCollection(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedCollection(java.util.Collection)");
    method.setSimpleName("synchronizedCollection");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedCollection(java.util.Collection)
    // starting method java.util.Collections#synchronizedCollection(java.util.Collection, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedCollection(java.util.Collection, java.lang.Object)");
    method.setSimpleName("synchronizedCollection");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedCollection(java.util.Collection, java.lang.Object)
    // starting method java.util.Collections#synchronizedSet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedSet(java.util.Set)");
    method.setSimpleName("synchronizedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedSet(java.util.Set)
    // starting method java.util.Collections#synchronizedSet(java.util.Set, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedSet(java.util.Set, java.lang.Object)");
    method.setSimpleName("synchronizedSet");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedSet(java.util.Set, java.lang.Object)
    // starting method java.util.Collections#synchronizedSortedSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedSortedSet(java.util.SortedSet)");
    method.setSimpleName("synchronizedSortedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedSortedSet(java.util.SortedSet)
    // starting method java.util.Collections#synchronizedList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedList(java.util.List)");
    method.setSimpleName("synchronizedList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedList(java.util.List)
    // starting method java.util.Collections#synchronizedList(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedList(java.util.List, java.lang.Object)");
    method.setSimpleName("synchronizedList");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedList(java.util.List, java.lang.Object)
    // starting method java.util.Collections#synchronizedMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedMap(java.util.Map)");
    method.setSimpleName("synchronizedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedMap(java.util.Map)
    // starting method java.util.Collections#synchronizedSortedMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedSortedMap(java.util.SortedMap)");
    method.setSimpleName("synchronizedSortedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedSortedMap(java.util.SortedMap)
    // starting method java.util.Collections#checkedCollection(java.util.Collection, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedCollection(java.util.Collection, java.lang.Class)");
    method.setSimpleName("checkedCollection");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedCollection(java.util.Collection, java.lang.Class)
    // starting method java.util.Collections#checkedSet(java.util.Set, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedSet(java.util.Set, java.lang.Class)");
    method.setSimpleName("checkedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedSet(java.util.Set, java.lang.Class)
    // starting method java.util.Collections#checkedSortedSet(java.util.SortedSet, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedSortedSet(java.util.SortedSet, java.lang.Class)");
    method.setSimpleName("checkedSortedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedSortedSet(java.util.SortedSet, java.lang.Class)
    // starting method java.util.Collections#checkedList(java.util.List, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedList(java.util.List, java.lang.Class)");
    method.setSimpleName("checkedList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedList(java.util.List, java.lang.Class)
    // starting method java.util.Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedMap(java.util.Map, java.lang.Class, java.lang.Class)");
    method.setSimpleName("checkedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
    // starting method java.util.Collections#checkedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)");
    method.setSimpleName("checkedSortedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)
    // starting method java.util.Collections#emptySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"emptySet()");
    method.setSimpleName("emptySet");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#emptySet()
    // starting method java.util.Collections#emptyList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"emptyList()");
    method.setSimpleName("emptyList");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#emptyList()
    // starting method java.util.Collections#emptyMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"emptyMap()");
    method.setSimpleName("emptyMap");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#emptyMap()
    // starting method java.util.Collections#singleton(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"singleton(java.lang.Object)");
    method.setSimpleName("singleton");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#singleton(java.lang.Object)
    // starting method java.util.Collections#singletonList(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"singletonList(java.lang.Object)");
    method.setSimpleName("singletonList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#singletonList(java.lang.Object)
    // starting method java.util.Collections#singletonMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"singletonMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("singletonMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#singletonMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections#nCopies(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nCopies(int, java.lang.Object)");
    method.setSimpleName("nCopies");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#nCopies(int, java.lang.Object)
    // starting method java.util.Collections#reverseOrder()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"reverseOrder()");
    method.setSimpleName("reverseOrder");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#reverseOrder()
    // starting method java.util.Collections#reverseOrder(java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"reverseOrder(java.util.Comparator)");
    method.setSimpleName("reverseOrder");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#reverseOrder(java.util.Comparator)
    // starting method java.util.Collections#enumeration(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"enumeration(java.util.Collection)");
    method.setSimpleName("enumeration");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#enumeration(java.util.Collection)
    // starting method java.util.Collections#list(java.util.Enumeration)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"list(java.util.Enumeration)");
    method.setSimpleName("list");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ArrayList");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#list(java.util.Enumeration)
    // ignoring method java.util.Collections#eq(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections#frequency(java.util.Collection, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"frequency(java.util.Collection, java.lang.Object)");
    method.setSimpleName("frequency");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#frequency(java.util.Collection, java.lang.Object)
    // starting method java.util.Collections#disjoint(java.util.Collection, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"disjoint(java.util.Collection, java.util.Collection)");
    method.setSimpleName("disjoint");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#disjoint(java.util.Collection, java.util.Collection)
    // starting method java.util.Collections#addAll(java.util.Collection, java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection, java.lang.Object[])");
    method.setSimpleName("addAll");
    helper.setMethodData(method,137);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#addAll(java.util.Collection, java.lang.Object[])
    // starting method java.util.Collections#access$000(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#access$000(java.lang.Object, java.lang.Object)

// finishing type java.util.Collections
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Comparator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Comparator#compare(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compare(java.lang.Object, java.lang.Object)");
    method.setSimpleName("compare");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Comparator#compare(java.lang.Object, java.lang.Object)
    // starting method java.util.Comparator#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Comparator#equals(java.lang.Object)

// finishing type java.util.Comparator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ConcurrentModificationException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","RuntimeException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.ConcurrentModificationException#ConcurrentModificationException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ConcurrentModificationException()");
    method.setSimpleName("ConcurrentModificationException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ConcurrentModificationException#ConcurrentModificationException()
    // starting method java.util.ConcurrentModificationException#ConcurrentModificationException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ConcurrentModificationException(java.lang.String)");
    method.setSimpleName("ConcurrentModificationException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ConcurrentModificationException#ConcurrentModificationException(java.lang.String)

// finishing type java.util.ConcurrentModificationException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Currency$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface PrivilegedAction 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PrivilegedAction");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface PrivilegedAction 


    // starting method java.util.Currency$1#Currency$1()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Currency$1()");
    method.setSimpleName("Currency$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency$1#Currency$1()
    // starting method java.util.Currency$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency$1#run()

// finishing type java.util.Currency$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Currency");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Currency#serialVersionUID 

// ignoring field java.util.Currency#currencyCode 

// ignoring field java.util.Currency#defaultFractionDigits 

// ignoring field java.util.Currency#instances 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#mainTable
	field = newType.addNode(JavaDataField.class,"mainTable"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#mainTable

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scCutOverTimes
	field = newType.addNode(JavaDataField.class,"scCutOverTimes"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scCutOverTimes

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scOldCurrencies
	field = newType.addNode(JavaDataField.class,"scOldCurrencies"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scOldCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scNewCurrencies
	field = newType.addNode(JavaDataField.class,"scNewCurrencies"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scNewCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scOldCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"scOldCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scOldCurrenciesDFD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scNewCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"scNewCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scNewCurrenciesDFD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#otherCurrencies
	field = newType.addNode(JavaDataField.class,"otherCurrencies"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#otherCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#otherCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"otherCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#otherCurrenciesDFD

// ignoring field java.util.Currency#A_TO_Z 

// ignoring field java.util.Currency#INVALID_COUNTRY_ENTRY 

// ignoring field java.util.Currency#COUNTRY_WITHOUT_CURRENCY_ENTRY 

// ignoring field java.util.Currency#SIMPLE_CASE_COUNTRY_MASK 

// ignoring field java.util.Currency#SIMPLE_CASE_COUNTRY_FINAL_CHAR_MASK 

// ignoring field java.util.Currency#SIMPLE_CASE_COUNTRY_DEFAULT_DIGITS_MASK 

// ignoring field java.util.Currency#SIMPLE_CASE_COUNTRY_DEFAULT_DIGITS_SHIFT 

// ignoring field java.util.Currency#SPECIAL_CASE_COUNTRY_MASK 

// ignoring field java.util.Currency#SPECIAL_CASE_COUNTRY_INDEX_MASK 

// ignoring field java.util.Currency#SPECIAL_CASE_COUNTRY_INDEX_DELTA 

// ignoring field java.util.Currency#COUNTRY_TYPE_MASK 


    // ignoring method java.util.Currency#Currency(java.lang.String, int)
    // starting method java.util.Currency#getInstance(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.lang.String)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Currency");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getInstance(java.lang.String)
    // ignoring method java.util.Currency#getInstance(java.lang.String, int)
    // starting method java.util.Currency#getInstance(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.util.Locale)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Currency");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getInstance(java.util.Locale)
    // starting method java.util.Currency#getCurrencyCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getCurrencyCode()");
    method.setSimpleName("getCurrencyCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getCurrencyCode()
    // starting method java.util.Currency#getSymbol()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSymbol()");
    method.setSimpleName("getSymbol");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getSymbol()
    // starting method java.util.Currency#getSymbol(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSymbol(java.util.Locale)");
    method.setSimpleName("getSymbol");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getSymbol(java.util.Locale)
    // starting method java.util.Currency#getDefaultFractionDigits()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDefaultFractionDigits()");
    method.setSimpleName("getDefaultFractionDigits");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getDefaultFractionDigits()
    // starting method java.util.Currency#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#toString()
    // ignoring method java.util.Currency#readResolve()
    // ignoring method java.util.Currency#getMainTableEntry(char, char)

// finishing type java.util.Currency
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "CurrencyData");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#mainTable
	field = newType.addNode(JavaDataField.class,"mainTable"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#mainTable

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scCutOverTimes
	field = newType.addNode(JavaDataField.class,"scCutOverTimes"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scCutOverTimes

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scOldCurrencies
	field = newType.addNode(JavaDataField.class,"scOldCurrencies"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scOldCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scNewCurrencies
	field = newType.addNode(JavaDataField.class,"scNewCurrencies"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scNewCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scOldCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"scOldCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scOldCurrenciesDFD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scNewCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"scNewCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scNewCurrenciesDFD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#otherCurrencies
	field = newType.addNode(JavaDataField.class,"otherCurrencies"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#otherCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#otherCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"otherCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#otherCurrenciesDFD


    // starting method java.util.CurrencyData#CurrencyData()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"CurrencyData()");
    method.setSimpleName("CurrencyData");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.CurrencyData#CurrencyData()

// finishing type java.util.CurrencyData
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Date");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Comparable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Comparable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparable 

// ignoring field java.util.Date#gcal 

// ignoring field java.util.Date#jcal 

// ignoring field java.util.Date#fastTime 

// ignoring field java.util.Date#cdate 

// ignoring field java.util.Date#defaultCenturyStart 

// ignoring field java.util.Date#serialVersionUID 

// ignoring field java.util.Date#wtb 

// ignoring field java.util.Date#ttb 


    // starting method java.util.Date#Date()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date()");
    method.setSimpleName("Date");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date()
    // starting method java.util.Date#Date(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(long)");
    method.setSimpleName("Date");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(long)
    // starting method java.util.Date#Date(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(int, int, int)");
    method.setSimpleName("Date");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(int, int, int)
    // starting method java.util.Date#Date(int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(int, int, int, int, int)");
    method.setSimpleName("Date");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(int, int, int, int, int)
    // starting method java.util.Date#Date(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(int, int, int, int, int, int)");
    method.setSimpleName("Date");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(int, int, int, int, int, int)
    // starting method java.util.Date#Date(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(java.lang.String)");
    method.setSimpleName("Date");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(java.lang.String)
    // starting method java.util.Date#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#clone()
    // starting method java.util.Date#UTC(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"UTC(int, int, int, int, int, int)");
    method.setSimpleName("UTC");
    helper.setMethodData(method,131081);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#UTC(int, int, int, int, int, int)
    // starting method java.util.Date#parse(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"parse(java.lang.String)");
    method.setSimpleName("parse");
    helper.setMethodData(method,131081);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#parse(java.lang.String)
    // starting method java.util.Date#getYear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getYear()");
    method.setSimpleName("getYear");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getYear()
    // starting method java.util.Date#setYear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setYear(int)");
    method.setSimpleName("setYear");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setYear(int)
    // starting method java.util.Date#getMonth()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMonth()");
    method.setSimpleName("getMonth");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getMonth()
    // starting method java.util.Date#setMonth(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setMonth(int)");
    method.setSimpleName("setMonth");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setMonth(int)
    // starting method java.util.Date#getDate()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDate()");
    method.setSimpleName("getDate");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getDate()
    // starting method java.util.Date#setDate(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setDate(int)");
    method.setSimpleName("setDate");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setDate(int)
    // starting method java.util.Date#getDay()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDay()");
    method.setSimpleName("getDay");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getDay()
    // starting method java.util.Date#getHours()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getHours()");
    method.setSimpleName("getHours");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getHours()
    // starting method java.util.Date#setHours(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setHours(int)");
    method.setSimpleName("setHours");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setHours(int)
    // starting method java.util.Date#getMinutes()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMinutes()");
    method.setSimpleName("getMinutes");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getMinutes()
    // starting method java.util.Date#setMinutes(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setMinutes(int)");
    method.setSimpleName("setMinutes");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setMinutes(int)
    // starting method java.util.Date#getSeconds()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSeconds()");
    method.setSimpleName("getSeconds");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getSeconds()
    // starting method java.util.Date#setSeconds(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setSeconds(int)");
    method.setSimpleName("setSeconds");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setSeconds(int)
    // starting method java.util.Date#getTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTime()");
    method.setSimpleName("getTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getTime()
    // ignoring method java.util.Date#getTimeImpl()
    // starting method java.util.Date#setTime(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTime(long)");
    method.setSimpleName("setTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setTime(long)
    // starting method java.util.Date#before(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"before(java.util.Date)");
    method.setSimpleName("before");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#before(java.util.Date)
    // starting method java.util.Date#after(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"after(java.util.Date)");
    method.setSimpleName("after");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#after(java.util.Date)
    // starting method java.util.Date#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#equals(java.lang.Object)
    // starting method java.util.Date#getMillisOf(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMillisOf(java.util.Date)");
    method.setSimpleName("getMillisOf");
    helper.setMethodData(method,24);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getMillisOf(java.util.Date)
    // starting method java.util.Date#compareTo(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.util.Date)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#compareTo(java.util.Date)
    // starting method java.util.Date#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#hashCode()
    // starting method java.util.Date#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#toString()
    // ignoring method java.util.Date#convertToAbbr(java.lang.StringBuilder, java.lang.String)
    // starting method java.util.Date#toLocaleString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toLocaleString()");
    method.setSimpleName("toLocaleString");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#toLocaleString()
    // starting method java.util.Date#toGMTString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toGMTString()");
    method.setSimpleName("toGMTString");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#toGMTString()
    // starting method java.util.Date#getTimezoneOffset()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimezoneOffset()");
    method.setSimpleName("getTimezoneOffset");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getTimezoneOffset()
    // ignoring method java.util.Date#getCalendarDate()
    // ignoring method java.util.Date#normalize()
    // ignoring method java.util.Date#normalize(sun.util.calendar.BaseCalendar$Date)
    // ignoring method java.util.Date#getCalendarSystem(int)
    // ignoring method java.util.Date#getCalendarSystem(long)
    // ignoring method java.util.Date#getCalendarSystem(sun.util.calendar.BaseCalendar$Date)
    // ignoring method java.util.Date#getJulianCalendar()
    // ignoring method java.util.Date#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.Date#readObject(java.io.ObjectInputStream)
    // starting method java.util.Date#compareTo(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.lang.Object)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#compareTo(java.lang.Object)

// finishing type java.util.Date
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Dictionary");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Dictionary#Dictionary()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Dictionary()");
    method.setSimpleName("Dictionary");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#Dictionary()
    // starting method java.util.Dictionary#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#size()
    // starting method java.util.Dictionary#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#isEmpty()
    // starting method java.util.Dictionary#keys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keys()");
    method.setSimpleName("keys");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#keys()
    // starting method java.util.Dictionary#elements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elements()");
    method.setSimpleName("elements");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#elements()
    // starting method java.util.Dictionary#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#get(java.lang.Object)
    // starting method java.util.Dictionary#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Dictionary#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#remove(java.lang.Object)

// finishing type java.util.Dictionary
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "DuplicateFormatFlagsException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.DuplicateFormatFlagsException#serialVersionUID 

// ignoring field java.util.DuplicateFormatFlagsException#flags 


    // starting method java.util.DuplicateFormatFlagsException#DuplicateFormatFlagsException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"DuplicateFormatFlagsException(java.lang.String)");
    method.setSimpleName("DuplicateFormatFlagsException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.DuplicateFormatFlagsException#DuplicateFormatFlagsException(java.lang.String)
    // starting method java.util.DuplicateFormatFlagsException#getFlags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFlags()");
    method.setSimpleName("getFlags");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.DuplicateFormatFlagsException#getFlags()
    // starting method java.util.DuplicateFormatFlagsException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.DuplicateFormatFlagsException#getMessage()

// finishing type java.util.DuplicateFormatFlagsException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EmptyStackException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","RuntimeException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.EmptyStackException#EmptyStackException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EmptyStackException()");
    method.setSimpleName("EmptyStackException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EmptyStackException#EmptyStackException()

// finishing type java.util.EmptyStackException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Enumeration");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Enumeration#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Enumeration#hasMoreElements()
    // starting method java.util.Enumeration#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Enumeration#nextElement()

// finishing type java.util.Enumeration
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.EnumMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumMap$EnumMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EntryIterator#this$0


    // ignoring method java.util.EnumMap$EntryIterator#EnumMap$EntryIterator(java.util.EnumMap)
    // starting method java.util.EnumMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#next()
    // starting method java.util.EnumMap$EntryIterator#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Enum");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#getKey()
    // starting method java.util.EnumMap$EntryIterator#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#getValue()
    // starting method java.util.EnumMap$EntryIterator#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#setValue(java.lang.Object)
    // starting method java.util.EnumMap$EntryIterator#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#equals(java.lang.Object)
    // starting method java.util.EnumMap$EntryIterator#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#hashCode()
    // starting method java.util.EnumMap$EntryIterator#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#toString()
    // ignoring method java.util.EnumMap$EntryIterator#checkLastReturnedIndexForEntryUse()
    // starting method java.util.EnumMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#next()
    // starting method java.util.EnumMap$EntryIterator#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#getKey()
    // starting method java.util.EnumMap$EntryIterator#EnumMap$EntryIterator(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$EntryIterator(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#EnumMap$EntryIterator(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EntrySet#this$0


    // ignoring method java.util.EnumMap$EntrySet#EnumMap$EntrySet(java.util.EnumMap)
    // starting method java.util.EnumMap$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#iterator()
    // starting method java.util.EnumMap$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#contains(java.lang.Object)
    // starting method java.util.EnumMap$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#remove(java.lang.Object)
    // starting method java.util.EnumMap$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#size()
    // starting method java.util.EnumMap$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#clear()
    // starting method java.util.EnumMap$EntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#toArray()
    // starting method java.util.EnumMap$EntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#toArray(java.lang.Object[])
    // ignoring method java.util.EnumMap$EntrySet#fillEntryArray(java.lang.Object[])
    // starting method java.util.EnumMap$EntrySet#EnumMap$EntrySet(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$EntrySet(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#EnumMap$EntrySet(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EnumMapIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EnumMapIterator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EnumMapIterator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EnumMapIterator#lastReturnedIndex
	field = newType.addNode(JavaDataField.class,"lastReturnedIndex"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EnumMapIterator#lastReturnedIndex

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EnumMapIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EnumMapIterator#this$0


    // ignoring method java.util.EnumMap$EnumMapIterator#EnumMap$EnumMapIterator(java.util.EnumMap)
    // starting method java.util.EnumMap$EnumMapIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EnumMapIterator#hasNext()
    // starting method java.util.EnumMap$EnumMapIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EnumMapIterator#remove()
    // ignoring method java.util.EnumMap$EnumMapIterator#checkLastReturnedIndex()
    // starting method java.util.EnumMap$EnumMapIterator#EnumMap$EnumMapIterator(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$EnumMapIterator(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$EnumMapIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EnumMapIterator#EnumMap$EnumMapIterator(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$EnumMapIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumMap$EnumMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$KeyIterator#this$0


    // ignoring method java.util.EnumMap$KeyIterator#EnumMap$KeyIterator(java.util.EnumMap)
    // starting method java.util.EnumMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Enum");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeyIterator#next()
    // starting method java.util.EnumMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeyIterator#next()
    // starting method java.util.EnumMap$KeyIterator#EnumMap$KeyIterator(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$KeyIterator(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeyIterator#EnumMap$KeyIterator(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$KeySet#this$0


    // ignoring method java.util.EnumMap$KeySet#EnumMap$KeySet(java.util.EnumMap)
    // starting method java.util.EnumMap$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#iterator()
    // starting method java.util.EnumMap$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#size()
    // starting method java.util.EnumMap$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#contains(java.lang.Object)
    // starting method java.util.EnumMap$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#remove(java.lang.Object)
    // starting method java.util.EnumMap$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#clear()
    // starting method java.util.EnumMap$KeySet#EnumMap$KeySet(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$KeySet(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#EnumMap$KeySet(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumMap$EnumMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$ValueIterator#this$0


    // ignoring method java.util.EnumMap$ValueIterator#EnumMap$ValueIterator(java.util.EnumMap)
    // starting method java.util.EnumMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$ValueIterator#next()
    // starting method java.util.EnumMap$ValueIterator#EnumMap$ValueIterator(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$ValueIterator(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$ValueIterator#EnumMap$ValueIterator(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$Values");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$Values#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$Values#this$0


    // ignoring method java.util.EnumMap$Values#EnumMap$Values(java.util.EnumMap)
    // starting method java.util.EnumMap$Values#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#iterator()
    // starting method java.util.EnumMap$Values#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#size()
    // starting method java.util.EnumMap$Values#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#contains(java.lang.Object)
    // starting method java.util.EnumMap$Values#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#remove(java.lang.Object)
    // starting method java.util.EnumMap$Values#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#clear()
    // starting method java.util.EnumMap$Values#EnumMap$Values(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$Values(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$Values");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#EnumMap$Values(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$Values
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 

// ignoring field java.util.EnumMap#keyType 

// ignoring field java.util.EnumMap#keyUniverse 

// ignoring field java.util.EnumMap#vals 

// ignoring field java.util.EnumMap#size 

// ignoring field java.util.EnumMap#NULL 

// ignoring field java.util.EnumMap#ZERO_LENGTH_ENUM_ARRAY 

// ignoring field java.util.EnumMap#entrySet 

// ignoring field java.util.EnumMap#serialVersionUID 


    // ignoring method java.util.EnumMap#maskNull(java.lang.Object)
    // ignoring method java.util.EnumMap#unmaskNull(java.lang.Object)
    // starting method java.util.EnumMap#EnumMap(java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap(java.lang.Class)");
    method.setSimpleName("EnumMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#EnumMap(java.lang.Class)
    // starting method java.util.EnumMap#EnumMap(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap(java.util.EnumMap)");
    method.setSimpleName("EnumMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#EnumMap(java.util.EnumMap)
    // starting method java.util.EnumMap#EnumMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap(java.util.Map)");
    method.setSimpleName("EnumMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#EnumMap(java.util.Map)
    // starting method java.util.EnumMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#size()
    // starting method java.util.EnumMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#containsValue(java.lang.Object)
    // starting method java.util.EnumMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#containsKey(java.lang.Object)
    // ignoring method java.util.EnumMap#containsMapping(java.lang.Object, java.lang.Object)
    // starting method java.util.EnumMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#get(java.lang.Object)
    // starting method java.util.EnumMap#put(java.lang.Enum, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Enum, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#put(java.lang.Enum, java.lang.Object)
    // starting method java.util.EnumMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#remove(java.lang.Object)
    // ignoring method java.util.EnumMap#removeMapping(java.lang.Object, java.lang.Object)
    // ignoring method java.util.EnumMap#isValidKey(java.lang.Object)
    // starting method java.util.EnumMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#putAll(java.util.Map)
    // starting method java.util.EnumMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#clear()
    // starting method java.util.EnumMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#keySet()
    // starting method java.util.EnumMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#values()
    // starting method java.util.EnumMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#entrySet()
    // starting method java.util.EnumMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#equals(java.lang.Object)
    // starting method java.util.EnumMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#clone()
    // ignoring method java.util.EnumMap#typeCheck(java.lang.Enum)
    // ignoring method java.util.EnumMap#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.EnumMap#readObject(java.io.ObjectInputStream)
    // starting method java.util.EnumMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","CloneNotSupportedException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.CloneNotSupportedException
    
    // finishing method java.util.EnumMap#clone()
    // starting method java.util.EnumMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.EnumMap#access$200(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.EnumMap)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$200(java.util.EnumMap)
    // starting method java.util.EnumMap#access$500(java.util.EnumMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$500(java.util.EnumMap, java.lang.Object)");
    method.setSimpleName("access$500");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$500(java.util.EnumMap, java.lang.Object)
    // starting method java.util.EnumMap#access$600(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$600(java.util.EnumMap)");
    method.setSimpleName("access$600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$600(java.util.EnumMap)
    // starting method java.util.EnumMap#access$210(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$210(java.util.EnumMap)");
    method.setSimpleName("access$210");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$210(java.util.EnumMap)
    // starting method java.util.EnumMap#access$900(java.util.EnumMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$900(java.util.EnumMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$900");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$900(java.util.EnumMap, java.lang.Object, java.lang.Object)
    // starting method java.util.EnumMap#access$1000(java.util.EnumMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1000(java.util.EnumMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$1000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$1000(java.util.EnumMap, java.lang.Object, java.lang.Object)
    // starting method java.util.EnumMap#access$1100(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1100(java.util.EnumMap)");
    method.setSimpleName("access$1100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$1100(java.util.EnumMap)
    // starting method java.util.EnumMap#access$1200(java.util.EnumMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1200(java.util.EnumMap, java.lang.Object)");
    method.setSimpleName("access$1200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$1200(java.util.EnumMap, java.lang.Object)
    // starting method java.util.EnumMap#access$1400()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1400()");
    method.setSimpleName("access$1400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$1400()

// finishing type java.util.EnumMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumSet$SerializationProxy");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.EnumSet$SerializationProxy#elementType 

// ignoring field java.util.EnumSet$SerializationProxy#elements 

// ignoring field java.util.EnumSet$SerializationProxy#serialVersionUID 


    // starting method java.util.EnumSet$SerializationProxy#EnumSet$SerializationProxy(java.util.EnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumSet$SerializationProxy(java.util.EnumSet)");
    method.setSimpleName("EnumSet$SerializationProxy");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet$SerializationProxy#EnumSet$SerializationProxy(java.util.EnumSet)
    // ignoring method java.util.EnumSet$SerializationProxy#readResolve()

// finishing type java.util.EnumSet$SerializationProxy
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumSet#elementType
	field = newType.addNode(JavaDataField.class,"elementType"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.EnumSet#elementType

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumSet#universe
	field = newType.addNode(JavaDataField.class,"universe"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.EnumSet#universe

// ignoring field java.util.EnumSet#ZERO_LENGTH_ENUM_ARRAY 


    // starting method java.util.EnumSet#EnumSet(java.lang.Class, java.lang.Enum[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumSet(java.lang.Class, java.lang.Enum[])");
    method.setSimpleName("EnumSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#EnumSet(java.lang.Class, java.lang.Enum[])
    // starting method java.util.EnumSet#noneOf(java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"noneOf(java.lang.Class)");
    method.setSimpleName("noneOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#noneOf(java.lang.Class)
    // starting method java.util.EnumSet#allOf(java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"allOf(java.lang.Class)");
    method.setSimpleName("allOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#allOf(java.lang.Class)
    // starting method java.util.EnumSet#addAll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll()");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1024);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#addAll()
    // starting method java.util.EnumSet#copyOf(java.util.EnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"copyOf(java.util.EnumSet)");
    method.setSimpleName("copyOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#copyOf(java.util.EnumSet)
    // starting method java.util.EnumSet#copyOf(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"copyOf(java.util.Collection)");
    method.setSimpleName("copyOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#copyOf(java.util.Collection)
    // starting method java.util.EnumSet#complementOf(java.util.EnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complementOf(java.util.EnumSet)");
    method.setSimpleName("complementOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#complementOf(java.util.EnumSet)
    // starting method java.util.EnumSet#of(java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum[])");
    method.setSimpleName("of");
    helper.setMethodData(method,137);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum[])
    // starting method java.util.EnumSet#range(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"range(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("range");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#range(java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#addRange(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addRange(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("addRange");
    helper.setMethodData(method,1024);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#addRange(java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#clone()
    // starting method java.util.EnumSet#complement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complement()");
    method.setSimpleName("complement");
    helper.setMethodData(method,1024);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#complement()
    // starting method java.util.EnumSet#typeCheck(java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"typeCheck(java.lang.Enum)");
    method.setSimpleName("typeCheck");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#typeCheck(java.lang.Enum)
    // starting method java.util.EnumSet#writeReplace()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"writeReplace()");
    method.setSimpleName("writeReplace");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#writeReplace()
    // starting method java.util.EnumSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","CloneNotSupportedException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.CloneNotSupportedException
    
    // finishing method java.util.EnumSet#clone()
    // starting method java.util.EnumSet#access$000()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000()");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#access$000()

// finishing type java.util.EnumSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "EventListener");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.EventListener
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EventListenerProxy");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface EventListener 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EventListener");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface EventListener 

// ignoring field java.util.EventListenerProxy#listener 


    // starting method java.util.EventListenerProxy#EventListenerProxy(java.util.EventListener)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EventListenerProxy(java.util.EventListener)");
    method.setSimpleName("EventListenerProxy");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventListenerProxy#EventListenerProxy(java.util.EventListener)
    // starting method java.util.EventListenerProxy#getListener()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getListener()");
    method.setSimpleName("getListener");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EventListener");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventListenerProxy#getListener()

// finishing type java.util.EventListenerProxy
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EventObject");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.EventObject#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EventObject#source
	field = newType.addNode(JavaDataField.class,"source"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 132, isArray, arrayDimensions);
    // finishing field java.util.EventObject#source


    // starting method java.util.EventObject#EventObject(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EventObject(java.lang.Object)");
    method.setSimpleName("EventObject");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventObject#EventObject(java.lang.Object)
    // starting method java.util.EventObject#getSource()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSource()");
    method.setSimpleName("getSource");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventObject#getSource()
    // starting method java.util.EventObject#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventObject#toString()

// finishing type java.util.EventObject
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "FormatFlagsConversionMismatchException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.FormatFlagsConversionMismatchException#serialVersionUID 

// ignoring field java.util.FormatFlagsConversionMismatchException#f 

// ignoring field java.util.FormatFlagsConversionMismatchException#c 


    // starting method java.util.FormatFlagsConversionMismatchException#FormatFlagsConversionMismatchException(java.lang.String, char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"FormatFlagsConversionMismatchException(java.lang.String, char)");
    method.setSimpleName("FormatFlagsConversionMismatchException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatFlagsConversionMismatchException#FormatFlagsConversionMismatchException(java.lang.String, char)
    // starting method java.util.FormatFlagsConversionMismatchException#getFlags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFlags()");
    method.setSimpleName("getFlags");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatFlagsConversionMismatchException#getFlags()
    // starting method java.util.FormatFlagsConversionMismatchException#getConversion()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getConversion()");
    method.setSimpleName("getConversion");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "char");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatFlagsConversionMismatchException#getConversion()
    // starting method java.util.FormatFlagsConversionMismatchException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatFlagsConversionMismatchException#getMessage()

// finishing type java.util.FormatFlagsConversionMismatchException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Formattable");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Formattable#formatTo(java.util.Formatter, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"formatTo(java.util.Formatter, int, int, int)");
    method.setSimpleName("formatTo");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formattable#formatTo(java.util.Formatter, int, int, int)

// finishing type java.util.Formattable
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "FormattableFlags");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.FormattableFlags#LEFT_JUSTIFY
	field = newType.addNode(JavaDataField.class,"LEFT_JUSTIFY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.FormattableFlags#LEFT_JUSTIFY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.FormattableFlags#UPPERCASE
	field = newType.addNode(JavaDataField.class,"UPPERCASE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.FormattableFlags#UPPERCASE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.FormattableFlags#ALTERNATE
	field = newType.addNode(JavaDataField.class,"ALTERNATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.FormattableFlags#ALTERNATE


    // ignoring method java.util.FormattableFlags#FormattableFlags()

// finishing type java.util.FormattableFlags
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeEnum.class,"java.util", "Formatter$BigDecimalLayoutForm");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Enum");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$BigDecimalLayoutForm#SCIENTIFIC
	field = newType.addNode(JavaDataField.class,"SCIENTIFIC"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$BigDecimalLayoutForm");
    helper.insertFieldData(field, fieldType, 16409, isArray, arrayDimensions);
    // finishing field java.util.Formatter$BigDecimalLayoutForm#SCIENTIFIC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$BigDecimalLayoutForm#DECIMAL_FLOAT
	field = newType.addNode(JavaDataField.class,"DECIMAL_FLOAT"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$BigDecimalLayoutForm");
    helper.insertFieldData(field, fieldType, 16409, isArray, arrayDimensions);
    // finishing field java.util.Formatter$BigDecimalLayoutForm#DECIMAL_FLOAT

// ignoring field java.util.Formatter$BigDecimalLayoutForm#$VALUES 


    // starting method java.util.Formatter$BigDecimalLayoutForm#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$BigDecimalLayoutForm#values()
    // starting method java.util.Formatter$BigDecimalLayoutForm#valueOf(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"valueOf(java.lang.String)");
    method.setSimpleName("valueOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$BigDecimalLayoutForm");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$BigDecimalLayoutForm#valueOf(java.lang.String)
    // ignoring method java.util.Formatter$BigDecimalLayoutForm#Formatter$BigDecimalLayoutForm(java.lang.String, int)

// finishing type java.util.Formatter$BigDecimalLayoutForm
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$Conversion");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#DECIMAL_INTEGER
	field = newType.addNode(JavaDataField.class,"DECIMAL_INTEGER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#DECIMAL_INTEGER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#OCTAL_INTEGER
	field = newType.addNode(JavaDataField.class,"OCTAL_INTEGER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#OCTAL_INTEGER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HEXADECIMAL_INTEGER
	field = newType.addNode(JavaDataField.class,"HEXADECIMAL_INTEGER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HEXADECIMAL_INTEGER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HEXADECIMAL_INTEGER_UPPER
	field = newType.addNode(JavaDataField.class,"HEXADECIMAL_INTEGER_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HEXADECIMAL_INTEGER_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#SCIENTIFIC
	field = newType.addNode(JavaDataField.class,"SCIENTIFIC"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#SCIENTIFIC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#SCIENTIFIC_UPPER
	field = newType.addNode(JavaDataField.class,"SCIENTIFIC_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#SCIENTIFIC_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#GENERAL
	field = newType.addNode(JavaDataField.class,"GENERAL"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#GENERAL

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#GENERAL_UPPER
	field = newType.addNode(JavaDataField.class,"GENERAL_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#GENERAL_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#DECIMAL_FLOAT
	field = newType.addNode(JavaDataField.class,"DECIMAL_FLOAT"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#DECIMAL_FLOAT

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HEXADECIMAL_FLOAT
	field = newType.addNode(JavaDataField.class,"HEXADECIMAL_FLOAT"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HEXADECIMAL_FLOAT

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HEXADECIMAL_FLOAT_UPPER
	field = newType.addNode(JavaDataField.class,"HEXADECIMAL_FLOAT_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HEXADECIMAL_FLOAT_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#CHARACTER
	field = newType.addNode(JavaDataField.class,"CHARACTER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#CHARACTER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#CHARACTER_UPPER
	field = newType.addNode(JavaDataField.class,"CHARACTER_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#CHARACTER_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#DATE_TIME
	field = newType.addNode(JavaDataField.class,"DATE_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#DATE_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#DATE_TIME_UPPER
	field = newType.addNode(JavaDataField.class,"DATE_TIME_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#DATE_TIME_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#BOOLEAN
	field = newType.addNode(JavaDataField.class,"BOOLEAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#BOOLEAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#BOOLEAN_UPPER
	field = newType.addNode(JavaDataField.class,"BOOLEAN_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#BOOLEAN_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#STRING
	field = newType.addNode(JavaDataField.class,"STRING"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#STRING

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#STRING_UPPER
	field = newType.addNode(JavaDataField.class,"STRING_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#STRING_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HASHCODE
	field = newType.addNode(JavaDataField.class,"HASHCODE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HASHCODE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HASHCODE_UPPER
	field = newType.addNode(JavaDataField.class,"HASHCODE_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HASHCODE_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#LINE_SEPARATOR
	field = newType.addNode(JavaDataField.class,"LINE_SEPARATOR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#LINE_SEPARATOR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#PERCENT_SIGN
	field = newType.addNode(JavaDataField.class,"PERCENT_SIGN"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#PERCENT_SIGN


    // ignoring method java.util.Formatter$Conversion#Formatter$Conversion()
    // starting method java.util.Formatter$Conversion#isValid(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isValid(char)");
    method.setSimpleName("isValid");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isValid(char)
    // starting method java.util.Formatter$Conversion#isGeneral(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isGeneral(char)");
    method.setSimpleName("isGeneral");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isGeneral(char)
    // starting method java.util.Formatter$Conversion#isInteger(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isInteger(char)");
    method.setSimpleName("isInteger");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isInteger(char)
    // starting method java.util.Formatter$Conversion#isFloat(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isFloat(char)");
    method.setSimpleName("isFloat");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isFloat(char)
    // starting method java.util.Formatter$Conversion#isText(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isText(char)");
    method.setSimpleName("isText");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isText(char)

// finishing type java.util.Formatter$Conversion
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$DateTime");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#HOUR_OF_DAY_0
	field = newType.addNode(JavaDataField.class,"HOUR_OF_DAY_0"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#HOUR_OF_DAY_0

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#HOUR_0
	field = newType.addNode(JavaDataField.class,"HOUR_0"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#HOUR_0

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#HOUR_OF_DAY
	field = newType.addNode(JavaDataField.class,"HOUR_OF_DAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#HOUR_OF_DAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#HOUR
	field = newType.addNode(JavaDataField.class,"HOUR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#HOUR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#MINUTE
	field = newType.addNode(JavaDataField.class,"MINUTE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#MINUTE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NANOSECOND
	field = newType.addNode(JavaDataField.class,"NANOSECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NANOSECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#MILLISECOND
	field = newType.addNode(JavaDataField.class,"MILLISECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#MILLISECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#MILLISECOND_SINCE_EPOCH
	field = newType.addNode(JavaDataField.class,"MILLISECOND_SINCE_EPOCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#MILLISECOND_SINCE_EPOCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#AM_PM
	field = newType.addNode(JavaDataField.class,"AM_PM"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#AM_PM

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#SECONDS_SINCE_EPOCH
	field = newType.addNode(JavaDataField.class,"SECONDS_SINCE_EPOCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#SECONDS_SINCE_EPOCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#SECOND
	field = newType.addNode(JavaDataField.class,"SECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#SECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#TIME
	field = newType.addNode(JavaDataField.class,"TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#ZONE_NUMERIC
	field = newType.addNode(JavaDataField.class,"ZONE_NUMERIC"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#ZONE_NUMERIC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#ZONE
	field = newType.addNode(JavaDataField.class,"ZONE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#ZONE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_DAY_ABBREV
	field = newType.addNode(JavaDataField.class,"NAME_OF_DAY_ABBREV"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_DAY_ABBREV

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_DAY
	field = newType.addNode(JavaDataField.class,"NAME_OF_DAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_DAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_MONTH_ABBREV
	field = newType.addNode(JavaDataField.class,"NAME_OF_MONTH_ABBREV"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_MONTH_ABBREV

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_MONTH
	field = newType.addNode(JavaDataField.class,"NAME_OF_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#CENTURY
	field = newType.addNode(JavaDataField.class,"CENTURY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#CENTURY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DAY_OF_MONTH_0
	field = newType.addNode(JavaDataField.class,"DAY_OF_MONTH_0"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DAY_OF_MONTH_0

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DAY_OF_MONTH
	field = newType.addNode(JavaDataField.class,"DAY_OF_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DAY_OF_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_MONTH_ABBREV_X
	field = newType.addNode(JavaDataField.class,"NAME_OF_MONTH_ABBREV_X"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_MONTH_ABBREV_X

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DAY_OF_YEAR
	field = newType.addNode(JavaDataField.class,"DAY_OF_YEAR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DAY_OF_YEAR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#MONTH
	field = newType.addNode(JavaDataField.class,"MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#YEAR_2
	field = newType.addNode(JavaDataField.class,"YEAR_2"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#YEAR_2

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#YEAR_4
	field = newType.addNode(JavaDataField.class,"YEAR_4"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#YEAR_4

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#TIME_12_HOUR
	field = newType.addNode(JavaDataField.class,"TIME_12_HOUR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#TIME_12_HOUR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#TIME_24_HOUR
	field = newType.addNode(JavaDataField.class,"TIME_24_HOUR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#TIME_24_HOUR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DATE_TIME
	field = newType.addNode(JavaDataField.class,"DATE_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DATE_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DATE
	field = newType.addNode(JavaDataField.class,"DATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DATE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#ISO_STANDARD_DATE
	field = newType.addNode(JavaDataField.class,"ISO_STANDARD_DATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#ISO_STANDARD_DATE


    // ignoring method java.util.Formatter$DateTime#Formatter$DateTime()
    // starting method java.util.Formatter$DateTime#isValid(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isValid(char)");
    method.setSimpleName("isValid");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$DateTime#isValid(char)

// finishing type java.util.Formatter$DateTime
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FixedString");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Formatter$FormatString 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Formatter$FormatString");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Formatter$FormatString 

// ignoring field java.util.Formatter$FixedString#s 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$FixedString#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Formatter$FixedString#this$0


    // starting method java.util.Formatter$FixedString#Formatter$FixedString(java.util.Formatter, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter$FixedString(java.util.Formatter, java.lang.String)");
    method.setSimpleName("Formatter$FixedString");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FixedString#Formatter$FixedString(java.util.Formatter, java.lang.String)
    // starting method java.util.Formatter$FixedString#index()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"index()");
    method.setSimpleName("index");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FixedString#index()
    // starting method java.util.Formatter$FixedString#print(java.lang.Object, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"print(java.lang.Object, java.util.Locale)");
    method.setSimpleName("print");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Formatter$FixedString#print(java.lang.Object, java.util.Locale)
    // starting method java.util.Formatter$FixedString#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FixedString#toString()

// finishing type java.util.Formatter$FixedString
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$Flags");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Formatter$Flags#flags 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#NONE
	field = newType.addNode(JavaDataField.class,"NONE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#NONE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#LEFT_JUSTIFY
	field = newType.addNode(JavaDataField.class,"LEFT_JUSTIFY"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#LEFT_JUSTIFY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#UPPERCASE
	field = newType.addNode(JavaDataField.class,"UPPERCASE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#UPPERCASE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#ALTERNATE
	field = newType.addNode(JavaDataField.class,"ALTERNATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#ALTERNATE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#PLUS
	field = newType.addNode(JavaDataField.class,"PLUS"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#PLUS

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#LEADING_SPACE
	field = newType.addNode(JavaDataField.class,"LEADING_SPACE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#LEADING_SPACE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#ZERO_PAD
	field = newType.addNode(JavaDataField.class,"ZERO_PAD"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#ZERO_PAD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#GROUP
	field = newType.addNode(JavaDataField.class,"GROUP"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#GROUP

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#PARENTHESES
	field = newType.addNode(JavaDataField.class,"PARENTHESES"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#PARENTHESES

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#PREVIOUS
	field = newType.addNode(JavaDataField.class,"PREVIOUS"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#PREVIOUS


    // ignoring method java.util.Formatter$Flags#Formatter$Flags(int)
    // starting method java.util.Formatter$Flags#valueOf()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"valueOf()");
    method.setSimpleName("valueOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#valueOf()
    // starting method java.util.Formatter$Flags#contains(java.util.Formatter$Flags)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.util.Formatter$Flags)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#contains(java.util.Formatter$Flags)
    // starting method java.util.Formatter$Flags#dup()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"dup()");
    method.setSimpleName("dup");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#dup()
    // ignoring method java.util.Formatter$Flags#add(java.util.Formatter$Flags)
    // starting method java.util.Formatter$Flags#remove(java.util.Formatter$Flags)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.util.Formatter$Flags)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#remove(java.util.Formatter$Flags)
    // starting method java.util.Formatter$Flags#parse(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"parse(java.lang.String)");
    method.setSimpleName("parse");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#parse(java.lang.String)
    // ignoring method java.util.Formatter$Flags#parse(char)
    // starting method java.util.Formatter$Flags#toString(java.util.Formatter$Flags)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(java.util.Formatter$Flags)");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#toString(java.util.Formatter$Flags)
    // starting method java.util.Formatter$Flags#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#toString()
    // starting method java.util.Formatter$Flags#access$100(java.util.Formatter$Flags, java.util.Formatter$Flags)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.Formatter$Flags, java.util.Formatter$Flags)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#access$100(java.util.Formatter$Flags, java.util.Formatter$Flags)

// finishing type java.util.Formatter$Flags
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FormatSpecifier$BigDecimalLayout");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Formatter$FormatSpecifier$BigDecimalLayout#mant 

// ignoring field java.util.Formatter$FormatSpecifier$BigDecimalLayout#exp 

// ignoring field java.util.Formatter$FormatSpecifier$BigDecimalLayout#dot 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$FormatSpecifier$BigDecimalLayout#this$1
	field = newType.addNode(JavaDataField.class,"this$1"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$FormatSpecifier");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Formatter$FormatSpecifier$BigDecimalLayout#this$1


    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#Formatter$FormatSpecifier$BigDecimalLayout(java.util.Formatter$FormatSpecifier, java.math.BigInteger, int, java.util.Formatter$BigDecimalLayoutForm)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter$FormatSpecifier$BigDecimalLayout(java.util.Formatter$FormatSpecifier, java.math.BigInteger, int, java.util.Formatter$BigDecimalLayoutForm)");
    method.setSimpleName("Formatter$FormatSpecifier$BigDecimalLayout");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#Formatter$FormatSpecifier$BigDecimalLayout(java.util.Formatter$FormatSpecifier, java.math.BigInteger, int, java.util.Formatter$BigDecimalLayoutForm)
    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#hasDot()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasDot()");
    method.setSimpleName("hasDot");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#hasDot()
    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#layoutChars()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"layoutChars()");
    method.setSimpleName("layoutChars");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#layoutChars()
    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#mantissa()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"mantissa()");
    method.setSimpleName("mantissa");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#mantissa()
    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#exponent()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"exponent()");
    method.setSimpleName("exponent");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#exponent()
    // ignoring method java.util.Formatter$FormatSpecifier$BigDecimalLayout#toCharArray(java.lang.StringBuilder)
    // ignoring method java.util.Formatter$FormatSpecifier$BigDecimalLayout#layout(java.math.BigInteger, int, java.util.Formatter$BigDecimalLayoutForm)

// finishing type java.util.Formatter$FormatSpecifier$BigDecimalLayout
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FormatSpecifier");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Formatter$FormatString 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Formatter$FormatString");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Formatter$FormatString 

// ignoring field java.util.Formatter$FormatSpecifier#index 

// ignoring field java.util.Formatter$FormatSpecifier#f 

// ignoring field java.util.Formatter$FormatSpecifier#width 

// ignoring field java.util.Formatter$FormatSpecifier#precision 

// ignoring field java.util.Formatter$FormatSpecifier#dt 

// ignoring field java.util.Formatter$FormatSpecifier#c 

// ignoring field java.util.Formatter$FormatSpecifier#formatter 

// ignoring field java.util.Formatter$FormatSpecifier#ls 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$FormatSpecifier#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.Formatter$FormatSpecifier#$assertionsDisabled

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$FormatSpecifier#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Formatter$FormatSpecifier#this$0


    // ignoring method java.util.Formatter$FormatSpecifier#index(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#index()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"index()");
    method.setSimpleName("index");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#index()
    // ignoring method java.util.Formatter$FormatSpecifier#flags(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#flags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"flags()");
    method.setSimpleName("flags");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#flags()
    // ignoring method java.util.Formatter$FormatSpecifier#width(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#width()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"width()");
    method.setSimpleName("width");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#width()
    // ignoring method java.util.Formatter$FormatSpecifier#precision(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#precision()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"precision()");
    method.setSimpleName("precision");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#precision()
    // ignoring method java.util.Formatter$FormatSpecifier#conversion(java.lang.String)
    // ignoring method java.util.Formatter$FormatSpecifier#conversion()
    // starting method java.util.Formatter$FormatSpecifier#Formatter$FormatSpecifier(java.util.Formatter, java.util.Formatter, java.lang.String[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter$FormatSpecifier(java.util.Formatter, java.util.Formatter, java.lang.String[])");
    method.setSimpleName("Formatter$FormatSpecifier");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#Formatter$FormatSpecifier(java.util.Formatter, java.util.Formatter, java.lang.String[])
    // starting method java.util.Formatter$FormatSpecifier#print(java.lang.Object, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"print(java.lang.Object, java.util.Locale)");
    method.setSimpleName("print");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Formatter$FormatSpecifier#print(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printInteger(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printFloat(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printDateTime(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printCharacter(java.lang.Object)
    // ignoring method java.util.Formatter$FormatSpecifier#printString(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printBoolean(java.lang.Object)
    // ignoring method java.util.Formatter$FormatSpecifier#printHashCode(java.lang.Object)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.lang.String)
    // ignoring method java.util.Formatter$FormatSpecifier#justify(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#toString()
    // ignoring method java.util.Formatter$FormatSpecifier#checkGeneral()
    // ignoring method java.util.Formatter$FormatSpecifier#checkDateTime()
    // ignoring method java.util.Formatter$FormatSpecifier#checkCharacter()
    // ignoring method java.util.Formatter$FormatSpecifier#checkInteger()
    // ignoring method java.util.Formatter$FormatSpecifier#checkBadFlags(java.util.Formatter$Flags[])
    // ignoring method java.util.Formatter$FormatSpecifier#checkFloat()
    // ignoring method java.util.Formatter$FormatSpecifier#checkNumeric()
    // ignoring method java.util.Formatter$FormatSpecifier#checkText()
    // ignoring method java.util.Formatter$FormatSpecifier#print(byte, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(short, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(int, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(long, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#leadingSign(java.lang.StringBuilder, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#trailingSign(java.lang.StringBuilder, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.math.BigInteger, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(float, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(double, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.lang.StringBuilder, double, java.util.Locale, java.util.Formatter$Flags, char, int, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#mantissa(char[], int)
    // ignoring method java.util.Formatter$FormatSpecifier#exponent(char[], int)
    // ignoring method java.util.Formatter$FormatSpecifier#addZeros(char[], int)
    // ignoring method java.util.Formatter$FormatSpecifier#hexDouble(double, int)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.math.BigDecimal, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.lang.StringBuilder, java.math.BigDecimal, java.util.Locale, java.util.Formatter$Flags, char, int, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#adjustWidth(int, java.util.Formatter$Flags, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#addDot(char[])
    // ignoring method java.util.Formatter$FormatSpecifier#trailingZeros(char[], int)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.util.Calendar, char, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.lang.StringBuilder, java.util.Calendar, char, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#failMismatch(java.util.Formatter$Flags, char)
    // ignoring method java.util.Formatter$FormatSpecifier#failConversion(char, java.lang.Object)
    // ignoring method java.util.Formatter$FormatSpecifier#getZero(java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#localizedMagnitude(java.lang.StringBuilder, long, java.util.Formatter$Flags, int, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#localizedMagnitude(java.lang.StringBuilder, char[], java.util.Formatter$Flags, int, java.util.Locale)

// finishing type java.util.Formatter$FormatSpecifier
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Formatter$FormatString");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Formatter$FormatString#index()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"index()");
    method.setSimpleName("index");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatString#index()
    // starting method java.util.Formatter$FormatString#print(java.lang.Object, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"print(java.lang.Object, java.util.Locale)");
    method.setSimpleName("print");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Formatter$FormatString#print(java.lang.Object, java.util.Locale)
    // starting method java.util.Formatter$FormatString#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatString#toString()

// finishing type java.util.Formatter$FormatString
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Closeable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Closeable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Closeable 
    // starting interface Flushable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Flushable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Flushable 

// ignoring field java.util.Formatter#a 

// ignoring field java.util.Formatter#l 

// ignoring field java.util.Formatter#lastException 

// ignoring field java.util.Formatter#zero 

// ignoring field java.util.Formatter#scaleUp 

// ignoring field java.util.Formatter#MAX_FD_CHARS 

// ignoring field java.util.Formatter#formatSpecifier 

// ignoring field java.util.Formatter#fsPattern 


    // ignoring method java.util.Formatter#init(java.lang.Appendable, java.util.Locale)
    // starting method java.util.Formatter#Formatter()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter()");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter()
    // starting method java.util.Formatter#Formatter(java.lang.Appendable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.Appendable)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.lang.Appendable)
    // starting method java.util.Formatter#Formatter(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.util.Locale)
    // starting method java.util.Formatter#Formatter(java.lang.Appendable, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.Appendable, java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.lang.Appendable, java.util.Locale)
    // starting method java.util.Formatter#Formatter(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.String)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
    
    // finishing method java.util.Formatter#Formatter(java.lang.String)
    // starting method java.util.Formatter#Formatter(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.String, java.lang.String)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.lang.String, java.lang.String)
    // starting method java.util.Formatter#Formatter(java.lang.String, java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.String, java.lang.String, java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.lang.String, java.lang.String, java.util.Locale)
    // starting method java.util.Formatter#Formatter(java.io.File)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.File)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
    
    // finishing method java.util.Formatter#Formatter(java.io.File)
    // starting method java.util.Formatter#Formatter(java.io.File, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.File, java.lang.String)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.io.File, java.lang.String)
    // starting method java.util.Formatter#Formatter(java.io.File, java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.File, java.lang.String, java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.io.File, java.lang.String, java.util.Locale)
    // starting method java.util.Formatter#Formatter(java.io.PrintStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.PrintStream)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.io.PrintStream)
    // starting method java.util.Formatter#Formatter(java.io.OutputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.OutputStream)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.io.OutputStream)
    // starting method java.util.Formatter#Formatter(java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.OutputStream, java.lang.String)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.io.OutputStream, java.lang.String)
    // starting method java.util.Formatter#Formatter(java.io.OutputStream, java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.OutputStream, java.lang.String, java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.io.OutputStream, java.lang.String, java.util.Locale)
    // ignoring method java.util.Formatter#setZero()
    // starting method java.util.Formatter#locale()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"locale()");
    method.setSimpleName("locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#locale()
    // starting method java.util.Formatter#out()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"out()");
    method.setSimpleName("out");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Appendable");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#out()
    // starting method java.util.Formatter#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#toString()
    // starting method java.util.Formatter#flush()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"flush()");
    method.setSimpleName("flush");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#flush()
    // starting method java.util.Formatter#close()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"close()");
    method.setSimpleName("close");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#close()
    // ignoring method java.util.Formatter#ensureOpen()
    // starting method java.util.Formatter#ioException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"ioException()");
    method.setSimpleName("ioException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#ioException()
    // starting method java.util.Formatter#format(java.lang.String, java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"format(java.lang.String, java.lang.Object[])");
    method.setSimpleName("format");
    helper.setMethodData(method,129);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#format(java.lang.String, java.lang.Object[])
    // starting method java.util.Formatter#format(java.util.Locale, java.lang.String, java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"format(java.util.Locale, java.lang.String, java.lang.Object[])");
    method.setSimpleName("format");
    helper.setMethodData(method,129);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#format(java.util.Locale, java.lang.String, java.lang.Object[])
    // ignoring method java.util.Formatter#parse(java.lang.String)
    // ignoring method java.util.Formatter#checkText(java.lang.String)
    // starting method java.util.Formatter#access$000(java.util.Formatter)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.Formatter)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Appendable");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#access$000(java.util.Formatter)
    // starting method java.util.Formatter#access$202(double)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$202(double)");
    method.setSimpleName("access$202");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#access$202(double)
    // starting method java.util.Formatter#access$200()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200()");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#access$200()
    // starting method java.util.Formatter#access$300(java.util.Formatter)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.util.Formatter)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "char");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#access$300(java.util.Formatter)

// finishing type java.util.Formatter
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "FormatterClosedException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","IllegalStateException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.FormatterClosedException#serialVersionUID 


    // starting method java.util.FormatterClosedException#FormatterClosedException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"FormatterClosedException()");
    method.setSimpleName("FormatterClosedException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatterClosedException#FormatterClosedException()

// finishing type java.util.FormatterClosedException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "GregorianCalendar");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Calendar");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#BC
	field = newType.addNode(JavaDataField.class,"BC"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#BC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#BCE
	field = newType.addNode(JavaDataField.class,"BCE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#BCE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#AD
	field = newType.addNode(JavaDataField.class,"AD"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#AD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#CE
	field = newType.addNode(JavaDataField.class,"CE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#CE

// ignoring field java.util.GregorianCalendar#EPOCH_OFFSET 

// ignoring field java.util.GregorianCalendar#EPOCH_YEAR 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#MONTH_LENGTH
	field = newType.addNode(JavaDataField.class,"MONTH_LENGTH"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#MONTH_LENGTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#LEAP_MONTH_LENGTH
	field = newType.addNode(JavaDataField.class,"LEAP_MONTH_LENGTH"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#LEAP_MONTH_LENGTH

// ignoring field java.util.GregorianCalendar#ONE_SECOND 

// ignoring field java.util.GregorianCalendar#ONE_MINUTE 

// ignoring field java.util.GregorianCalendar#ONE_HOUR 

// ignoring field java.util.GregorianCalendar#ONE_DAY 

// ignoring field java.util.GregorianCalendar#ONE_WEEK 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#MIN_VALUES
	field = newType.addNode(JavaDataField.class,"MIN_VALUES"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#MIN_VALUES

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#LEAST_MAX_VALUES
	field = newType.addNode(JavaDataField.class,"LEAST_MAX_VALUES"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#LEAST_MAX_VALUES

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#MAX_VALUES
	field = newType.addNode(JavaDataField.class,"MAX_VALUES"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#MAX_VALUES

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#serialVersionUID

// ignoring field java.util.GregorianCalendar#gcal 

// ignoring field java.util.GregorianCalendar#jcal 

// ignoring field java.util.GregorianCalendar#jeras 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#DEFAULT_GREGORIAN_CUTOVER
	field = newType.addNode(JavaDataField.class,"DEFAULT_GREGORIAN_CUTOVER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#DEFAULT_GREGORIAN_CUTOVER

// ignoring field java.util.GregorianCalendar#gregorianCutover 

// ignoring field java.util.GregorianCalendar#gregorianCutoverDate 

// ignoring field java.util.GregorianCalendar#gregorianCutoverYear 

// ignoring field java.util.GregorianCalendar#gregorianCutoverYearJulian 

// ignoring field java.util.GregorianCalendar#gdate 

// ignoring field java.util.GregorianCalendar#cdate 

// ignoring field java.util.GregorianCalendar#calsys 

// ignoring field java.util.GregorianCalendar#zoneOffsets 

// ignoring field java.util.GregorianCalendar#originalFields 

// ignoring field java.util.GregorianCalendar#cachedFixedDate 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#$assertionsDisabled


    // starting method java.util.GregorianCalendar#GregorianCalendar()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar()");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar()
    // starting method java.util.GregorianCalendar#GregorianCalendar(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(java.util.TimeZone)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(java.util.TimeZone)
    // starting method java.util.GregorianCalendar#GregorianCalendar(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(java.util.Locale)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(java.util.Locale)
    // starting method java.util.GregorianCalendar#GregorianCalendar(java.util.TimeZone, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(java.util.TimeZone, java.util.Locale)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(java.util.TimeZone, java.util.Locale)
    // starting method java.util.GregorianCalendar#GregorianCalendar(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(int, int, int)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(int, int, int)
    // starting method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(int, int, int, int, int)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int)
    // starting method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(int, int, int, int, int, int)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int, int)
    // starting method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(int, int, int, int, int, int, int)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int, int, int)
    // starting method java.util.GregorianCalendar#setGregorianChange(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setGregorianChange(java.util.Date)");
    method.setSimpleName("setGregorianChange");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#setGregorianChange(java.util.Date)
    // ignoring method java.util.GregorianCalendar#setGregorianChange(long)
    // starting method java.util.GregorianCalendar#getGregorianChange()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getGregorianChange()");
    method.setSimpleName("getGregorianChange");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Date");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getGregorianChange()
    // starting method java.util.GregorianCalendar#isLeapYear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isLeapYear(int)");
    method.setSimpleName("isLeapYear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#isLeapYear(int)
    // starting method java.util.GregorianCalendar#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#equals(java.lang.Object)
    // starting method java.util.GregorianCalendar#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#hashCode()
    // starting method java.util.GregorianCalendar#add(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, int)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#add(int, int)
    // starting method java.util.GregorianCalendar#roll(int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"roll(int, boolean)");
    method.setSimpleName("roll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#roll(int, boolean)
    // starting method java.util.GregorianCalendar#roll(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"roll(int, int)");
    method.setSimpleName("roll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#roll(int, int)
    // starting method java.util.GregorianCalendar#getMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMinimum(int)");
    method.setSimpleName("getMinimum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getMinimum(int)
    // starting method java.util.GregorianCalendar#getMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMaximum(int)");
    method.setSimpleName("getMaximum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getMaximum(int)
    // starting method java.util.GregorianCalendar#getGreatestMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getGreatestMinimum(int)");
    method.setSimpleName("getGreatestMinimum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getGreatestMinimum(int)
    // starting method java.util.GregorianCalendar#getLeastMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLeastMaximum(int)");
    method.setSimpleName("getLeastMaximum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getLeastMaximum(int)
    // starting method java.util.GregorianCalendar#getActualMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActualMinimum(int)");
    method.setSimpleName("getActualMinimum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getActualMinimum(int)
    // starting method java.util.GregorianCalendar#getActualMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActualMaximum(int)");
    method.setSimpleName("getActualMaximum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getActualMaximum(int)
    // ignoring method java.util.GregorianCalendar#getYearOffsetInMillis()
    // starting method java.util.GregorianCalendar#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#clone()
    // starting method java.util.GregorianCalendar#getTimeZone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimeZone()");
    method.setSimpleName("getTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getTimeZone()
    // starting method java.util.GregorianCalendar#setTimeZone(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTimeZone(java.util.TimeZone)");
    method.setSimpleName("setTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#setTimeZone(java.util.TimeZone)
    // starting method java.util.GregorianCalendar#computeFields()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"computeFields()");
    method.setSimpleName("computeFields");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#computeFields()
    // ignoring method java.util.GregorianCalendar#computeFields(int, int)
    // ignoring method java.util.GregorianCalendar#getWeekNumber(long, long)
    // starting method java.util.GregorianCalendar#computeTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"computeTime()");
    method.setSimpleName("computeTime");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#computeTime()
    // ignoring method java.util.GregorianCalendar#getFixedDate(sun.util.calendar.BaseCalendar, int, int)
    // ignoring method java.util.GregorianCalendar#getNormalizedCalendar()
    // ignoring method java.util.GregorianCalendar#getJulianCalendarSystem()
    // ignoring method java.util.GregorianCalendar#getCutoverCalendarSystem()
    // ignoring method java.util.GregorianCalendar#isCutoverYear(int)
    // ignoring method java.util.GregorianCalendar#getFixedDateJan1(sun.util.calendar.BaseCalendar$Date, long)
    // ignoring method java.util.GregorianCalendar#getFixedDateMonth1(sun.util.calendar.BaseCalendar$Date, long)
    // ignoring method java.util.GregorianCalendar#getCalendarDate(long)
    // ignoring method java.util.GregorianCalendar#getGregorianCutoverDate()
    // ignoring method java.util.GregorianCalendar#getLastJulianDate()
    // ignoring method java.util.GregorianCalendar#monthLength(int, int)
    // ignoring method java.util.GregorianCalendar#monthLength(int)
    // ignoring method java.util.GregorianCalendar#actualMonthLength()
    // ignoring method java.util.GregorianCalendar#yearLength(int)
    // ignoring method java.util.GregorianCalendar#yearLength()
    // ignoring method java.util.GregorianCalendar#pinDayOfMonth()
    // ignoring method java.util.GregorianCalendar#getCurrentFixedDate()
    // ignoring method java.util.GregorianCalendar#getRolledValue(int, int, int, int)
    // ignoring method java.util.GregorianCalendar#internalGetEra()
    // ignoring method java.util.GregorianCalendar#readObject(java.io.ObjectInputStream)

// finishing type java.util.GregorianCalendar
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.HashMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Entry#key
	field = newType.addNode(JavaDataField.class,"key"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Entry#key

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Entry#value
	field = newType.addNode(JavaDataField.class,"value"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Entry#value

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Entry#hash
	field = newType.addNode(JavaDataField.class,"hash"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Entry#hash

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Entry#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Entry#next


    // starting method java.util.HashMap$Entry#HashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)");
    method.setSimpleName("HashMap$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#HashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)
    // starting method java.util.HashMap$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#getKey()
    // starting method java.util.HashMap$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#getValue()
    // starting method java.util.HashMap$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#setValue(java.lang.Object)
    // starting method java.util.HashMap$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#equals(java.lang.Object)
    // starting method java.util.HashMap$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#hashCode()
    // starting method java.util.HashMap$Entry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#toString()
    // starting method java.util.HashMap$Entry#recordAccess(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"recordAccess(java.util.HashMap)");
    method.setSimpleName("recordAccess");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#recordAccess(java.util.HashMap)
    // starting method java.util.HashMap$Entry#recordRemoval(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"recordRemoval(java.util.HashMap)");
    method.setSimpleName("recordRemoval");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#recordRemoval(java.util.HashMap)

// finishing type java.util.HashMap$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$EntryIterator#this$0


    // ignoring method java.util.HashMap$EntryIterator#HashMap$EntryIterator(java.util.HashMap)
    // starting method java.util.HashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntryIterator#next()
    // starting method java.util.HashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntryIterator#next()
    // starting method java.util.HashMap$EntryIterator#HashMap$EntryIterator(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$EntryIterator(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntryIterator#HashMap$EntryIterator(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$EntrySet#this$0


    // ignoring method java.util.HashMap$EntrySet#HashMap$EntrySet(java.util.HashMap)
    // starting method java.util.HashMap$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#iterator()
    // starting method java.util.HashMap$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#contains(java.lang.Object)
    // starting method java.util.HashMap$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#remove(java.lang.Object)
    // starting method java.util.HashMap$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#size()
    // starting method java.util.HashMap$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#clear()
    // starting method java.util.HashMap$EntrySet#HashMap$EntrySet(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$EntrySet(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#HashMap$EntrySet(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$HashIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#next

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#current
	field = newType.addNode(JavaDataField.class,"current"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#current

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#this$0


    // starting method java.util.HashMap$HashIterator#HashMap$HashIterator(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$HashIterator(java.util.HashMap)");
    method.setSimpleName("HashMap$HashIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$HashIterator#HashMap$HashIterator(java.util.HashMap)
    // starting method java.util.HashMap$HashIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$HashIterator#hasNext()
    // starting method java.util.HashMap$HashIterator#nextEntry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextEntry()");
    method.setSimpleName("nextEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$HashIterator#nextEntry()
    // starting method java.util.HashMap$HashIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$HashIterator#remove()

// finishing type java.util.HashMap$HashIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$KeyIterator#this$0


    // ignoring method java.util.HashMap$KeyIterator#HashMap$KeyIterator(java.util.HashMap)
    // starting method java.util.HashMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeyIterator#next()
    // starting method java.util.HashMap$KeyIterator#HashMap$KeyIterator(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$KeyIterator(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeyIterator#HashMap$KeyIterator(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$KeySet#this$0


    // ignoring method java.util.HashMap$KeySet#HashMap$KeySet(java.util.HashMap)
    // starting method java.util.HashMap$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#iterator()
    // starting method java.util.HashMap$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#size()
    // starting method java.util.HashMap$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#contains(java.lang.Object)
    // starting method java.util.HashMap$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#remove(java.lang.Object)
    // starting method java.util.HashMap$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#clear()
    // starting method java.util.HashMap$KeySet#HashMap$KeySet(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$KeySet(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#HashMap$KeySet(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$ValueIterator#this$0


    // ignoring method java.util.HashMap$ValueIterator#HashMap$ValueIterator(java.util.HashMap)
    // starting method java.util.HashMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$ValueIterator#next()
    // starting method java.util.HashMap$ValueIterator#HashMap$ValueIterator(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$ValueIterator(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$ValueIterator#HashMap$ValueIterator(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$Values");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Values#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Values#this$0


    // ignoring method java.util.HashMap$Values#HashMap$Values(java.util.HashMap)
    // starting method java.util.HashMap$Values#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#iterator()
    // starting method java.util.HashMap$Values#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#size()
    // starting method java.util.HashMap$Values#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#contains(java.lang.Object)
    // starting method java.util.HashMap$Values#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#clear()
    // starting method java.util.HashMap$Values#HashMap$Values(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$Values(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$Values");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#HashMap$Values(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$Values
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#DEFAULT_INITIAL_CAPACITY
	field = newType.addNode(JavaDataField.class,"DEFAULT_INITIAL_CAPACITY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashMap#DEFAULT_INITIAL_CAPACITY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#MAXIMUM_CAPACITY
	field = newType.addNode(JavaDataField.class,"MAXIMUM_CAPACITY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashMap#MAXIMUM_CAPACITY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#DEFAULT_LOAD_FACTOR
	field = newType.addNode(JavaDataField.class,"DEFAULT_LOAD_FACTOR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","float");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashMap#DEFAULT_LOAD_FACTOR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#table
	field = newType.addNode(JavaDataField.class,"table"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 128, isArray, arrayDimensions);
    // finishing field java.util.HashMap#table

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#size
	field = newType.addNode(JavaDataField.class,"size"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 128, isArray, arrayDimensions);
    // finishing field java.util.HashMap#size

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#threshold
	field = newType.addNode(JavaDataField.class,"threshold"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap#threshold

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#loadFactor
	field = newType.addNode(JavaDataField.class,"loadFactor"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","float");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.HashMap#loadFactor

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#modCount
	field = newType.addNode(JavaDataField.class,"modCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 192, isArray, arrayDimensions);
    // finishing field java.util.HashMap#modCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#NULL_KEY
	field = newType.addNode(JavaDataField.class,"NULL_KEY"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashMap#NULL_KEY

// ignoring field java.util.HashMap#useNewHash 

// ignoring field java.util.HashMap#entrySet 

// ignoring field java.util.HashMap#serialVersionUID 


    // starting method java.util.HashMap#HashMap(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap(int, float)");
    method.setSimpleName("HashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#HashMap(int, float)
    // starting method java.util.HashMap#HashMap(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap(int)");
    method.setSimpleName("HashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#HashMap(int)
    // starting method java.util.HashMap#HashMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap()");
    method.setSimpleName("HashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#HashMap()
    // starting method java.util.HashMap#HashMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap(java.util.Map)");
    method.setSimpleName("HashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#HashMap(java.util.Map)
    // starting method java.util.HashMap#init()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"init()");
    method.setSimpleName("init");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#init()
    // starting method java.util.HashMap#maskNull(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"maskNull(java.lang.Object)");
    method.setSimpleName("maskNull");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#maskNull(java.lang.Object)
    // starting method java.util.HashMap#unmaskNull(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmaskNull(java.lang.Object)");
    method.setSimpleName("unmaskNull");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#unmaskNull(java.lang.Object)
    // ignoring method java.util.HashMap#oldHash(int)
    // ignoring method java.util.HashMap#newHash(int)
    // starting method java.util.HashMap#hash(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hash(int)");
    method.setSimpleName("hash");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#hash(int)
    // starting method java.util.HashMap#hash(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hash(java.lang.Object)");
    method.setSimpleName("hash");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#hash(java.lang.Object)
    // starting method java.util.HashMap#eq(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"eq(java.lang.Object, java.lang.Object)");
    method.setSimpleName("eq");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#eq(java.lang.Object, java.lang.Object)
    // starting method java.util.HashMap#indexFor(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexFor(int, int)");
    method.setSimpleName("indexFor");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#indexFor(int, int)
    // starting method java.util.HashMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#size()
    // starting method java.util.HashMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#isEmpty()
    // starting method java.util.HashMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#get(java.lang.Object)
    // ignoring method java.util.HashMap#getForNullKey()
    // starting method java.util.HashMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#containsKey(java.lang.Object)
    // starting method java.util.HashMap#getEntry(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getEntry(java.lang.Object)");
    method.setSimpleName("getEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#getEntry(java.lang.Object)
    // starting method java.util.HashMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#put(java.lang.Object, java.lang.Object)
    // ignoring method java.util.HashMap#putForNullKey(java.lang.Object)
    // ignoring method java.util.HashMap#putForCreate(java.lang.Object, java.lang.Object)
    // starting method java.util.HashMap#putAllForCreate(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAllForCreate(java.util.Map)");
    method.setSimpleName("putAllForCreate");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#putAllForCreate(java.util.Map)
    // starting method java.util.HashMap#resize(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"resize(int)");
    method.setSimpleName("resize");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#resize(int)
    // starting method java.util.HashMap#transfer(java.util.HashMap$Entry[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"transfer(java.util.HashMap$Entry[])");
    method.setSimpleName("transfer");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#transfer(java.util.HashMap$Entry[])
    // starting method java.util.HashMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#putAll(java.util.Map)
    // starting method java.util.HashMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#remove(java.lang.Object)
    // starting method java.util.HashMap#removeEntryForKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeEntryForKey(java.lang.Object)");
    method.setSimpleName("removeEntryForKey");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#removeEntryForKey(java.lang.Object)
    // starting method java.util.HashMap#removeMapping(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeMapping(java.lang.Object)");
    method.setSimpleName("removeMapping");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#removeMapping(java.lang.Object)
    // starting method java.util.HashMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#clear()
    // starting method java.util.HashMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#containsValue(java.lang.Object)
    // ignoring method java.util.HashMap#containsNullValue()
    // starting method java.util.HashMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#clone()
    // starting method java.util.HashMap#addEntry(int, java.lang.Object, java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addEntry(int, java.lang.Object, java.lang.Object, int)");
    method.setSimpleName("addEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#addEntry(int, java.lang.Object, java.lang.Object, int)
    // starting method java.util.HashMap#createEntry(int, java.lang.Object, java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"createEntry(int, java.lang.Object, java.lang.Object, int)");
    method.setSimpleName("createEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#createEntry(int, java.lang.Object, java.lang.Object, int)
    // starting method java.util.HashMap#newKeyIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newKeyIterator()");
    method.setSimpleName("newKeyIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#newKeyIterator()
    // starting method java.util.HashMap#newValueIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newValueIterator()");
    method.setSimpleName("newValueIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#newValueIterator()
    // starting method java.util.HashMap#newEntryIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newEntryIterator()");
    method.setSimpleName("newEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#newEntryIterator()
    // starting method java.util.HashMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#keySet()
    // starting method java.util.HashMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#values()
    // starting method java.util.HashMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#entrySet()
    // ignoring method java.util.HashMap#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.HashMap#readObject(java.io.ObjectInputStream)
    // starting method java.util.HashMap#capacity()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"capacity()");
    method.setSimpleName("capacity");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#capacity()
    // starting method java.util.HashMap#loadFactor()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"loadFactor()");
    method.setSimpleName("loadFactor");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "float");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#loadFactor()

// finishing type java.util.HashMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashSet#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashSet#serialVersionUID

// ignoring field java.util.HashSet#map 

// ignoring field java.util.HashSet#PRESENT 


    // starting method java.util.HashSet#HashSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet()");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet()
    // starting method java.util.HashSet#HashSet(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet(java.util.Collection)");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet(java.util.Collection)
    // starting method java.util.HashSet#HashSet(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet(int, float)");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet(int, float)
    // starting method java.util.HashSet#HashSet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet(int)");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet(int)
    // starting method java.util.HashSet#HashSet(int, float, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet(int, float, boolean)");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet(int, float, boolean)
    // starting method java.util.HashSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#iterator()
    // starting method java.util.HashSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#size()
    // starting method java.util.HashSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#isEmpty()
    // starting method java.util.HashSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#contains(java.lang.Object)
    // starting method java.util.HashSet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#add(java.lang.Object)
    // starting method java.util.HashSet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#remove(java.lang.Object)
    // starting method java.util.HashSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#clear()
    // starting method java.util.HashSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#clone()
    // ignoring method java.util.HashSet#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.HashSet#readObject(java.io.ObjectInputStream)

// finishing type java.util.HashSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.Hashtable$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EmptyEnumerator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 


    // starting method java.util.Hashtable$EmptyEnumerator#Hashtable$EmptyEnumerator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$EmptyEnumerator()");
    method.setSimpleName("Hashtable$EmptyEnumerator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyEnumerator#Hashtable$EmptyEnumerator()
    // starting method java.util.Hashtable$EmptyEnumerator#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyEnumerator#hasMoreElements()
    // starting method java.util.Hashtable$EmptyEnumerator#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyEnumerator#nextElement()

// finishing type java.util.Hashtable$EmptyEnumerator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EmptyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 


    // starting method java.util.Hashtable$EmptyIterator#Hashtable$EmptyIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$EmptyIterator()");
    method.setSimpleName("Hashtable$EmptyIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyIterator#Hashtable$EmptyIterator()
    // starting method java.util.Hashtable$EmptyIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyIterator#hasNext()
    // starting method java.util.Hashtable$EmptyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyIterator#next()
    // starting method java.util.Hashtable$EmptyIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyIterator#remove()

// finishing type java.util.Hashtable$EmptyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Entry#hash
	field = newType.addNode(JavaDataField.class,"hash"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Entry#hash

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Entry#key
	field = newType.addNode(JavaDataField.class,"key"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Entry#key

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Entry#value
	field = newType.addNode(JavaDataField.class,"value"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Entry#value

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Entry#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Entry#next


    // starting method java.util.Hashtable$Entry#Hashtable$Entry(int, java.lang.Object, java.lang.Object, java.util.Hashtable$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$Entry(int, java.lang.Object, java.lang.Object, java.util.Hashtable$Entry)");
    method.setSimpleName("Hashtable$Entry");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#Hashtable$Entry(int, java.lang.Object, java.lang.Object, java.util.Hashtable$Entry)
    // starting method java.util.Hashtable$Entry#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#clone()
    // starting method java.util.Hashtable$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#getKey()
    // starting method java.util.Hashtable$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#getValue()
    // starting method java.util.Hashtable$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#setValue(java.lang.Object)
    // starting method java.util.Hashtable$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#equals(java.lang.Object)
    // starting method java.util.Hashtable$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#hashCode()
    // starting method java.util.Hashtable$Entry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#toString()

// finishing type java.util.Hashtable$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$EntrySet#this$0


    // ignoring method java.util.Hashtable$EntrySet#Hashtable$EntrySet(java.util.Hashtable)
    // starting method java.util.Hashtable$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#iterator()
    // starting method java.util.Hashtable$EntrySet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#add(java.lang.Object)
    // starting method java.util.Hashtable$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#contains(java.lang.Object)
    // starting method java.util.Hashtable$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#remove(java.lang.Object)
    // starting method java.util.Hashtable$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#size()
    // starting method java.util.Hashtable$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#clear()
    // starting method java.util.Hashtable$EntrySet#Hashtable$EntrySet(java.util.Hashtable, java.util.Hashtable$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$EntrySet(java.util.Hashtable, java.util.Hashtable$1)");
    method.setSimpleName("Hashtable$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#Hashtable$EntrySet(java.util.Hashtable, java.util.Hashtable$1)

// finishing type java.util.Hashtable$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$Enumerator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#table
	field = newType.addNode(JavaDataField.class,"table"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#table

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#entry
	field = newType.addNode(JavaDataField.class,"entry"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#entry

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#type
	field = newType.addNode(JavaDataField.class,"type"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#type

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#iterator
	field = newType.addNode(JavaDataField.class,"iterator"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#iterator

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#this$0


    // starting method java.util.Hashtable$Enumerator#Hashtable$Enumerator(java.util.Hashtable, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$Enumerator(java.util.Hashtable, int, boolean)");
    method.setSimpleName("Hashtable$Enumerator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#Hashtable$Enumerator(java.util.Hashtable, int, boolean)
    // starting method java.util.Hashtable$Enumerator#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#hasMoreElements()
    // starting method java.util.Hashtable$Enumerator#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#nextElement()
    // starting method java.util.Hashtable$Enumerator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#hasNext()
    // starting method java.util.Hashtable$Enumerator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#next()
    // starting method java.util.Hashtable$Enumerator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#remove()

// finishing type java.util.Hashtable$Enumerator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$KeySet#this$0


    // ignoring method java.util.Hashtable$KeySet#Hashtable$KeySet(java.util.Hashtable)
    // starting method java.util.Hashtable$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#iterator()
    // starting method java.util.Hashtable$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#size()
    // starting method java.util.Hashtable$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#contains(java.lang.Object)
    // starting method java.util.Hashtable$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#remove(java.lang.Object)
    // starting method java.util.Hashtable$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#clear()
    // starting method java.util.Hashtable$KeySet#Hashtable$KeySet(java.util.Hashtable, java.util.Hashtable$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$KeySet(java.util.Hashtable, java.util.Hashtable$1)");
    method.setSimpleName("Hashtable$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#Hashtable$KeySet(java.util.Hashtable, java.util.Hashtable$1)

// finishing type java.util.Hashtable$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$ValueCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$ValueCollection#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$ValueCollection#this$0


    // ignoring method java.util.Hashtable$ValueCollection#Hashtable$ValueCollection(java.util.Hashtable)
    // starting method java.util.Hashtable$ValueCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#iterator()
    // starting method java.util.Hashtable$ValueCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#size()
    // starting method java.util.Hashtable$ValueCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#contains(java.lang.Object)
    // starting method java.util.Hashtable$ValueCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#clear()
    // starting method java.util.Hashtable$ValueCollection#Hashtable$ValueCollection(java.util.Hashtable, java.util.Hashtable$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$ValueCollection(java.util.Hashtable, java.util.Hashtable$1)");
    method.setSimpleName("Hashtable$ValueCollection");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#Hashtable$ValueCollection(java.util.Hashtable, java.util.Hashtable$1)

// finishing type java.util.Hashtable$ValueCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Dictionary");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Hashtable#table 

// ignoring field java.util.Hashtable#count 

// ignoring field java.util.Hashtable#threshold 

// ignoring field java.util.Hashtable#loadFactor 

// ignoring field java.util.Hashtable#modCount 

// ignoring field java.util.Hashtable#serialVersionUID 

// ignoring field java.util.Hashtable#keySet 

// ignoring field java.util.Hashtable#entrySet 

// ignoring field java.util.Hashtable#values 

// ignoring field java.util.Hashtable#KEYS 

// ignoring field java.util.Hashtable#VALUES 

// ignoring field java.util.Hashtable#ENTRIES 

// ignoring field java.util.Hashtable#emptyEnumerator 

// ignoring field java.util.Hashtable#emptyIterator 


    // starting method java.util.Hashtable#Hashtable(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable(int, float)");
    method.setSimpleName("Hashtable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#Hashtable(int, float)
    // starting method java.util.Hashtable#Hashtable(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable(int)");
    method.setSimpleName("Hashtable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#Hashtable(int)
    // starting method java.util.Hashtable#Hashtable()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable()");
    method.setSimpleName("Hashtable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#Hashtable()
    // starting method java.util.Hashtable#Hashtable(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable(java.util.Map)");
    method.setSimpleName("Hashtable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#Hashtable(java.util.Map)
    // starting method java.util.Hashtable#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#size()
    // starting method java.util.Hashtable#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#isEmpty()
    // starting method java.util.Hashtable#keys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keys()");
    method.setSimpleName("keys");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#keys()
    // starting method java.util.Hashtable#elements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elements()");
    method.setSimpleName("elements");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#elements()
    // starting method java.util.Hashtable#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#contains(java.lang.Object)
    // starting method java.util.Hashtable#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#containsValue(java.lang.Object)
    // starting method java.util.Hashtable#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#containsKey(java.lang.Object)
    // starting method java.util.Hashtable#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#get(java.lang.Object)
    // starting method java.util.Hashtable#rehash()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"rehash()");
    method.setSimpleName("rehash");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#rehash()
    // starting method java.util.Hashtable#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Hashtable#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#remove(java.lang.Object)
    // starting method java.util.Hashtable#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#putAll(java.util.Map)
    // starting method java.util.Hashtable#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#clear()
    // starting method java.util.Hashtable#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#clone()
    // starting method java.util.Hashtable#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#toString()
    // ignoring method java.util.Hashtable#getEnumeration(int)
    // ignoring method java.util.Hashtable#getIterator(int)
    // starting method java.util.Hashtable#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#keySet()
    // starting method java.util.Hashtable#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#entrySet()
    // starting method java.util.Hashtable#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#values()
    // starting method java.util.Hashtable#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#equals(java.lang.Object)
    // starting method java.util.Hashtable#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#hashCode()
    // ignoring method java.util.Hashtable#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.Hashtable#readObject(java.io.ObjectInputStream)
    // ignoring method java.util.Hashtable#reconstitutionPut(java.util.Hashtable$Entry[], java.lang.Object, java.lang.Object)
    // starting method java.util.Hashtable#access$100(java.util.Hashtable, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.Hashtable, int)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$100(java.util.Hashtable, int)
    // starting method java.util.Hashtable#access$200(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.Hashtable)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$200(java.util.Hashtable)
    // starting method java.util.Hashtable#access$400(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.Hashtable)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$400(java.util.Hashtable)
    // starting method java.util.Hashtable#access$508(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$508(java.util.Hashtable)");
    method.setSimpleName("access$508");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$508(java.util.Hashtable)
    // starting method java.util.Hashtable#access$210(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$210(java.util.Hashtable)");
    method.setSimpleName("access$210");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$210(java.util.Hashtable)
    // starting method java.util.Hashtable#access$500(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$500(java.util.Hashtable)");
    method.setSimpleName("access$500");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$500(java.util.Hashtable)

// finishing type java.util.Hashtable
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.IdentityHashMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IdentityHashMap$IdentityHashMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$EntryIterator#this$0


    // ignoring method java.util.IdentityHashMap$EntryIterator#IdentityHashMap$EntryIterator(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#next()
    // starting method java.util.IdentityHashMap$EntryIterator#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#getKey()
    // starting method java.util.IdentityHashMap$EntryIterator#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#getValue()
    // starting method java.util.IdentityHashMap$EntryIterator#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#setValue(java.lang.Object)
    // starting method java.util.IdentityHashMap$EntryIterator#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#equals(java.lang.Object)
    // starting method java.util.IdentityHashMap$EntryIterator#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#hashCode()
    // starting method java.util.IdentityHashMap$EntryIterator#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#toString()
    // starting method java.util.IdentityHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#next()
    // starting method java.util.IdentityHashMap$EntryIterator#IdentityHashMap$EntryIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$EntryIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#IdentityHashMap$EntryIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$EntrySet#this$0


    // ignoring method java.util.IdentityHashMap$EntrySet#IdentityHashMap$EntrySet(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#iterator()
    // starting method java.util.IdentityHashMap$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#contains(java.lang.Object)
    // starting method java.util.IdentityHashMap$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#remove(java.lang.Object)
    // starting method java.util.IdentityHashMap$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#size()
    // starting method java.util.IdentityHashMap$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#clear()
    // starting method java.util.IdentityHashMap$EntrySet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#removeAll(java.util.Collection)
    // starting method java.util.IdentityHashMap$EntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#toArray()
    // starting method java.util.IdentityHashMap$EntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#toArray(java.lang.Object[])
    // starting method java.util.IdentityHashMap$EntrySet#IdentityHashMap$EntrySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$EntrySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#IdentityHashMap$EntrySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$IdentityHashMapIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#lastReturnedIndex
	field = newType.addNode(JavaDataField.class,"lastReturnedIndex"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#lastReturnedIndex

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#indexValid
	field = newType.addNode(JavaDataField.class,"indexValid"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#indexValid

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#traversalTable
	field = newType.addNode(JavaDataField.class,"traversalTable"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#traversalTable

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#this$0


    // ignoring method java.util.IdentityHashMap$IdentityHashMapIterator#IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$IdentityHashMapIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$IdentityHashMapIterator#hasNext()
    // starting method java.util.IdentityHashMap$IdentityHashMapIterator#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$IdentityHashMapIterator#nextIndex()
    // starting method java.util.IdentityHashMap$IdentityHashMapIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$IdentityHashMapIterator#remove()
    // starting method java.util.IdentityHashMap$IdentityHashMapIterator#IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$IdentityHashMapIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$IdentityHashMapIterator#IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$IdentityHashMapIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IdentityHashMap$IdentityHashMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$KeyIterator#this$0


    // ignoring method java.util.IdentityHashMap$KeyIterator#IdentityHashMap$KeyIterator(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeyIterator#next()
    // starting method java.util.IdentityHashMap$KeyIterator#IdentityHashMap$KeyIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$KeyIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeyIterator#IdentityHashMap$KeyIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$KeySet#this$0


    // ignoring method java.util.IdentityHashMap$KeySet#IdentityHashMap$KeySet(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#iterator()
    // starting method java.util.IdentityHashMap$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#size()
    // starting method java.util.IdentityHashMap$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#contains(java.lang.Object)
    // starting method java.util.IdentityHashMap$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#remove(java.lang.Object)
    // starting method java.util.IdentityHashMap$KeySet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#removeAll(java.util.Collection)
    // starting method java.util.IdentityHashMap$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#clear()
    // starting method java.util.IdentityHashMap$KeySet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#hashCode()
    // starting method java.util.IdentityHashMap$KeySet#IdentityHashMap$KeySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$KeySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#IdentityHashMap$KeySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IdentityHashMap$IdentityHashMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$ValueIterator#this$0


    // ignoring method java.util.IdentityHashMap$ValueIterator#IdentityHashMap$ValueIterator(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$ValueIterator#next()
    // starting method java.util.IdentityHashMap$ValueIterator#IdentityHashMap$ValueIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$ValueIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$ValueIterator#IdentityHashMap$ValueIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$Values");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$Values#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$Values#this$0


    // ignoring method java.util.IdentityHashMap$Values#IdentityHashMap$Values(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$Values#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#iterator()
    // starting method java.util.IdentityHashMap$Values#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#size()
    // starting method java.util.IdentityHashMap$Values#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#contains(java.lang.Object)
    // starting method java.util.IdentityHashMap$Values#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#remove(java.lang.Object)
    // starting method java.util.IdentityHashMap$Values#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#clear()
    // starting method java.util.IdentityHashMap$Values#IdentityHashMap$Values(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$Values(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$Values");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#IdentityHashMap$Values(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$Values
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 

// ignoring field java.util.IdentityHashMap#DEFAULT_CAPACITY 

// ignoring field java.util.IdentityHashMap#MINIMUM_CAPACITY 

// ignoring field java.util.IdentityHashMap#MAXIMUM_CAPACITY 

// ignoring field java.util.IdentityHashMap#table 

// ignoring field java.util.IdentityHashMap#size 

// ignoring field java.util.IdentityHashMap#modCount 

// ignoring field java.util.IdentityHashMap#threshold 

// ignoring field java.util.IdentityHashMap#NULL_KEY 

// ignoring field java.util.IdentityHashMap#entrySet 

// ignoring field java.util.IdentityHashMap#serialVersionUID 


    // ignoring method java.util.IdentityHashMap#maskNull(java.lang.Object)
    // ignoring method java.util.IdentityHashMap#unmaskNull(java.lang.Object)
    // starting method java.util.IdentityHashMap#IdentityHashMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap()");
    method.setSimpleName("IdentityHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#IdentityHashMap()
    // starting method java.util.IdentityHashMap#IdentityHashMap(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap(int)");
    method.setSimpleName("IdentityHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#IdentityHashMap(int)
    // ignoring method java.util.IdentityHashMap#capacity(int)
    // ignoring method java.util.IdentityHashMap#init(int)
    // starting method java.util.IdentityHashMap#IdentityHashMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap(java.util.Map)");
    method.setSimpleName("IdentityHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#IdentityHashMap(java.util.Map)
    // starting method java.util.IdentityHashMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#size()
    // starting method java.util.IdentityHashMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#isEmpty()
    // ignoring method java.util.IdentityHashMap#hash(java.lang.Object, int)
    // ignoring method java.util.IdentityHashMap#nextKeyIndex(int, int)
    // starting method java.util.IdentityHashMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#get(java.lang.Object)
    // starting method java.util.IdentityHashMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#containsKey(java.lang.Object)
    // starting method java.util.IdentityHashMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#containsValue(java.lang.Object)
    // ignoring method java.util.IdentityHashMap#containsMapping(java.lang.Object, java.lang.Object)
    // starting method java.util.IdentityHashMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#put(java.lang.Object, java.lang.Object)
    // ignoring method java.util.IdentityHashMap#resize(int)
    // starting method java.util.IdentityHashMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#putAll(java.util.Map)
    // starting method java.util.IdentityHashMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#remove(java.lang.Object)
    // ignoring method java.util.IdentityHashMap#removeMapping(java.lang.Object, java.lang.Object)
    // ignoring method java.util.IdentityHashMap#closeDeletion(int)
    // starting method java.util.IdentityHashMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#clear()
    // starting method java.util.IdentityHashMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#equals(java.lang.Object)
    // starting method java.util.IdentityHashMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#hashCode()
    // starting method java.util.IdentityHashMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#clone()
    // starting method java.util.IdentityHashMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#keySet()
    // starting method java.util.IdentityHashMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#values()
    // starting method java.util.IdentityHashMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#entrySet()
    // ignoring method java.util.IdentityHashMap#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.IdentityHashMap#readObject(java.io.ObjectInputStream)
    // ignoring method java.util.IdentityHashMap#putForCreate(java.lang.Object, java.lang.Object)
    // starting method java.util.IdentityHashMap#access$000(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.IdentityHashMap)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$000(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$100(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.IdentityHashMap)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$100(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$200(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.IdentityHashMap)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$200(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$204(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$204(java.util.IdentityHashMap)");
    method.setSimpleName("access$204");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$204(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$010(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$010(java.util.IdentityHashMap)");
    method.setSimpleName("access$010");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$010(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$300(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(int, int)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$300(int, int)
    // starting method java.util.IdentityHashMap#access$400(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.lang.Object, int)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$400(java.lang.Object, int)
    // starting method java.util.IdentityHashMap#access$600(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$600(java.lang.Object)");
    method.setSimpleName("access$600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$600(java.lang.Object)
    // starting method java.util.IdentityHashMap#access$1300(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1300(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$1300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$1300(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)
    // starting method java.util.IdentityHashMap#access$1400(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1400(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$1400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$1400(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)

// finishing type java.util.IdentityHashMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatCodePointException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatCodePointException#serialVersionUID 

// ignoring field java.util.IllegalFormatCodePointException#c 


    // starting method java.util.IllegalFormatCodePointException#IllegalFormatCodePointException(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatCodePointException(int)");
    method.setSimpleName("IllegalFormatCodePointException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatCodePointException#IllegalFormatCodePointException(int)
    // starting method java.util.IllegalFormatCodePointException#getCodePoint()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getCodePoint()");
    method.setSimpleName("getCodePoint");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatCodePointException#getCodePoint()
    // starting method java.util.IllegalFormatCodePointException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatCodePointException#getMessage()

// finishing type java.util.IllegalFormatCodePointException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatConversionException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatConversionException#serialVersionUID 

// ignoring field java.util.IllegalFormatConversionException#c 

// ignoring field java.util.IllegalFormatConversionException#arg 


    // starting method java.util.IllegalFormatConversionException#IllegalFormatConversionException(char, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatConversionException(char, java.lang.Class)");
    method.setSimpleName("IllegalFormatConversionException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatConversionException#IllegalFormatConversionException(char, java.lang.Class)
    // starting method java.util.IllegalFormatConversionException#getConversion()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getConversion()");
    method.setSimpleName("getConversion");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "char");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatConversionException#getConversion()
    // starting method java.util.IllegalFormatConversionException#getArgumentClass()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getArgumentClass()");
    method.setSimpleName("getArgumentClass");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatConversionException#getArgumentClass()
    // starting method java.util.IllegalFormatConversionException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatConversionException#getMessage()

// finishing type java.util.IllegalFormatConversionException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","IllegalArgumentException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatException#serialVersionUID 


    // starting method java.util.IllegalFormatException#IllegalFormatException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatException()");
    method.setSimpleName("IllegalFormatException");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatException#IllegalFormatException()

// finishing type java.util.IllegalFormatException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatFlagsException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatFlagsException#serialVersionUID 

// ignoring field java.util.IllegalFormatFlagsException#flags 


    // starting method java.util.IllegalFormatFlagsException#IllegalFormatFlagsException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatFlagsException(java.lang.String)");
    method.setSimpleName("IllegalFormatFlagsException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatFlagsException#IllegalFormatFlagsException(java.lang.String)
    // starting method java.util.IllegalFormatFlagsException#getFlags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFlags()");
    method.setSimpleName("getFlags");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatFlagsException#getFlags()
    // starting method java.util.IllegalFormatFlagsException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatFlagsException#getMessage()

// finishing type java.util.IllegalFormatFlagsException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatPrecisionException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatPrecisionException#serialVersionUID 

// ignoring field java.util.IllegalFormatPrecisionException#p 


    // starting method java.util.IllegalFormatPrecisionException#IllegalFormatPrecisionException(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatPrecisionException(int)");
    method.setSimpleName("IllegalFormatPrecisionException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatPrecisionException#IllegalFormatPrecisionException(int)
    // starting method java.util.IllegalFormatPrecisionException#getPrecision()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getPrecision()");
    method.setSimpleName("getPrecision");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatPrecisionException#getPrecision()
    // starting method java.util.IllegalFormatPrecisionException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatPrecisionException#getMessage()

// finishing type java.util.IllegalFormatPrecisionException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatWidthException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatWidthException#serialVersionUID 

// ignoring field java.util.IllegalFormatWidthException#w 


    // starting method java.util.IllegalFormatWidthException#IllegalFormatWidthException(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatWidthException(int)");
    method.setSimpleName("IllegalFormatWidthException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatWidthException#IllegalFormatWidthException(int)
    // starting method java.util.IllegalFormatWidthException#getWidth()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getWidth()");
    method.setSimpleName("getWidth");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatWidthException#getWidth()
    // starting method java.util.IllegalFormatWidthException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatWidthException#getMessage()

// finishing type java.util.IllegalFormatWidthException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "InputMismatchException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","NoSuchElementException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.InputMismatchException#InputMismatchException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"InputMismatchException()");
    method.setSimpleName("InputMismatchException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.InputMismatchException#InputMismatchException()
    // starting method java.util.InputMismatchException#InputMismatchException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"InputMismatchException(java.lang.String)");
    method.setSimpleName("InputMismatchException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.InputMismatchException#InputMismatchException(java.lang.String)

// finishing type java.util.InputMismatchException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "InvalidPropertiesFormatException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","IOException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.InvalidPropertiesFormatException#InvalidPropertiesFormatException(java.lang.Throwable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"InvalidPropertiesFormatException(java.lang.Throwable)");
    method.setSimpleName("InvalidPropertiesFormatException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.InvalidPropertiesFormatException#InvalidPropertiesFormatException(java.lang.Throwable)
    // starting method java.util.InvalidPropertiesFormatException#InvalidPropertiesFormatException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"InvalidPropertiesFormatException(java.lang.String)");
    method.setSimpleName("InvalidPropertiesFormatException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.InvalidPropertiesFormatException#InvalidPropertiesFormatException(java.lang.String)
    // ignoring method java.util.InvalidPropertiesFormatException#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.InvalidPropertiesFormatException#readObject(java.io.ObjectInputStream)

// finishing type java.util.InvalidPropertiesFormatException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Iterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Iterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Iterator#hasNext()
    // starting method java.util.Iterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Iterator#next()
    // starting method java.util.Iterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Iterator#remove()

// finishing type java.util.Iterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "JumboEnumSet$EnumSetIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#unseen
	field = newType.addNode(JavaDataField.class,"unseen"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#unseen

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#unseenIndex
	field = newType.addNode(JavaDataField.class,"unseenIndex"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#unseenIndex

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#lastReturnedIndex
	field = newType.addNode(JavaDataField.class,"lastReturnedIndex"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#lastReturnedIndex

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","JumboEnumSet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#this$0


    // starting method java.util.JumboEnumSet$EnumSetIterator#JumboEnumSet$EnumSetIterator(java.util.JumboEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"JumboEnumSet$EnumSetIterator(java.util.JumboEnumSet)");
    method.setSimpleName("JumboEnumSet$EnumSetIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#JumboEnumSet$EnumSetIterator(java.util.JumboEnumSet)
    // starting method java.util.JumboEnumSet$EnumSetIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#hasNext()
    // starting method java.util.JumboEnumSet$EnumSetIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Enum");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#next()
    // starting method java.util.JumboEnumSet$EnumSetIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#remove()
    // starting method java.util.JumboEnumSet$EnumSetIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#next()

// finishing type java.util.JumboEnumSet$EnumSetIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "JumboEnumSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.JumboEnumSet#elements 

// ignoring field java.util.JumboEnumSet#size 


    // starting method java.util.JumboEnumSet#JumboEnumSet(java.lang.Class, java.lang.Enum[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"JumboEnumSet(java.lang.Class, java.lang.Enum[])");
    method.setSimpleName("JumboEnumSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#JumboEnumSet(java.lang.Class, java.lang.Enum[])
    // starting method java.util.JumboEnumSet#addRange(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addRange(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("addRange");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#addRange(java.lang.Enum, java.lang.Enum)
    // starting method java.util.JumboEnumSet#addAll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll()");
    method.setSimpleName("addAll");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#addAll()
    // starting method java.util.JumboEnumSet#complement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complement()");
    method.setSimpleName("complement");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#complement()
    // starting method java.util.JumboEnumSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#iterator()
    // starting method java.util.JumboEnumSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#size()
    // starting method java.util.JumboEnumSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#isEmpty()
    // starting method java.util.JumboEnumSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#contains(java.lang.Object)
    // starting method java.util.JumboEnumSet#add(java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Enum)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#add(java.lang.Enum)
    // starting method java.util.JumboEnumSet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#remove(java.lang.Object)
    // starting method java.util.JumboEnumSet#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#containsAll(java.util.Collection)
    // starting method java.util.JumboEnumSet#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#addAll(java.util.Collection)
    // starting method java.util.JumboEnumSet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#removeAll(java.util.Collection)
    // starting method java.util.JumboEnumSet#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#retainAll(java.util.Collection)
    // starting method java.util.JumboEnumSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#clear()
    // starting method java.util.JumboEnumSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#equals(java.lang.Object)
    // ignoring method java.util.JumboEnumSet#recalculateSize()
    // starting method java.util.JumboEnumSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#clone()
    // starting method java.util.JumboEnumSet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#add(java.lang.Object)
    // starting method java.util.JumboEnumSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","CloneNotSupportedException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.CloneNotSupportedException
    
    // finishing method java.util.JumboEnumSet#clone()
    // starting method java.util.JumboEnumSet#access$000(java.util.JumboEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.JumboEnumSet)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#access$000(java.util.JumboEnumSet)
    // starting method java.util.JumboEnumSet#access$110(java.util.JumboEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$110(java.util.JumboEnumSet)");
    method.setSimpleName("access$110");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#access$110(java.util.JumboEnumSet)

// finishing type java.util.JumboEnumSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.LinkedHashMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap$Entry");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$Entry#before
	field = newType.addNode(JavaDataField.class,"before"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$Entry#before

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$Entry#after
	field = newType.addNode(JavaDataField.class,"after"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$Entry#after


    // starting method java.util.LinkedHashMap$Entry#LinkedHashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)");
    method.setSimpleName("LinkedHashMap$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$Entry#LinkedHashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)
    // ignoring method java.util.LinkedHashMap$Entry#remove()
    // ignoring method java.util.LinkedHashMap$Entry#addBefore(java.util.LinkedHashMap$Entry)
    // starting method java.util.LinkedHashMap$Entry#recordAccess(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"recordAccess(java.util.HashMap)");
    method.setSimpleName("recordAccess");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$Entry#recordAccess(java.util.HashMap)
    // starting method java.util.LinkedHashMap$Entry#recordRemoval(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"recordRemoval(java.util.HashMap)");
    method.setSimpleName("recordRemoval");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$Entry#recordRemoval(java.util.HashMap)
    // starting method java.util.LinkedHashMap$Entry#access$600(java.util.LinkedHashMap$Entry, java.util.LinkedHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$600(java.util.LinkedHashMap$Entry, java.util.LinkedHashMap$Entry)");
    method.setSimpleName("access$600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$Entry#access$600(java.util.LinkedHashMap$Entry, java.util.LinkedHashMap$Entry)

// finishing type java.util.LinkedHashMap$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","LinkedHashMap$LinkedHashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$EntryIterator#this$0


    // ignoring method java.util.LinkedHashMap$EntryIterator#LinkedHashMap$EntryIterator(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$EntryIterator#next()
    // starting method java.util.LinkedHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$EntryIterator#next()
    // starting method java.util.LinkedHashMap$EntryIterator#LinkedHashMap$EntryIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$EntryIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)");
    method.setSimpleName("LinkedHashMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$EntryIterator#LinkedHashMap$EntryIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)

// finishing type java.util.LinkedHashMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","LinkedHashMap$LinkedHashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$KeyIterator#this$0


    // ignoring method java.util.LinkedHashMap$KeyIterator#LinkedHashMap$KeyIterator(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$KeyIterator#next()
    // starting method java.util.LinkedHashMap$KeyIterator#LinkedHashMap$KeyIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$KeyIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)");
    method.setSimpleName("LinkedHashMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$KeyIterator#LinkedHashMap$KeyIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)

// finishing type java.util.LinkedHashMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$LinkedHashIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$LinkedHashIterator#nextEntry
	field = newType.addNode(JavaDataField.class,"nextEntry"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$LinkedHashIterator#nextEntry

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$LinkedHashIterator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$LinkedHashIterator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$LinkedHashIterator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$LinkedHashIterator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$LinkedHashIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$LinkedHashIterator#this$0


    // ignoring method java.util.LinkedHashMap$LinkedHashIterator#LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap$LinkedHashIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$LinkedHashIterator#hasNext()
    // starting method java.util.LinkedHashMap$LinkedHashIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$LinkedHashIterator#remove()
    // starting method java.util.LinkedHashMap$LinkedHashIterator#nextEntry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextEntry()");
    method.setSimpleName("nextEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$LinkedHashIterator#nextEntry()
    // starting method java.util.LinkedHashMap$LinkedHashIterator#LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)");
    method.setSimpleName("LinkedHashMap$LinkedHashIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$LinkedHashIterator#LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)

// finishing type java.util.LinkedHashMap$LinkedHashIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","LinkedHashMap$LinkedHashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$ValueIterator#this$0


    // ignoring method java.util.LinkedHashMap$ValueIterator#LinkedHashMap$ValueIterator(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$ValueIterator#next()
    // starting method java.util.LinkedHashMap$ValueIterator#LinkedHashMap$ValueIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$ValueIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)");
    method.setSimpleName("LinkedHashMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$ValueIterator#LinkedHashMap$ValueIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)

// finishing type java.util.LinkedHashMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 

// ignoring field java.util.LinkedHashMap#serialVersionUID 

// ignoring field java.util.LinkedHashMap#header 

// ignoring field java.util.LinkedHashMap#accessOrder 


    // starting method java.util.LinkedHashMap#LinkedHashMap(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap(int, float)");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap(int, float)
    // starting method java.util.LinkedHashMap#LinkedHashMap(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap(int)");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap(int)
    // starting method java.util.LinkedHashMap#LinkedHashMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap()");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap()
    // starting method java.util.LinkedHashMap#LinkedHashMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap(java.util.Map)");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap(java.util.Map)
    // starting method java.util.LinkedHashMap#LinkedHashMap(int, float, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap(int, float, boolean)");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap(int, float, boolean)
    // starting method java.util.LinkedHashMap#init()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"init()");
    method.setSimpleName("init");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#init()
    // starting method java.util.LinkedHashMap#transfer(java.util.HashMap$Entry[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"transfer(java.util.HashMap$Entry[])");
    method.setSimpleName("transfer");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#transfer(java.util.HashMap$Entry[])
    // starting method java.util.LinkedHashMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#containsValue(java.lang.Object)
    // starting method java.util.LinkedHashMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#get(java.lang.Object)
    // starting method java.util.LinkedHashMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#clear()
    // starting method java.util.LinkedHashMap#newKeyIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newKeyIterator()");
    method.setSimpleName("newKeyIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#newKeyIterator()
    // starting method java.util.LinkedHashMap#newValueIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newValueIterator()");
    method.setSimpleName("newValueIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#newValueIterator()
    // starting method java.util.LinkedHashMap#newEntryIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newEntryIterator()");
    method.setSimpleName("newEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#newEntryIterator()
    // starting method java.util.LinkedHashMap#addEntry(int, java.lang.Object, java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addEntry(int, java.lang.Object, java.lang.Object, int)");
    method.setSimpleName("addEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#addEntry(int, java.lang.Object, java.lang.Object, int)
    // starting method java.util.LinkedHashMap#createEntry(int, java.lang.Object, java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"createEntry(int, java.lang.Object, java.lang.Object, int)");
    method.setSimpleName("createEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#createEntry(int, java.lang.Object, java.lang.Object, int)
    // starting method java.util.LinkedHashMap#removeEldestEntry(java.util.Map$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeEldestEntry(java.util.Map$Entry)");
    method.setSimpleName("removeEldestEntry");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#removeEldestEntry(java.util.Map$Entry)
    // starting method java.util.LinkedHashMap#access$000(java.util.LinkedHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.LinkedHashMap)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#access$000(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap#access$100(java.util.LinkedHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.LinkedHashMap)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#access$100(java.util.LinkedHashMap)

// finishing type java.util.LinkedHashMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.LinkedHashSet#serialVersionUID 


    // starting method java.util.LinkedHashSet#LinkedHashSet(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashSet(int, float)");
    method.setSimpleName("LinkedHashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashSet#LinkedHashSet(int, float)
    // starting method java.util.LinkedHashSet#LinkedHashSet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashSet(int)");
    method.setSimpleName("LinkedHashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashSet#LinkedHashSet(int)
    // starting method java.util.LinkedHashSet#LinkedHashSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashSet()");
    method.setSimpleName("LinkedHashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashSet#LinkedHashSet()
    // starting method java.util.LinkedHashSet#LinkedHashSet(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashSet(java.util.Collection)");
    method.setSimpleName("LinkedHashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashSet#LinkedHashSet(java.util.Collection)

// finishing type java.util.LinkedHashSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedList$Entry#element
	field = newType.addNode(JavaDataField.class,"element"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedList$Entry#element

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedList$Entry#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedList$Entry#next

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedList$Entry#previous
	field = newType.addNode(JavaDataField.class,"previous"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedList$Entry#previous


    // starting method java.util.LinkedList$Entry#LinkedList$Entry(java.lang.Object, java.util.LinkedList$Entry, java.util.LinkedList$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedList$Entry(java.lang.Object, java.util.LinkedList$Entry, java.util.LinkedList$Entry)");
    method.setSimpleName("LinkedList$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$Entry#LinkedList$Entry(java.lang.Object, java.util.LinkedList$Entry, java.util.LinkedList$Entry)

// finishing type java.util.LinkedList$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList$ListItr");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

// ignoring field java.util.LinkedList$ListItr#lastReturned 

// ignoring field java.util.LinkedList$ListItr#next 

// ignoring field java.util.LinkedList$ListItr#nextIndex 

// ignoring field java.util.LinkedList$ListItr#expectedModCount 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedList$ListItr#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedList$ListItr#this$0


    // starting method java.util.LinkedList$ListItr#LinkedList$ListItr(java.util.LinkedList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedList$ListItr(java.util.LinkedList, int)");
    method.setSimpleName("LinkedList$ListItr");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#LinkedList$ListItr(java.util.LinkedList, int)
    // starting method java.util.LinkedList$ListItr#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#hasNext()
    // starting method java.util.LinkedList$ListItr#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#next()
    // starting method java.util.LinkedList$ListItr#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#hasPrevious()
    // starting method java.util.LinkedList$ListItr#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#previous()
    // starting method java.util.LinkedList$ListItr#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#nextIndex()
    // starting method java.util.LinkedList$ListItr#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#previousIndex()
    // starting method java.util.LinkedList$ListItr#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#remove()
    // starting method java.util.LinkedList$ListItr#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#set(java.lang.Object)
    // starting method java.util.LinkedList$ListItr#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#add(java.lang.Object)
    // starting method java.util.LinkedList$ListItr#checkForComodification()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkForComodification()");
    method.setSimpleName("checkForComodification");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#checkForComodification()

// finishing type java.util.LinkedList$ListItr
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSequentialList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 
    // starting interface Queue 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Queue");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Queue 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.LinkedList#header 

// ignoring field java.util.LinkedList#size 

// ignoring field java.util.LinkedList#serialVersionUID 


    // starting method java.util.LinkedList#LinkedList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedList()");
    method.setSimpleName("LinkedList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#LinkedList()
    // starting method java.util.LinkedList#LinkedList(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedList(java.util.Collection)");
    method.setSimpleName("LinkedList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#LinkedList(java.util.Collection)
    // starting method java.util.LinkedList#getFirst()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFirst()");
    method.setSimpleName("getFirst");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#getFirst()
    // starting method java.util.LinkedList#getLast()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLast()");
    method.setSimpleName("getLast");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#getLast()
    // starting method java.util.LinkedList#removeFirst()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeFirst()");
    method.setSimpleName("removeFirst");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#removeFirst()
    // starting method java.util.LinkedList#removeLast()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeLast()");
    method.setSimpleName("removeLast");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#removeLast()
    // starting method java.util.LinkedList#addFirst(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addFirst(java.lang.Object)");
    method.setSimpleName("addFirst");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#addFirst(java.lang.Object)
    // starting method java.util.LinkedList#addLast(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addLast(java.lang.Object)");
    method.setSimpleName("addLast");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#addLast(java.lang.Object)
    // starting method java.util.LinkedList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#contains(java.lang.Object)
    // starting method java.util.LinkedList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#size()
    // starting method java.util.LinkedList#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#add(java.lang.Object)
    // starting method java.util.LinkedList#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#remove(java.lang.Object)
    // starting method java.util.LinkedList#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#addAll(java.util.Collection)
    // starting method java.util.LinkedList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#addAll(int, java.util.Collection)
    // starting method java.util.LinkedList#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#clear()
    // starting method java.util.LinkedList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#get(int)
    // starting method java.util.LinkedList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#set(int, java.lang.Object)
    // starting method java.util.LinkedList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#add(int, java.lang.Object)
    // starting method java.util.LinkedList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#remove(int)
    // ignoring method java.util.LinkedList#entry(int)
    // starting method java.util.LinkedList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#indexOf(java.lang.Object)
    // starting method java.util.LinkedList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#lastIndexOf(java.lang.Object)
    // starting method java.util.LinkedList#peek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"peek()");
    method.setSimpleName("peek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#peek()
    // starting method java.util.LinkedList#element()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"element()");
    method.setSimpleName("element");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#element()
    // starting method java.util.LinkedList#poll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"poll()");
    method.setSimpleName("poll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#poll()
    // starting method java.util.LinkedList#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#remove()
    // starting method java.util.LinkedList#offer(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"offer(java.lang.Object)");
    method.setSimpleName("offer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#offer(java.lang.Object)
    // starting method java.util.LinkedList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#listIterator(int)
    // ignoring method java.util.LinkedList#addBefore(java.lang.Object, java.util.LinkedList$Entry)
    // ignoring method java.util.LinkedList#remove(java.util.LinkedList$Entry)
    // starting method java.util.LinkedList#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#clone()
    // starting method java.util.LinkedList#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#toArray()
    // starting method java.util.LinkedList#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#toArray(java.lang.Object[])
    // ignoring method java.util.LinkedList#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.LinkedList#readObject(java.io.ObjectInputStream)
    // starting method java.util.LinkedList#access$000(java.util.LinkedList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.LinkedList)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#access$000(java.util.LinkedList)
    // starting method java.util.LinkedList#access$100(java.util.LinkedList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.LinkedList)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#access$100(java.util.LinkedList)
    // starting method java.util.LinkedList#access$200(java.util.LinkedList, java.util.LinkedList$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.LinkedList, java.util.LinkedList$Entry)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#access$200(java.util.LinkedList, java.util.LinkedList$Entry)
    // starting method java.util.LinkedList#access$300(java.util.LinkedList, java.lang.Object, java.util.LinkedList$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.util.LinkedList, java.lang.Object, java.util.LinkedList$Entry)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#access$300(java.util.LinkedList, java.lang.Object, java.util.LinkedList$Entry)

// finishing type java.util.LinkedList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "List");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 


    // starting method java.util.List#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#size()
    // starting method java.util.List#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#isEmpty()
    // starting method java.util.List#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#contains(java.lang.Object)
    // starting method java.util.List#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#iterator()
    // starting method java.util.List#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#toArray()
    // starting method java.util.List#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#toArray(java.lang.Object[])
    // starting method java.util.List#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#add(java.lang.Object)
    // starting method java.util.List#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#remove(java.lang.Object)
    // starting method java.util.List#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#containsAll(java.util.Collection)
    // starting method java.util.List#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#addAll(java.util.Collection)
    // starting method java.util.List#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#addAll(int, java.util.Collection)
    // starting method java.util.List#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#removeAll(java.util.Collection)
    // starting method java.util.List#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#retainAll(java.util.Collection)
    // starting method java.util.List#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#clear()
    // starting method java.util.List#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#equals(java.lang.Object)
    // starting method java.util.List#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#hashCode()
    // starting method java.util.List#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#get(int)
    // starting method java.util.List#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#set(int, java.lang.Object)
    // starting method java.util.List#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#add(int, java.lang.Object)
    // starting method java.util.List#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#remove(int)
    // starting method java.util.List#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#indexOf(java.lang.Object)
    // starting method java.util.List#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#lastIndexOf(java.lang.Object)
    // starting method java.util.List#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#listIterator()
    // starting method java.util.List#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#listIterator(int)
    // starting method java.util.List#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#subList(int, int)

// finishing type java.util.List
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "ListIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 


    // starting method java.util.ListIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#hasNext()
    // starting method java.util.ListIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#next()
    // starting method java.util.ListIterator#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#hasPrevious()
    // starting method java.util.ListIterator#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#previous()
    // starting method java.util.ListIterator#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#nextIndex()
    // starting method java.util.ListIterator#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#previousIndex()
    // starting method java.util.ListIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#remove()
    // starting method java.util.ListIterator#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#set(java.lang.Object)
    // starting method java.util.ListIterator#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#add(java.lang.Object)

// finishing type java.util.ListIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ListResourceBundle");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ResourceBundle");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.ListResourceBundle#lookup 


    // starting method java.util.ListResourceBundle#ListResourceBundle()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ListResourceBundle()");
    method.setSimpleName("ListResourceBundle");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListResourceBundle#ListResourceBundle()
    // starting method java.util.ListResourceBundle#handleGetObject(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"handleGetObject(java.lang.String)");
    method.setSimpleName("handleGetObject");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListResourceBundle#handleGetObject(java.lang.String)
    // starting method java.util.ListResourceBundle#getKeys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKeys()");
    method.setSimpleName("getKeys");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListResourceBundle#getKeys()
    // starting method java.util.ListResourceBundle#getContents()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getContents()");
    method.setSimpleName("getContents");
    helper.setMethodData(method,1028);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListResourceBundle#getContents()
    // ignoring method java.util.ListResourceBundle#loadLookup()

// finishing type java.util.ListResourceBundle
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Locale");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#ENGLISH
	field = newType.addNode(JavaDataField.class,"ENGLISH"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#ENGLISH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#FRENCH
	field = newType.addNode(JavaDataField.class,"FRENCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#FRENCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#GERMAN
	field = newType.addNode(JavaDataField.class,"GERMAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#GERMAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#ITALIAN
	field = newType.addNode(JavaDataField.class,"ITALIAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#ITALIAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#JAPANESE
	field = newType.addNode(JavaDataField.class,"JAPANESE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#JAPANESE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#KOREAN
	field = newType.addNode(JavaDataField.class,"KOREAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#KOREAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#CHINESE
	field = newType.addNode(JavaDataField.class,"CHINESE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#CHINESE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#SIMPLIFIED_CHINESE
	field = newType.addNode(JavaDataField.class,"SIMPLIFIED_CHINESE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#SIMPLIFIED_CHINESE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#TRADITIONAL_CHINESE
	field = newType.addNode(JavaDataField.class,"TRADITIONAL_CHINESE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#TRADITIONAL_CHINESE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#FRANCE
	field = newType.addNode(JavaDataField.class,"FRANCE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#FRANCE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#GERMANY
	field = newType.addNode(JavaDataField.class,"GERMANY"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#GERMANY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#ITALY
	field = newType.addNode(JavaDataField.class,"ITALY"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#ITALY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#JAPAN
	field = newType.addNode(JavaDataField.class,"JAPAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#JAPAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#KOREA
	field = newType.addNode(JavaDataField.class,"KOREA"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#KOREA

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#CHINA
	field = newType.addNode(JavaDataField.class,"CHINA"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#CHINA

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#PRC
	field = newType.addNode(JavaDataField.class,"PRC"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#PRC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#TAIWAN
	field = newType.addNode(JavaDataField.class,"TAIWAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#TAIWAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#UK
	field = newType.addNode(JavaDataField.class,"UK"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#UK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#US
	field = newType.addNode(JavaDataField.class,"US"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#US

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#CANADA
	field = newType.addNode(JavaDataField.class,"CANADA"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#CANADA

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#CANADA_FRENCH
	field = newType.addNode(JavaDataField.class,"CANADA_FRENCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#CANADA_FRENCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Locale#serialVersionUID

// ignoring field java.util.Locale#language 

// ignoring field java.util.Locale#country 

// ignoring field java.util.Locale#variant 

// ignoring field java.util.Locale#hashcode 

// ignoring field java.util.Locale#hashCodeValue 

// ignoring field java.util.Locale#defaultLocale 

// ignoring field java.util.Locale#isoLanguages 

// ignoring field java.util.Locale#compressedIsoLanguages 

// ignoring field java.util.Locale#isoCountries 

// ignoring field java.util.Locale#compressedIsoCountries 


    // starting method java.util.Locale#Locale(java.lang.String, java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Locale(java.lang.String, java.lang.String, java.lang.String)");
    method.setSimpleName("Locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#Locale(java.lang.String, java.lang.String, java.lang.String)
    // starting method java.util.Locale#Locale(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Locale(java.lang.String, java.lang.String)");
    method.setSimpleName("Locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#Locale(java.lang.String, java.lang.String)
    // starting method java.util.Locale#Locale(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Locale(java.lang.String)");
    method.setSimpleName("Locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#Locale(java.lang.String)
    // starting method java.util.Locale#getDefault()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDefault()");
    method.setSimpleName("getDefault");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDefault()
    // starting method java.util.Locale#setDefault(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setDefault(java.util.Locale)");
    method.setSimpleName("setDefault");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#setDefault(java.util.Locale)
    // starting method java.util.Locale#getAvailableLocales()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getAvailableLocales()");
    method.setSimpleName("getAvailableLocales");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getAvailableLocales()
    // starting method java.util.Locale#getISOCountries()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getISOCountries()");
    method.setSimpleName("getISOCountries");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getISOCountries()
    // starting method java.util.Locale#getISOLanguages()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getISOLanguages()");
    method.setSimpleName("getISOLanguages");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getISOLanguages()
    // starting method java.util.Locale#getLanguage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLanguage()");
    method.setSimpleName("getLanguage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getLanguage()
    // starting method java.util.Locale#getCountry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getCountry()");
    method.setSimpleName("getCountry");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getCountry()
    // starting method java.util.Locale#getVariant()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getVariant()");
    method.setSimpleName("getVariant");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getVariant()
    // starting method java.util.Locale#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#toString()
    // starting method java.util.Locale#getISO3Language()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getISO3Language()");
    method.setSimpleName("getISO3Language");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.util","MissingResourceException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.util.MissingResourceException
    
    // finishing method java.util.Locale#getISO3Language()
    // starting method java.util.Locale#getISO3Country()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getISO3Country()");
    method.setSimpleName("getISO3Country");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.util","MissingResourceException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.util.MissingResourceException
    
    // finishing method java.util.Locale#getISO3Country()
    // starting method java.util.Locale#getDisplayLanguage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayLanguage()");
    method.setSimpleName("getDisplayLanguage");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayLanguage()
    // starting method java.util.Locale#getDisplayLanguage(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayLanguage(java.util.Locale)");
    method.setSimpleName("getDisplayLanguage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayLanguage(java.util.Locale)
    // starting method java.util.Locale#getDisplayCountry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayCountry()");
    method.setSimpleName("getDisplayCountry");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayCountry()
    // starting method java.util.Locale#getDisplayCountry(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayCountry(java.util.Locale)");
    method.setSimpleName("getDisplayCountry");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayCountry(java.util.Locale)
    // starting method java.util.Locale#getDisplayVariant()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayVariant()");
    method.setSimpleName("getDisplayVariant");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayVariant()
    // starting method java.util.Locale#getDisplayVariant(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayVariant(java.util.Locale)");
    method.setSimpleName("getDisplayVariant");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayVariant(java.util.Locale)
    // starting method java.util.Locale#getDisplayName()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName()");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayName()
    // starting method java.util.Locale#getDisplayName(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName(java.util.Locale)");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayName(java.util.Locale)
    // starting method java.util.Locale#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#clone()
    // starting method java.util.Locale#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#hashCode()
    // starting method java.util.Locale#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#equals(java.lang.Object)
    // ignoring method java.util.Locale#getDisplayVariantArray(java.util.ResourceBundle)
    // ignoring method java.util.Locale#formatList(java.lang.String[], java.lang.String[])
    // ignoring method java.util.Locale#composeList(java.text.MessageFormat, java.lang.String[])
    // ignoring method java.util.Locale#readResolve()
    // ignoring method java.util.Locale#toLowerCase(java.lang.String)
    // ignoring method java.util.Locale#toUpperCase(java.lang.String)
    // ignoring method java.util.Locale#findStringMatch(java.lang.String[][], java.lang.String, java.lang.String)
    // ignoring method java.util.Locale#convertOldISOCodes(java.lang.String)

// finishing type java.util.Locale
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Map$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Map$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#getKey()
    // starting method java.util.Map$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#getValue()
    // starting method java.util.Map$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#setValue(java.lang.Object)
    // starting method java.util.Map$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#equals(java.lang.Object)
    // starting method java.util.Map$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#hashCode()

// finishing type java.util.Map$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Map");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Map#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#size()
    // starting method java.util.Map#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#isEmpty()
    // starting method java.util.Map#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#containsKey(java.lang.Object)
    // starting method java.util.Map#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#containsValue(java.lang.Object)
    // starting method java.util.Map#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#get(java.lang.Object)
    // starting method java.util.Map#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Map#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#remove(java.lang.Object)
    // starting method java.util.Map#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#putAll(java.util.Map)
    // starting method java.util.Map#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#clear()
    // starting method java.util.Map#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#keySet()
    // starting method java.util.Map#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#values()
    // starting method java.util.Map#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#entrySet()
    // starting method java.util.Map#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#equals(java.lang.Object)
    // starting method java.util.Map#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#hashCode()

// finishing type java.util.Map
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "MissingFormatArgumentException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.MissingFormatArgumentException#serialVersionUID 

// ignoring field java.util.MissingFormatArgumentException#s 


    // starting method java.util.MissingFormatArgumentException#MissingFormatArgumentException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"MissingFormatArgumentException(java.lang.String)");
    method.setSimpleName("MissingFormatArgumentException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatArgumentException#MissingFormatArgumentException(java.lang.String)
    // starting method java.util.MissingFormatArgumentException#getFormatSpecifier()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFormatSpecifier()");
    method.setSimpleName("getFormatSpecifier");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatArgumentException#getFormatSpecifier()
    // starting method java.util.MissingFormatArgumentException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatArgumentException#getMessage()

// finishing type java.util.MissingFormatArgumentException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "MissingFormatWidthException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.MissingFormatWidthException#serialVersionUID 

// ignoring field java.util.MissingFormatWidthException#s 


    // starting method java.util.MissingFormatWidthException#MissingFormatWidthException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"MissingFormatWidthException(java.lang.String)");
    method.setSimpleName("MissingFormatWidthException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatWidthException#MissingFormatWidthException(java.lang.String)
    // starting method java.util.MissingFormatWidthException#getFormatSpecifier()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFormatSpecifier()");
    method.setSimpleName("getFormatSpecifier");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatWidthException#getFormatSpecifier()
    // starting method java.util.MissingFormatWidthException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatWidthException#getMessage()

// finishing type java.util.MissingFormatWidthException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "MissingResourceException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","RuntimeException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.MissingResourceException#className 

// ignoring field java.util.MissingResourceException#key 


    // starting method java.util.MissingResourceException#MissingResourceException(java.lang.String, java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"MissingResourceException(java.lang.String, java.lang.String, java.lang.String)");
    method.setSimpleName("MissingResourceException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingResourceException#MissingResourceException(java.lang.String, java.lang.String, java.lang.String)
    // starting method java.util.MissingResourceException#getClassName()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getClassName()");
    method.setSimpleName("getClassName");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingResourceException#getClassName()
    // starting method java.util.MissingResourceException#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingResourceException#getKey()

// finishing type java.util.MissingResourceException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "NoSuchElementException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","RuntimeException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.NoSuchElementException#NoSuchElementException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"NoSuchElementException()");
    method.setSimpleName("NoSuchElementException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.NoSuchElementException#NoSuchElementException()
    // starting method java.util.NoSuchElementException#NoSuchElementException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"NoSuchElementException(java.lang.String)");
    method.setSimpleName("NoSuchElementException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.NoSuchElementException#NoSuchElementException(java.lang.String)

// finishing type java.util.NoSuchElementException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Observable");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Observable#changed 

// ignoring field java.util.Observable#obs 


    // starting method java.util.Observable#Observable()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Observable()");
    method.setSimpleName("Observable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#Observable()
    // starting method java.util.Observable#addObserver(java.util.Observer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addObserver(java.util.Observer)");
    method.setSimpleName("addObserver");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#addObserver(java.util.Observer)
    // starting method java.util.Observable#deleteObserver(java.util.Observer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deleteObserver(java.util.Observer)");
    method.setSimpleName("deleteObserver");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#deleteObserver(java.util.Observer)
    // starting method java.util.Observable#notifyObservers()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"notifyObservers()");
    method.setSimpleName("notifyObservers");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#notifyObservers()
    // starting method java.util.Observable#notifyObservers(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"notifyObservers(java.lang.Object)");
    method.setSimpleName("notifyObservers");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#notifyObservers(java.lang.Object)
    // starting method java.util.Observable#deleteObservers()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deleteObservers()");
    method.setSimpleName("deleteObservers");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#deleteObservers()
    // starting method java.util.Observable#setChanged()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setChanged()");
    method.setSimpleName("setChanged");
    helper.setMethodData(method,36);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#setChanged()
    // starting method java.util.Observable#clearChanged()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clearChanged()");
    method.setSimpleName("clearChanged");
    helper.setMethodData(method,36);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#clearChanged()
    // starting method java.util.Observable#hasChanged()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasChanged()");
    method.setSimpleName("hasChanged");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#hasChanged()
    // starting method java.util.Observable#countObservers()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"countObservers()");
    method.setSimpleName("countObservers");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#countObservers()

// finishing type java.util.Observable
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Observer");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Observer#update(java.util.Observable, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"update(java.util.Observable, java.lang.Object)");
    method.setSimpleName("update");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observer#update(java.util.Observable, java.lang.Object)

// finishing type java.util.Observer
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.PriorityQueue$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue$Itr");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.PriorityQueue$Itr#cursor 

// ignoring field java.util.PriorityQueue$Itr#lastRet 

// ignoring field java.util.PriorityQueue$Itr#expectedModCount 

// ignoring field java.util.PriorityQueue$Itr#forgetMeNot 

// ignoring field java.util.PriorityQueue$Itr#lastRetElt 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.PriorityQueue$Itr#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","PriorityQueue");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.PriorityQueue$Itr#this$0


    // ignoring method java.util.PriorityQueue$Itr#PriorityQueue$Itr(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue$Itr#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#hasNext()
    // starting method java.util.PriorityQueue$Itr#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#next()
    // starting method java.util.PriorityQueue$Itr#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#remove()
    // starting method java.util.PriorityQueue$Itr#checkForComodification()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkForComodification()");
    method.setSimpleName("checkForComodification");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#checkForComodification()
    // starting method java.util.PriorityQueue$Itr#PriorityQueue$Itr(java.util.PriorityQueue, java.util.PriorityQueue$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue$Itr(java.util.PriorityQueue, java.util.PriorityQueue$1)");
    method.setSimpleName("PriorityQueue$Itr");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#PriorityQueue$Itr(java.util.PriorityQueue, java.util.PriorityQueue$1)

// finishing type java.util.PriorityQueue$Itr
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractQueue");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.PriorityQueue#serialVersionUID 

// ignoring field java.util.PriorityQueue#DEFAULT_INITIAL_CAPACITY 

// ignoring field java.util.PriorityQueue#queue 

// ignoring field java.util.PriorityQueue#size 

// ignoring field java.util.PriorityQueue#comparator 

// ignoring field java.util.PriorityQueue#modCount 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.PriorityQueue#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.PriorityQueue#$assertionsDisabled


    // starting method java.util.PriorityQueue#PriorityQueue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue()");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue()
    // starting method java.util.PriorityQueue#PriorityQueue(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(int)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(int)
    // starting method java.util.PriorityQueue#PriorityQueue(int, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(int, java.util.Comparator)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(int, java.util.Comparator)
    // ignoring method java.util.PriorityQueue#initializeArray(java.util.Collection)
    // ignoring method java.util.PriorityQueue#fillFromSorted(java.util.Collection)
    // ignoring method java.util.PriorityQueue#fillFromUnsorted(java.util.Collection)
    // starting method java.util.PriorityQueue#PriorityQueue(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(java.util.Collection)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(java.util.Collection)
    // starting method java.util.PriorityQueue#PriorityQueue(java.util.PriorityQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(java.util.PriorityQueue)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue#PriorityQueue(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(java.util.SortedSet)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(java.util.SortedSet)
    // ignoring method java.util.PriorityQueue#grow(int)
    // starting method java.util.PriorityQueue#offer(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"offer(java.lang.Object)");
    method.setSimpleName("offer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#offer(java.lang.Object)
    // starting method java.util.PriorityQueue#peek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"peek()");
    method.setSimpleName("peek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#peek()
    // starting method java.util.PriorityQueue#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#add(java.lang.Object)
    // starting method java.util.PriorityQueue#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#remove(java.lang.Object)
    // starting method java.util.PriorityQueue#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#iterator()
    // starting method java.util.PriorityQueue#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#size()
    // starting method java.util.PriorityQueue#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#clear()
    // starting method java.util.PriorityQueue#poll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"poll()");
    method.setSimpleName("poll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#poll()
    // ignoring method java.util.PriorityQueue#removeAt(int)
    // ignoring method java.util.PriorityQueue#fixUp(int)
    // ignoring method java.util.PriorityQueue#fixDown(int)
    // ignoring method java.util.PriorityQueue#heapify()
    // starting method java.util.PriorityQueue#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#comparator()
    // ignoring method java.util.PriorityQueue#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.PriorityQueue#readObject(java.io.ObjectInputStream)
    // starting method java.util.PriorityQueue#access$100(java.util.PriorityQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.PriorityQueue)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#access$100(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue#access$200(java.util.PriorityQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.PriorityQueue)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#access$200(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue#access$300(java.util.PriorityQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.util.PriorityQueue)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#access$300(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue#access$400(java.util.PriorityQueue, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.PriorityQueue, int)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#access$400(java.util.PriorityQueue, int)

// finishing type java.util.PriorityQueue
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Properties$LineReader");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#inBuf
	field = newType.addNode(JavaDataField.class,"inBuf"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#inBuf

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#lineBuf
	field = newType.addNode(JavaDataField.class,"lineBuf"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#lineBuf

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#inLimit
	field = newType.addNode(JavaDataField.class,"inLimit"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#inLimit

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#inOff
	field = newType.addNode(JavaDataField.class,"inOff"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#inOff

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#inStream
	field = newType.addNode(JavaDataField.class,"inStream"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.io","InputStream");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#inStream

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Properties");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#this$0


    // starting method java.util.Properties$LineReader#Properties$LineReader(java.util.Properties, java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Properties$LineReader(java.util.Properties, java.io.InputStream)");
    method.setSimpleName("Properties$LineReader");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties$LineReader#Properties$LineReader(java.util.Properties, java.io.InputStream)
    // starting method java.util.Properties$LineReader#readLine()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"readLine()");
    method.setSimpleName("readLine");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties$LineReader#readLine()

// finishing type java.util.Properties$LineReader
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Properties");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Hashtable");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Properties#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties#defaults
	field = newType.addNode(JavaDataField.class,"defaults"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Properties");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Properties#defaults

// ignoring field java.util.Properties#hexDigit 


    // starting method java.util.Properties#Properties()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Properties()");
    method.setSimpleName("Properties");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#Properties()
    // starting method java.util.Properties#Properties(java.util.Properties)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Properties(java.util.Properties)");
    method.setSimpleName("Properties");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#Properties(java.util.Properties)
    // starting method java.util.Properties#setProperty(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setProperty(java.lang.String, java.lang.String)");
    method.setSimpleName("setProperty");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#setProperty(java.lang.String, java.lang.String)
    // starting method java.util.Properties#load(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"load(java.io.InputStream)");
    method.setSimpleName("load");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties#load(java.io.InputStream)
    // ignoring method java.util.Properties#loadConvert(char[], int, int, char[])
    // ignoring method java.util.Properties#saveConvert(java.lang.String, boolean)
    // starting method java.util.Properties#save(java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"save(java.io.OutputStream, java.lang.String)");
    method.setSimpleName("save");
    helper.setMethodData(method,131105);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#save(java.io.OutputStream, java.lang.String)
    // starting method java.util.Properties#store(java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"store(java.io.OutputStream, java.lang.String)");
    method.setSimpleName("store");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties#store(java.io.OutputStream, java.lang.String)
    // ignoring method java.util.Properties#writeln(java.io.BufferedWriter, java.lang.String)
    // starting method java.util.Properties#loadFromXML(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"loadFromXML(java.io.InputStream)");
    method.setSimpleName("loadFromXML");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.util","InvalidPropertiesFormatException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.util.InvalidPropertiesFormatException
    
    // finishing method java.util.Properties#loadFromXML(java.io.InputStream)
    // starting method java.util.Properties#storeToXML(java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"storeToXML(java.io.OutputStream, java.lang.String)");
    method.setSimpleName("storeToXML");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties#storeToXML(java.io.OutputStream, java.lang.String)
    // starting method java.util.Properties#storeToXML(java.io.OutputStream, java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"storeToXML(java.io.OutputStream, java.lang.String, java.lang.String)");
    method.setSimpleName("storeToXML");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties#storeToXML(java.io.OutputStream, java.lang.String, java.lang.String)
    // starting method java.util.Properties#getProperty(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getProperty(java.lang.String)");
    method.setSimpleName("getProperty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#getProperty(java.lang.String)
    // starting method java.util.Properties#getProperty(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getProperty(java.lang.String, java.lang.String)");
    method.setSimpleName("getProperty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#getProperty(java.lang.String, java.lang.String)
    // starting method java.util.Properties#propertyNames()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"propertyNames()");
    method.setSimpleName("propertyNames");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#propertyNames()
    // starting method java.util.Properties#list(java.io.PrintStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"list(java.io.PrintStream)");
    method.setSimpleName("list");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#list(java.io.PrintStream)
    // starting method java.util.Properties#list(java.io.PrintWriter)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"list(java.io.PrintWriter)");
    method.setSimpleName("list");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#list(java.io.PrintWriter)
    // ignoring method java.util.Properties#enumerate(java.util.Hashtable)
    // ignoring method java.util.Properties#toHex(int)

// finishing type java.util.Properties
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PropertyPermission");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","BasicPermission");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.PropertyPermission#READ 

// ignoring field java.util.PropertyPermission#WRITE 

// ignoring field java.util.PropertyPermission#ALL 

// ignoring field java.util.PropertyPermission#NONE 

// ignoring field java.util.PropertyPermission#mask 

// ignoring field java.util.PropertyPermission#actions 

// ignoring field java.util.PropertyPermission#serialVersionUID 


    // ignoring method java.util.PropertyPermission#init(int)
    // starting method java.util.PropertyPermission#PropertyPermission(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PropertyPermission(java.lang.String, java.lang.String)");
    method.setSimpleName("PropertyPermission");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#PropertyPermission(java.lang.String, java.lang.String)
    // starting method java.util.PropertyPermission#implies(java.security.Permission)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"implies(java.security.Permission)");
    method.setSimpleName("implies");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#implies(java.security.Permission)
    // starting method java.util.PropertyPermission#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#equals(java.lang.Object)
    // starting method java.util.PropertyPermission#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#hashCode()
    // ignoring method java.util.PropertyPermission#getMask(java.lang.String)
    // starting method java.util.PropertyPermission#getActions(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActions(int)");
    method.setSimpleName("getActions");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#getActions(int)
    // starting method java.util.PropertyPermission#getActions()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActions()");
    method.setSimpleName("getActions");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#getActions()
    // starting method java.util.PropertyPermission#getMask()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMask()");
    method.setSimpleName("getMask");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#getMask()
    // starting method java.util.PropertyPermission#newPermissionCollection()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newPermissionCollection()");
    method.setSimpleName("newPermissionCollection");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.security","PermissionCollection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#newPermissionCollection()
    // ignoring method java.util.PropertyPermission#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.PropertyPermission#readObject(java.io.ObjectInputStream)

// finishing type java.util.PropertyPermission
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PropertyPermissionCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PermissionCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.PropertyPermissionCollection#perms 

// ignoring field java.util.PropertyPermissionCollection#all_allowed 

// ignoring field java.util.PropertyPermissionCollection#serialVersionUID 

// ignoring field java.util.PropertyPermissionCollection#serialPersistentFields 


    // starting method java.util.PropertyPermissionCollection#PropertyPermissionCollection()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PropertyPermissionCollection()");
    method.setSimpleName("PropertyPermissionCollection");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermissionCollection#PropertyPermissionCollection()
    // starting method java.util.PropertyPermissionCollection#add(java.security.Permission)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.security.Permission)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermissionCollection#add(java.security.Permission)
    // starting method java.util.PropertyPermissionCollection#implies(java.security.Permission)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"implies(java.security.Permission)");
    method.setSimpleName("implies");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermissionCollection#implies(java.security.Permission)
    // starting method java.util.PropertyPermissionCollection#elements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elements()");
    method.setSimpleName("elements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermissionCollection#elements()
    // ignoring method java.util.PropertyPermissionCollection#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.PropertyPermissionCollection#readObject(java.io.ObjectInputStream)

// finishing type java.util.PropertyPermissionCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PropertyResourceBundle");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ResourceBundle");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.PropertyResourceBundle#lookup 


    // starting method java.util.PropertyResourceBundle#PropertyResourceBundle(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PropertyResourceBundle(java.io.InputStream)");
    method.setSimpleName("PropertyResourceBundle");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.PropertyResourceBundle#PropertyResourceBundle(java.io.InputStream)
    // starting method java.util.PropertyResourceBundle#handleGetObject(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"handleGetObject(java.lang.String)");
    method.setSimpleName("handleGetObject");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyResourceBundle#handleGetObject(java.lang.String)
    // starting method java.util.PropertyResourceBundle#getKeys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKeys()");
    method.setSimpleName("getKeys");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyResourceBundle#getKeys()

// finishing type java.util.PropertyResourceBundle
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Queue");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 


    // starting method java.util.Queue#offer(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"offer(java.lang.Object)");
    method.setSimpleName("offer");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#offer(java.lang.Object)
    // starting method java.util.Queue#poll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"poll()");
    method.setSimpleName("poll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#poll()
    // starting method java.util.Queue#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#remove()
    // starting method java.util.Queue#peek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"peek()");
    method.setSimpleName("peek");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#peek()
    // starting method java.util.Queue#element()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"element()");
    method.setSimpleName("element");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#element()

// finishing type java.util.Queue
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Random");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Random#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Random#serialVersionUID

// ignoring field java.util.Random#seed 

// ignoring field java.util.Random#multiplier 

// ignoring field java.util.Random#addend 

// ignoring field java.util.Random#mask 

// ignoring field java.util.Random#seedUniquifier 

// ignoring field java.util.Random#BITS_PER_BYTE 

// ignoring field java.util.Random#BYTES_PER_INT 

// ignoring field java.util.Random#nextNextGaussian 

// ignoring field java.util.Random#haveNextNextGaussian 

// ignoring field java.util.Random#serialPersistentFields 


    // starting method java.util.Random#Random()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Random()");
    method.setSimpleName("Random");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#Random()
    // starting method java.util.Random#Random(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Random(long)");
    method.setSimpleName("Random");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#Random(long)
    // starting method java.util.Random#setSeed(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setSeed(long)");
    method.setSimpleName("setSeed");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#setSeed(long)
    // starting method java.util.Random#next(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next(int)");
    method.setSimpleName("next");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#next(int)
    // starting method java.util.Random#nextBytes(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBytes(byte[])");
    method.setSimpleName("nextBytes");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextBytes(byte[])
    // starting method java.util.Random#nextInt()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextInt()");
    method.setSimpleName("nextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextInt()
    // starting method java.util.Random#nextInt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextInt(int)");
    method.setSimpleName("nextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextInt(int)
    // starting method java.util.Random#nextLong()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextLong()");
    method.setSimpleName("nextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextLong()
    // starting method java.util.Random#nextBoolean()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBoolean()");
    method.setSimpleName("nextBoolean");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextBoolean()
    // starting method java.util.Random#nextFloat()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextFloat()");
    method.setSimpleName("nextFloat");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "float");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextFloat()
    // starting method java.util.Random#nextDouble()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextDouble()");
    method.setSimpleName("nextDouble");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextDouble()
    // starting method java.util.Random#nextGaussian()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextGaussian()");
    method.setSimpleName("nextGaussian");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextGaussian()
    // ignoring method java.util.Random#readObject(java.io.ObjectInputStream)
    // ignoring method java.util.Random#writeObject(java.io.ObjectOutputStream)

// finishing type java.util.Random
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "RandomAccess");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.RandomAccess
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "RandomAccessSubList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SubList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 


    // starting method java.util.RandomAccessSubList#RandomAccessSubList(java.util.AbstractList, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"RandomAccessSubList(java.util.AbstractList, int, int)");
    method.setSimpleName("RandomAccessSubList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RandomAccessSubList#RandomAccessSubList(java.util.AbstractList, int, int)
    // starting method java.util.RandomAccessSubList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RandomAccessSubList#subList(int, int)

// finishing type java.util.RandomAccessSubList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "RegularEnumSet$EnumSetIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.RegularEnumSet$EnumSetIterator#unseen
	field = newType.addNode(JavaDataField.class,"unseen"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.RegularEnumSet$EnumSetIterator#unseen

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.RegularEnumSet$EnumSetIterator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.RegularEnumSet$EnumSetIterator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.RegularEnumSet$EnumSetIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","RegularEnumSet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.RegularEnumSet$EnumSetIterator#this$0


    // starting method java.util.RegularEnumSet$EnumSetIterator#RegularEnumSet$EnumSetIterator(java.util.RegularEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"RegularEnumSet$EnumSetIterator(java.util.RegularEnumSet)");
    method.setSimpleName("RegularEnumSet$EnumSetIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#RegularEnumSet$EnumSetIterator(java.util.RegularEnumSet)
    // starting method java.util.RegularEnumSet$EnumSetIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#hasNext()
    // starting method java.util.RegularEnumSet$EnumSetIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Enum");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#next()
    // starting method java.util.RegularEnumSet$EnumSetIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#remove()
    // starting method java.util.RegularEnumSet$EnumSetIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#next()

// finishing type java.util.RegularEnumSet$EnumSetIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "RegularEnumSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.RegularEnumSet#elements 


    // starting method java.util.RegularEnumSet#RegularEnumSet(java.lang.Class, java.lang.Enum[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"RegularEnumSet(java.lang.Class, java.lang.Enum[])");
    method.setSimpleName("RegularEnumSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#RegularEnumSet(java.lang.Class, java.lang.Enum[])
    // starting method java.util.RegularEnumSet#addRange(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addRange(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("addRange");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#addRange(java.lang.Enum, java.lang.Enum)
    // starting method java.util.RegularEnumSet#addAll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll()");
    method.setSimpleName("addAll");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#addAll()
    // starting method java.util.RegularEnumSet#complement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complement()");
    method.setSimpleName("complement");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#complement()
    // starting method java.util.RegularEnumSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#iterator()
    // starting method java.util.RegularEnumSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#size()
    // starting method java.util.RegularEnumSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#isEmpty()
    // starting method java.util.RegularEnumSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#contains(java.lang.Object)
    // starting method java.util.RegularEnumSet#add(java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Enum)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#add(java.lang.Enum)
    // starting method java.util.RegularEnumSet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#remove(java.lang.Object)
    // starting method java.util.RegularEnumSet#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#containsAll(java.util.Collection)
    // starting method java.util.RegularEnumSet#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#addAll(java.util.Collection)
    // starting method java.util.RegularEnumSet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#removeAll(java.util.Collection)
    // starting method java.util.RegularEnumSet#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#retainAll(java.util.Collection)
    // starting method java.util.RegularEnumSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#clear()
    // starting method java.util.RegularEnumSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#equals(java.lang.Object)
    // starting method java.util.RegularEnumSet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#add(java.lang.Object)
    // starting method java.util.RegularEnumSet#access$000(java.util.RegularEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.RegularEnumSet)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#access$000(java.util.RegularEnumSet)
    // starting method java.util.RegularEnumSet#access$022(java.util.RegularEnumSet, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$022(java.util.RegularEnumSet, long)");
    method.setSimpleName("access$022");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#access$022(java.util.RegularEnumSet, long)

// finishing type java.util.RegularEnumSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface PrivilegedAction 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PrivilegedAction");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface PrivilegedAction 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundle$1#val$loader
	field = newType.addNode(JavaDataField.class,"val$loader"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","ClassLoader");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundle$1#val$loader

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundle$1#val$resName
	field = newType.addNode(JavaDataField.class,"val$resName"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundle$1#val$resName


    // starting method java.util.ResourceBundle$1#ResourceBundle$1(java.lang.ClassLoader, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundle$1(java.lang.ClassLoader, java.lang.String)");
    method.setSimpleName("ResourceBundle$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$1#ResourceBundle$1(java.lang.ClassLoader, java.lang.String)
    // starting method java.util.ResourceBundle$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$1#run()

// finishing type java.util.ResourceBundle$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$LoaderReference");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang.ref","WeakReference");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.ResourceBundle$LoaderReference#cacheKey 


    // starting method java.util.ResourceBundle$LoaderReference#ResourceBundle$LoaderReference(java.lang.Object, java.lang.ref.ReferenceQueue, java.util.ResourceBundle$ResourceCacheKey)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundle$LoaderReference(java.lang.Object, java.lang.ref.ReferenceQueue, java.util.ResourceBundle$ResourceCacheKey)");
    method.setSimpleName("ResourceBundle$LoaderReference");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$LoaderReference#ResourceBundle$LoaderReference(java.lang.Object, java.lang.ref.ReferenceQueue, java.util.ResourceBundle$ResourceCacheKey)
    // starting method java.util.ResourceBundle$LoaderReference#getCacheKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getCacheKey()");
    method.setSimpleName("getCacheKey");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle$ResourceCacheKey");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$LoaderReference#getCacheKey()

// finishing type java.util.ResourceBundle$LoaderReference
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$ResourceCacheKey");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 

// ignoring field java.util.ResourceBundle$ResourceCacheKey#loaderRef 

// ignoring field java.util.ResourceBundle$ResourceCacheKey#searchName 

// ignoring field java.util.ResourceBundle$ResourceCacheKey#defaultLocale 

// ignoring field java.util.ResourceBundle$ResourceCacheKey#hashCodeCache 


    // ignoring method java.util.ResourceBundle$ResourceCacheKey#ResourceBundle$ResourceCacheKey()
    // starting method java.util.ResourceBundle$ResourceCacheKey#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#equals(java.lang.Object)
    // starting method java.util.ResourceBundle$ResourceCacheKey#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#hashCode()
    // starting method java.util.ResourceBundle$ResourceCacheKey#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#clone()
    // starting method java.util.ResourceBundle$ResourceCacheKey#setKeyValues(java.lang.ClassLoader, java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setKeyValues(java.lang.ClassLoader, java.lang.String, java.util.Locale)");
    method.setSimpleName("setKeyValues");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#setKeyValues(java.lang.ClassLoader, java.lang.String, java.util.Locale)
    // starting method java.util.ResourceBundle$ResourceCacheKey#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#clear()
    // starting method java.util.ResourceBundle$ResourceCacheKey#ResourceBundle$ResourceCacheKey(java.util.ResourceBundle$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundle$ResourceCacheKey(java.util.ResourceBundle$1)");
    method.setSimpleName("ResourceBundle$ResourceCacheKey");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#ResourceBundle$ResourceCacheKey(java.util.ResourceBundle$1)

// finishing type java.util.ResourceBundle$ResourceCacheKey
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.ResourceBundle#cacheKey 

// ignoring field java.util.ResourceBundle#INITIAL_CACHE_SIZE 

// ignoring field java.util.ResourceBundle#CACHE_LOAD_FACTOR 

// ignoring field java.util.ResourceBundle#MAX_BUNDLES_SEARCHED 

// ignoring field java.util.ResourceBundle#underConstruction 

// ignoring field java.util.ResourceBundle#NOT_FOUND 

// ignoring field java.util.ResourceBundle#cacheList 

// ignoring field java.util.ResourceBundle#referenceQueue 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundle#parent
	field = newType.addNode(JavaDataField.class,"parent"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundle#parent

// ignoring field java.util.ResourceBundle#locale 


    // starting method java.util.ResourceBundle#ResourceBundle()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundle()");
    method.setSimpleName("ResourceBundle");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#ResourceBundle()
    // starting method java.util.ResourceBundle#getString(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getString(java.lang.String)");
    method.setSimpleName("getString");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getString(java.lang.String)
    // starting method java.util.ResourceBundle#getStringArray(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getStringArray(java.lang.String)");
    method.setSimpleName("getStringArray");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getStringArray(java.lang.String)
    // starting method java.util.ResourceBundle#getObject(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getObject(java.lang.String)");
    method.setSimpleName("getObject");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getObject(java.lang.String)
    // starting method java.util.ResourceBundle#getLocale()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLocale()");
    method.setSimpleName("getLocale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getLocale()
    // ignoring method java.util.ResourceBundle#setLocale(java.lang.String, java.lang.String)
    // ignoring method java.util.ResourceBundle#getLoader()
    // ignoring method java.util.ResourceBundle#getClassContext()
    // starting method java.util.ResourceBundle#setParent(java.util.ResourceBundle)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setParent(java.util.ResourceBundle)");
    method.setSimpleName("setParent");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#setParent(java.util.ResourceBundle)
    // starting method java.util.ResourceBundle#getBundle(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getBundle(java.lang.String)");
    method.setSimpleName("getBundle");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getBundle(java.lang.String)
    // starting method java.util.ResourceBundle#getBundle(java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getBundle(java.lang.String, java.util.Locale)");
    method.setSimpleName("getBundle");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getBundle(java.lang.String, java.util.Locale)
    // starting method java.util.ResourceBundle#getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)");
    method.setSimpleName("getBundle");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
    // ignoring method java.util.ResourceBundle#getBundleImpl(java.lang.String, java.util.Locale, java.lang.ClassLoader)
    // ignoring method java.util.ResourceBundle#propagate(java.lang.ClassLoader, java.util.Vector, java.util.Vector, java.util.Locale, java.lang.Object)
    // ignoring method java.util.ResourceBundle#throwMissingResourceException(java.lang.String, java.util.Locale)
    // ignoring method java.util.ResourceBundle#cleanUpConstructionList()
    // ignoring method java.util.ResourceBundle#findBundle(java.lang.ClassLoader, java.lang.String, java.util.Locale, java.lang.String, java.lang.Object)
    // ignoring method java.util.ResourceBundle#calculateBundleNames(java.lang.String, java.util.Locale)
    // ignoring method java.util.ResourceBundle#findBundleInCache(java.lang.ClassLoader, java.lang.String, java.util.Locale)
    // ignoring method java.util.ResourceBundle#putBundleInCache(java.lang.ClassLoader, java.lang.String, java.util.Locale, java.lang.Object)
    // ignoring method java.util.ResourceBundle#loadBundle(java.lang.ClassLoader, java.lang.String, java.util.Locale)
    // starting method java.util.ResourceBundle#handleGetObject(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"handleGetObject(java.lang.String)");
    method.setSimpleName("handleGetObject");
    helper.setMethodData(method,1028);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#handleGetObject(java.lang.String)
    // starting method java.util.ResourceBundle#getKeys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKeys()");
    method.setSimpleName("getKeys");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getKeys()
    // starting method java.util.ResourceBundle#access$100()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100()");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang.ref","ReferenceQueue");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#access$100()

// finishing type java.util.ResourceBundle
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundleEnumeration");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundleEnumeration#set
	field = newType.addNode(JavaDataField.class,"set"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundleEnumeration#set

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundleEnumeration#iterator
	field = newType.addNode(JavaDataField.class,"iterator"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundleEnumeration#iterator

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundleEnumeration#enumeration
	field = newType.addNode(JavaDataField.class,"enumeration"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundleEnumeration#enumeration

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundleEnumeration#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundleEnumeration#next


    // starting method java.util.ResourceBundleEnumeration#ResourceBundleEnumeration(java.util.Set, java.util.Enumeration)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundleEnumeration(java.util.Set, java.util.Enumeration)");
    method.setSimpleName("ResourceBundleEnumeration");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundleEnumeration#ResourceBundleEnumeration(java.util.Set, java.util.Enumeration)
    // starting method java.util.ResourceBundleEnumeration#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundleEnumeration#hasMoreElements()
    // starting method java.util.ResourceBundleEnumeration#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundleEnumeration#nextElement()
    // starting method java.util.ResourceBundleEnumeration#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundleEnumeration#nextElement()

// finishing type java.util.ResourceBundleEnumeration
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Scanner$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"sun.misc","LRUCache");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Scanner$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Scanner$1#this$0


    // starting method java.util.Scanner$1#Scanner$1(java.util.Scanner, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner$1(java.util.Scanner, int)");
    method.setSimpleName("Scanner$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#Scanner$1(java.util.Scanner, int)
    // starting method java.util.Scanner$1#create(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"create(java.lang.String)");
    method.setSimpleName("create");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util.regex","Pattern");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#create(java.lang.String)
    // starting method java.util.Scanner$1#hasName(java.util.regex.Pattern, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasName(java.util.regex.Pattern, java.lang.String)");
    method.setSimpleName("hasName");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#hasName(java.util.regex.Pattern, java.lang.String)
    // starting method java.util.Scanner$1#hasName(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasName(java.lang.Object, java.lang.Object)");
    method.setSimpleName("hasName");
    helper.setMethodData(method,4164);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#hasName(java.lang.Object, java.lang.Object)
    // starting method java.util.Scanner$1#create(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"create(java.lang.Object)");
    method.setSimpleName("create");
    helper.setMethodData(method,4164);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#create(java.lang.Object)

// finishing type java.util.Scanner$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Scanner");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.Scanner#buf 

// ignoring field java.util.Scanner#BUFFER_SIZE 

// ignoring field java.util.Scanner#position 

// ignoring field java.util.Scanner#matcher 

// ignoring field java.util.Scanner#delimPattern 

// ignoring field java.util.Scanner#hasNextPattern 

// ignoring field java.util.Scanner#hasNextPosition 

// ignoring field java.util.Scanner#hasNextResult 

// ignoring field java.util.Scanner#source 

// ignoring field java.util.Scanner#sourceClosed 

// ignoring field java.util.Scanner#needInput 

// ignoring field java.util.Scanner#skipped 

// ignoring field java.util.Scanner#savedScannerPosition 

// ignoring field java.util.Scanner#typeCache 

// ignoring field java.util.Scanner#matchValid 

// ignoring field java.util.Scanner#closed 

// ignoring field java.util.Scanner#radix 

// ignoring field java.util.Scanner#defaultRadix 

// ignoring field java.util.Scanner#locale 

// ignoring field java.util.Scanner#patternCache 

// ignoring field java.util.Scanner#lastException 

// ignoring field java.util.Scanner#WHITESPACE_PATTERN 

// ignoring field java.util.Scanner#FIND_ANY_PATTERN 

// ignoring field java.util.Scanner#NON_ASCII_DIGIT 

// ignoring field java.util.Scanner#groupSeparator 

// ignoring field java.util.Scanner#decimalSeparator 

// ignoring field java.util.Scanner#nanString 

// ignoring field java.util.Scanner#infinityString 

// ignoring field java.util.Scanner#positivePrefix 

// ignoring field java.util.Scanner#negativePrefix 

// ignoring field java.util.Scanner#positiveSuffix 

// ignoring field java.util.Scanner#negativeSuffix 

// ignoring field java.util.Scanner#boolPattern 

// ignoring field java.util.Scanner#BOOLEAN_PATTERN 

// ignoring field java.util.Scanner#integerPattern 

// ignoring field java.util.Scanner#digits 

// ignoring field java.util.Scanner#non0Digit 

// ignoring field java.util.Scanner#SIMPLE_GROUP_INDEX 

// ignoring field java.util.Scanner#separatorPattern 

// ignoring field java.util.Scanner#LINE_SEPARATOR_PATTERN 

// ignoring field java.util.Scanner#floatPattern 

// ignoring field java.util.Scanner#decimalPattern 


    // ignoring method java.util.Scanner#boolPattern()
    // ignoring method java.util.Scanner#buildIntegerPatternString()
    // ignoring method java.util.Scanner#integerPattern()
    // ignoring method java.util.Scanner#separatorPattern()
    // ignoring method java.util.Scanner#buildFloatAndDecimalPattern()
    // ignoring method java.util.Scanner#floatPattern()
    // ignoring method java.util.Scanner#decimalPattern()
    // ignoring method java.util.Scanner#Scanner(java.lang.Readable, java.util.regex.Pattern)
    // starting method java.util.Scanner#Scanner(java.lang.Readable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.lang.Readable)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.lang.Readable)
    // starting method java.util.Scanner#Scanner(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.io.InputStream)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.io.InputStream)
    // starting method java.util.Scanner#Scanner(java.io.InputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.io.InputStream, java.lang.String)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.io.InputStream, java.lang.String)
    // ignoring method java.util.Scanner#makeReadable(java.io.InputStream, java.lang.String)
    // starting method java.util.Scanner#Scanner(java.io.File)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.io.File)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
    
    // finishing method java.util.Scanner#Scanner(java.io.File)
    // starting method java.util.Scanner#Scanner(java.io.File, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.io.File, java.lang.String)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
    
    // finishing method java.util.Scanner#Scanner(java.io.File, java.lang.String)
    // starting method java.util.Scanner#Scanner(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.lang.String)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.lang.String)
    // starting method java.util.Scanner#Scanner(java.nio.channels.ReadableByteChannel)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.nio.channels.ReadableByteChannel)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.nio.channels.ReadableByteChannel)
    // ignoring method java.util.Scanner#makeReadable(java.nio.channels.ReadableByteChannel)
    // starting method java.util.Scanner#Scanner(java.nio.channels.ReadableByteChannel, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.nio.channels.ReadableByteChannel, java.lang.String)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.nio.channels.ReadableByteChannel, java.lang.String)
    // ignoring method java.util.Scanner#makeReadable(java.nio.channels.ReadableByteChannel, java.lang.String)
    // ignoring method java.util.Scanner#saveState()
    // ignoring method java.util.Scanner#revertState()
    // ignoring method java.util.Scanner#revertState(boolean)
    // ignoring method java.util.Scanner#cacheResult(java.util.regex.Pattern)
    // ignoring method java.util.Scanner#clearCaches()
    // ignoring method java.util.Scanner#getCachedResult()
    // ignoring method java.util.Scanner#useTypeCache()
    // ignoring method java.util.Scanner#readInput()
    // ignoring method java.util.Scanner#makeSpace()
    // ignoring method java.util.Scanner#translateSavedIndexes(int)
    // ignoring method java.util.Scanner#throwFor()
    // ignoring method java.util.Scanner#hasTokenInBuffer()
    // ignoring method java.util.Scanner#getCompleteTokenInBuffer(java.util.regex.Pattern)
    // ignoring method java.util.Scanner#findPatternInBuffer(java.util.regex.Pattern, int)
    // ignoring method java.util.Scanner#matchPatternInBuffer(java.util.regex.Pattern)
    // ignoring method java.util.Scanner#ensureOpen()
    // starting method java.util.Scanner#close()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"close()");
    method.setSimpleName("close");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#close()
    // starting method java.util.Scanner#ioException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"ioException()");
    method.setSimpleName("ioException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#ioException()
    // starting method java.util.Scanner#delimiter()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"delimiter()");
    method.setSimpleName("delimiter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util.regex","Pattern");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#delimiter()
    // starting method java.util.Scanner#useDelimiter(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useDelimiter(java.util.regex.Pattern)");
    method.setSimpleName("useDelimiter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#useDelimiter(java.util.regex.Pattern)
    // starting method java.util.Scanner#useDelimiter(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useDelimiter(java.lang.String)");
    method.setSimpleName("useDelimiter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#useDelimiter(java.lang.String)
    // starting method java.util.Scanner#locale()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"locale()");
    method.setSimpleName("locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#locale()
    // starting method java.util.Scanner#useLocale(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useLocale(java.util.Locale)");
    method.setSimpleName("useLocale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#useLocale(java.util.Locale)
    // starting method java.util.Scanner#radix()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"radix()");
    method.setSimpleName("radix");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#radix()
    // starting method java.util.Scanner#useRadix(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useRadix(int)");
    method.setSimpleName("useRadix");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#useRadix(int)
    // ignoring method java.util.Scanner#setRadix(int)
    // starting method java.util.Scanner#match()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"match()");
    method.setSimpleName("match");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util.regex","MatchResult");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#match()
    // starting method java.util.Scanner#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#toString()
    // starting method java.util.Scanner#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNext()
    // starting method java.util.Scanner#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#next()
    // starting method java.util.Scanner#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#remove()
    // starting method java.util.Scanner#hasNext(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext(java.lang.String)");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNext(java.lang.String)
    // starting method java.util.Scanner#next(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next(java.lang.String)");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#next(java.lang.String)
    // starting method java.util.Scanner#hasNext(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext(java.util.regex.Pattern)");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNext(java.util.regex.Pattern)
    // starting method java.util.Scanner#next(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next(java.util.regex.Pattern)");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#next(java.util.regex.Pattern)
    // starting method java.util.Scanner#hasNextLine()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextLine()");
    method.setSimpleName("hasNextLine");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextLine()
    // starting method java.util.Scanner#nextLine()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextLine()");
    method.setSimpleName("nextLine");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextLine()
    // starting method java.util.Scanner#findInLine(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"findInLine(java.lang.String)");
    method.setSimpleName("findInLine");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#findInLine(java.lang.String)
    // starting method java.util.Scanner#findInLine(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"findInLine(java.util.regex.Pattern)");
    method.setSimpleName("findInLine");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#findInLine(java.util.regex.Pattern)
    // starting method java.util.Scanner#findWithinHorizon(java.lang.String, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"findWithinHorizon(java.lang.String, int)");
    method.setSimpleName("findWithinHorizon");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#findWithinHorizon(java.lang.String, int)
    // starting method java.util.Scanner#findWithinHorizon(java.util.regex.Pattern, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"findWithinHorizon(java.util.regex.Pattern, int)");
    method.setSimpleName("findWithinHorizon");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#findWithinHorizon(java.util.regex.Pattern, int)
    // starting method java.util.Scanner#skip(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"skip(java.util.regex.Pattern)");
    method.setSimpleName("skip");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#skip(java.util.regex.Pattern)
    // starting method java.util.Scanner#skip(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"skip(java.lang.String)");
    method.setSimpleName("skip");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#skip(java.lang.String)
    // starting method java.util.Scanner#hasNextBoolean()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextBoolean()");
    method.setSimpleName("hasNextBoolean");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextBoolean()
    // starting method java.util.Scanner#nextBoolean()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBoolean()");
    method.setSimpleName("nextBoolean");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextBoolean()
    // starting method java.util.Scanner#hasNextByte()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextByte()");
    method.setSimpleName("hasNextByte");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextByte()
    // starting method java.util.Scanner#hasNextByte(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextByte(int)");
    method.setSimpleName("hasNextByte");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextByte(int)
    // starting method java.util.Scanner#nextByte()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextByte()");
    method.setSimpleName("nextByte");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "byte");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextByte()
    // starting method java.util.Scanner#nextByte(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextByte(int)");
    method.setSimpleName("nextByte");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "byte");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextByte(int)
    // starting method java.util.Scanner#hasNextShort()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextShort()");
    method.setSimpleName("hasNextShort");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextShort()
    // starting method java.util.Scanner#hasNextShort(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextShort(int)");
    method.setSimpleName("hasNextShort");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextShort(int)
    // starting method java.util.Scanner#nextShort()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextShort()");
    method.setSimpleName("nextShort");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "short");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextShort()
    // starting method java.util.Scanner#nextShort(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextShort(int)");
    method.setSimpleName("nextShort");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "short");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextShort(int)
    // starting method java.util.Scanner#hasNextInt()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextInt()");
    method.setSimpleName("hasNextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextInt()
    // starting method java.util.Scanner#hasNextInt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextInt(int)");
    method.setSimpleName("hasNextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextInt(int)
    // ignoring method java.util.Scanner#processIntegerToken(java.lang.String)
    // starting method java.util.Scanner#nextInt()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextInt()");
    method.setSimpleName("nextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextInt()
    // starting method java.util.Scanner#nextInt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextInt(int)");
    method.setSimpleName("nextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextInt(int)
    // starting method java.util.Scanner#hasNextLong()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextLong()");
    method.setSimpleName("hasNextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextLong()
    // starting method java.util.Scanner#hasNextLong(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextLong(int)");
    method.setSimpleName("hasNextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextLong(int)
    // starting method java.util.Scanner#nextLong()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextLong()");
    method.setSimpleName("nextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextLong()
    // starting method java.util.Scanner#nextLong(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextLong(int)");
    method.setSimpleName("nextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextLong(int)
    // ignoring method java.util.Scanner#processFloatToken(java.lang.String)
    // starting method java.util.Scanner#hasNextFloat()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextFloat()");
    method.setSimpleName("hasNextFloat");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextFloat()
    // starting method java.util.Scanner#nextFloat()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextFloat()");
    method.setSimpleName("nextFloat");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "float");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextFloat()
    // starting method java.util.Scanner#hasNextDouble()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextDouble()");
    method.setSimpleName("hasNextDouble");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextDouble()
    // starting method java.util.Scanner#nextDouble()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextDouble()");
    method.setSimpleName("nextDouble");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextDouble()
    // starting method java.util.Scanner#hasNextBigInteger()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextBigInteger()");
    method.setSimpleName("hasNextBigInteger");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextBigInteger()
    // starting method java.util.Scanner#hasNextBigInteger(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextBigInteger(int)");
    method.setSimpleName("hasNextBigInteger");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextBigInteger(int)
    // starting method java.util.Scanner#nextBigInteger()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBigInteger()");
    method.setSimpleName("nextBigInteger");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.math","BigInteger");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextBigInteger()
    // starting method java.util.Scanner#nextBigInteger(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBigInteger(int)");
    method.setSimpleName("nextBigInteger");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.math","BigInteger");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextBigInteger(int)
    // starting method java.util.Scanner#hasNextBigDecimal()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextBigDecimal()");
    method.setSimpleName("hasNextBigDecimal");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextBigDecimal()
    // starting method java.util.Scanner#nextBigDecimal()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBigDecimal()");
    method.setSimpleName("nextBigDecimal");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.math","BigDecimal");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextBigDecimal()
    // starting method java.util.Scanner#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#next()

// finishing type java.util.Scanner
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Set");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 


    // starting method java.util.Set#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#size()
    // starting method java.util.Set#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#isEmpty()
    // starting method java.util.Set#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#contains(java.lang.Object)
    // starting method java.util.Set#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#iterator()
    // starting method java.util.Set#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#toArray()
    // starting method java.util.Set#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#toArray(java.lang.Object[])
    // starting method java.util.Set#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#add(java.lang.Object)
    // starting method java.util.Set#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#remove(java.lang.Object)
    // starting method java.util.Set#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#containsAll(java.util.Collection)
    // starting method java.util.Set#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#addAll(java.util.Collection)
    // starting method java.util.Set#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#retainAll(java.util.Collection)
    // starting method java.util.Set#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#removeAll(java.util.Collection)
    // starting method java.util.Set#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#clear()
    // starting method java.util.Set#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#equals(java.lang.Object)
    // starting method java.util.Set#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#hashCode()

// finishing type java.util.Set
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "SimpleTimeZone");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TimeZone");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.SimpleTimeZone#startMonth 

// ignoring field java.util.SimpleTimeZone#startDay 

// ignoring field java.util.SimpleTimeZone#startDayOfWeek 

// ignoring field java.util.SimpleTimeZone#startTime 

// ignoring field java.util.SimpleTimeZone#startTimeMode 

// ignoring field java.util.SimpleTimeZone#endMonth 

// ignoring field java.util.SimpleTimeZone#endDay 

// ignoring field java.util.SimpleTimeZone#endDayOfWeek 

// ignoring field java.util.SimpleTimeZone#endTime 

// ignoring field java.util.SimpleTimeZone#endTimeMode 

// ignoring field java.util.SimpleTimeZone#startYear 

// ignoring field java.util.SimpleTimeZone#rawOffset 

// ignoring field java.util.SimpleTimeZone#useDaylight 

// ignoring field java.util.SimpleTimeZone#millisPerHour 

// ignoring field java.util.SimpleTimeZone#millisPerDay 

// ignoring field java.util.SimpleTimeZone#monthLength 

// ignoring field java.util.SimpleTimeZone#staticMonthLength 

// ignoring field java.util.SimpleTimeZone#staticLeapMonthLength 

// ignoring field java.util.SimpleTimeZone#startMode 

// ignoring field java.util.SimpleTimeZone#endMode 

// ignoring field java.util.SimpleTimeZone#dstSavings 

// ignoring field java.util.SimpleTimeZone#gcal 

// ignoring field java.util.SimpleTimeZone#cacheYear 

// ignoring field java.util.SimpleTimeZone#cacheStart 

// ignoring field java.util.SimpleTimeZone#cacheEnd 

// ignoring field java.util.SimpleTimeZone#DOM_MODE 

// ignoring field java.util.SimpleTimeZone#DOW_IN_MONTH_MODE 

// ignoring field java.util.SimpleTimeZone#DOW_GE_DOM_MODE 

// ignoring field java.util.SimpleTimeZone#DOW_LE_DOM_MODE 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#WALL_TIME
	field = newType.addNode(JavaDataField.class,"WALL_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#WALL_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#STANDARD_TIME
	field = newType.addNode(JavaDataField.class,"STANDARD_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#STANDARD_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#UTC_TIME
	field = newType.addNode(JavaDataField.class,"UTC_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#UTC_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#currentSerialVersion
	field = newType.addNode(JavaDataField.class,"currentSerialVersion"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#currentSerialVersion

// ignoring field java.util.SimpleTimeZone#serialVersionOnStream 


    // starting method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SimpleTimeZone(int, java.lang.String)");
    method.setSimpleName("SimpleTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String)
    // starting method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int)");
    method.setSimpleName("SimpleTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int)
    // starting method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int)");
    method.setSimpleName("SimpleTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int)
    // starting method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int, int, int)");
    method.setSimpleName("SimpleTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int, int, int)
    // starting method java.util.SimpleTimeZone#setStartYear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setStartYear(int)");
    method.setSimpleName("setStartYear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setStartYear(int)
    // starting method java.util.SimpleTimeZone#setStartRule(int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setStartRule(int, int, int, int)");
    method.setSimpleName("setStartRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setStartRule(int, int, int, int)
    // starting method java.util.SimpleTimeZone#setStartRule(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setStartRule(int, int, int)");
    method.setSimpleName("setStartRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setStartRule(int, int, int)
    // starting method java.util.SimpleTimeZone#setStartRule(int, int, int, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setStartRule(int, int, int, int, boolean)");
    method.setSimpleName("setStartRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setStartRule(int, int, int, int, boolean)
    // starting method java.util.SimpleTimeZone#setEndRule(int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setEndRule(int, int, int, int)");
    method.setSimpleName("setEndRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setEndRule(int, int, int, int)
    // starting method java.util.SimpleTimeZone#setEndRule(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setEndRule(int, int, int)");
    method.setSimpleName("setEndRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setEndRule(int, int, int)
    // starting method java.util.SimpleTimeZone#setEndRule(int, int, int, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setEndRule(int, int, int, int, boolean)");
    method.setSimpleName("setEndRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setEndRule(int, int, int, int, boolean)
    // starting method java.util.SimpleTimeZone#getOffset(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffset(long)");
    method.setSimpleName("getOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getOffset(long)
    // starting method java.util.SimpleTimeZone#getOffsets(long, int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffsets(long, int[])");
    method.setSimpleName("getOffsets");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getOffsets(long, int[])
    // starting method java.util.SimpleTimeZone#getOffset(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffset(int, int, int, int, int, int)");
    method.setSimpleName("getOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getOffset(int, int, int, int, int, int)
    // ignoring method java.util.SimpleTimeZone#getOffset(sun.util.calendar.BaseCalendar, sun.util.calendar.BaseCalendar$Date, int, long)
    // ignoring method java.util.SimpleTimeZone#getStart(sun.util.calendar.BaseCalendar, sun.util.calendar.BaseCalendar$Date, int)
    // ignoring method java.util.SimpleTimeZone#getEnd(sun.util.calendar.BaseCalendar, sun.util.calendar.BaseCalendar$Date, int)
    // ignoring method java.util.SimpleTimeZone#getTransition(sun.util.calendar.BaseCalendar, sun.util.calendar.BaseCalendar$Date, int, int, int, int, int, int)
    // starting method java.util.SimpleTimeZone#getRawOffset()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getRawOffset()");
    method.setSimpleName("getRawOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getRawOffset()
    // starting method java.util.SimpleTimeZone#setRawOffset(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setRawOffset(int)");
    method.setSimpleName("setRawOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setRawOffset(int)
    // starting method java.util.SimpleTimeZone#setDSTSavings(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setDSTSavings(int)");
    method.setSimpleName("setDSTSavings");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setDSTSavings(int)
    // starting method java.util.SimpleTimeZone#getDSTSavings()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDSTSavings()");
    method.setSimpleName("getDSTSavings");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getDSTSavings()
    // starting method java.util.SimpleTimeZone#useDaylightTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useDaylightTime()");
    method.setSimpleName("useDaylightTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#useDaylightTime()
    // starting method java.util.SimpleTimeZone#inDaylightTime(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"inDaylightTime(java.util.Date)");
    method.setSimpleName("inDaylightTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#inDaylightTime(java.util.Date)
    // starting method java.util.SimpleTimeZone#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#clone()
    // starting method java.util.SimpleTimeZone#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#hashCode()
    // starting method java.util.SimpleTimeZone#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#equals(java.lang.Object)
    // starting method java.util.SimpleTimeZone#hasSameRules(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasSameRules(java.util.TimeZone)");
    method.setSimpleName("hasSameRules");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#hasSameRules(java.util.TimeZone)
    // starting method java.util.SimpleTimeZone#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#toString()
    // ignoring method java.util.SimpleTimeZone#invalidateCache()
    // ignoring method java.util.SimpleTimeZone#decodeRules()
    // ignoring method java.util.SimpleTimeZone#decodeStartRule()
    // ignoring method java.util.SimpleTimeZone#decodeEndRule()
    // ignoring method java.util.SimpleTimeZone#makeRulesCompatible()
    // ignoring method java.util.SimpleTimeZone#packRules()
    // ignoring method java.util.SimpleTimeZone#unpackRules(byte[])
    // ignoring method java.util.SimpleTimeZone#packTimes()
    // ignoring method java.util.SimpleTimeZone#unpackTimes(int[])
    // ignoring method java.util.SimpleTimeZone#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.SimpleTimeZone#readObject(java.io.ObjectInputStream)

// finishing type java.util.SimpleTimeZone
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "SortedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 


    // starting method java.util.SortedMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#comparator()
    // starting method java.util.SortedMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.SortedMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#headMap(java.lang.Object)
    // starting method java.util.SortedMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#tailMap(java.lang.Object)
    // starting method java.util.SortedMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#firstKey()
    // starting method java.util.SortedMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#lastKey()

// finishing type java.util.SortedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "SortedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 


    // starting method java.util.SortedSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#comparator()
    // starting method java.util.SortedSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.SortedSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#headSet(java.lang.Object)
    // starting method java.util.SortedSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#tailSet(java.lang.Object)
    // starting method java.util.SortedSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#first()
    // starting method java.util.SortedSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#last()

// finishing type java.util.SortedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Stack");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Vector");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Stack#serialVersionUID 


    // starting method java.util.Stack#Stack()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Stack()");
    method.setSimpleName("Stack");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#Stack()
    // starting method java.util.Stack#push(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"push(java.lang.Object)");
    method.setSimpleName("push");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#push(java.lang.Object)
    // starting method java.util.Stack#pop()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"pop()");
    method.setSimpleName("pop");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#pop()
    // starting method java.util.Stack#peek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"peek()");
    method.setSimpleName("peek");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#peek()
    // starting method java.util.Stack#empty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"empty()");
    method.setSimpleName("empty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#empty()
    // starting method java.util.Stack#search(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"search(java.lang.Object)");
    method.setSimpleName("search");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#search(java.lang.Object)

// finishing type java.util.Stack
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "StringTokenizer");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 

// ignoring field java.util.StringTokenizer#currentPosition 

// ignoring field java.util.StringTokenizer#newPosition 

// ignoring field java.util.StringTokenizer#maxPosition 

// ignoring field java.util.StringTokenizer#str 

// ignoring field java.util.StringTokenizer#delimiters 

// ignoring field java.util.StringTokenizer#retDelims 

// ignoring field java.util.StringTokenizer#delimsChanged 

// ignoring field java.util.StringTokenizer#maxDelimCodePoint 

// ignoring field java.util.StringTokenizer#hasSurrogates 

// ignoring field java.util.StringTokenizer#delimiterCodePoints 


    // ignoring method java.util.StringTokenizer#setMaxDelimCodePoint()
    // starting method java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"StringTokenizer(java.lang.String, java.lang.String, boolean)");
    method.setSimpleName("StringTokenizer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String, boolean)
    // starting method java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"StringTokenizer(java.lang.String, java.lang.String)");
    method.setSimpleName("StringTokenizer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String)
    // starting method java.util.StringTokenizer#StringTokenizer(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"StringTokenizer(java.lang.String)");
    method.setSimpleName("StringTokenizer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#StringTokenizer(java.lang.String)
    // ignoring method java.util.StringTokenizer#skipDelimiters(int)
    // ignoring method java.util.StringTokenizer#scanToken(int)
    // ignoring method java.util.StringTokenizer#isDelimiter(int)
    // starting method java.util.StringTokenizer#hasMoreTokens()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreTokens()");
    method.setSimpleName("hasMoreTokens");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#hasMoreTokens()
    // starting method java.util.StringTokenizer#nextToken()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextToken()");
    method.setSimpleName("nextToken");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#nextToken()
    // starting method java.util.StringTokenizer#nextToken(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextToken(java.lang.String)");
    method.setSimpleName("nextToken");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#nextToken(java.lang.String)
    // starting method java.util.StringTokenizer#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#hasMoreElements()
    // starting method java.util.StringTokenizer#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#nextElement()
    // starting method java.util.StringTokenizer#countTokens()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"countTokens()");
    method.setSimpleName("countTokens");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#countTokens()

// finishing type java.util.StringTokenizer
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "SubList$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

// ignoring field java.util.SubList$1#i 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SubList$1#val$index
	field = newType.addNode(JavaDataField.class,"val$index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.SubList$1#val$index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SubList$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SubList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.SubList$1#this$0


    // starting method java.util.SubList$1#SubList$1(java.util.SubList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SubList$1(java.util.SubList, int)");
    method.setSimpleName("SubList$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#SubList$1(java.util.SubList, int)
    // starting method java.util.SubList$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#hasNext()
    // starting method java.util.SubList$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#next()
    // starting method java.util.SubList$1#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#hasPrevious()
    // starting method java.util.SubList$1#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#previous()
    // starting method java.util.SubList$1#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#nextIndex()
    // starting method java.util.SubList$1#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#previousIndex()
    // starting method java.util.SubList$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#remove()
    // starting method java.util.SubList$1#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#set(java.lang.Object)
    // starting method java.util.SubList$1#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#add(java.lang.Object)

// finishing type java.util.SubList$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "SubList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.SubList#l 

// ignoring field java.util.SubList#offset 

// ignoring field java.util.SubList#size 

// ignoring field java.util.SubList#expectedModCount 


    // starting method java.util.SubList#SubList(java.util.AbstractList, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SubList(java.util.AbstractList, int, int)");
    method.setSimpleName("SubList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#SubList(java.util.AbstractList, int, int)
    // starting method java.util.SubList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#set(int, java.lang.Object)
    // starting method java.util.SubList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#get(int)
    // starting method java.util.SubList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#size()
    // starting method java.util.SubList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#add(int, java.lang.Object)
    // starting method java.util.SubList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#remove(int)
    // starting method java.util.SubList#removeRange(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeRange(int, int)");
    method.setSimpleName("removeRange");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#removeRange(int, int)
    // starting method java.util.SubList#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#addAll(java.util.Collection)
    // starting method java.util.SubList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#addAll(int, java.util.Collection)
    // starting method java.util.SubList#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#iterator()
    // starting method java.util.SubList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#listIterator(int)
    // starting method java.util.SubList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#subList(int, int)
    // ignoring method java.util.SubList#rangeCheck(int)
    // ignoring method java.util.SubList#checkForComodification()
    // starting method java.util.SubList#access$000(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.SubList)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$000(java.util.SubList)
    // starting method java.util.SubList#access$100(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.SubList)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractList");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$100(java.util.SubList)
    // starting method java.util.SubList#access$200(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.SubList)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$200(java.util.SubList)
    // starting method java.util.SubList#access$302(java.util.SubList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$302(java.util.SubList, int)");
    method.setSimpleName("access$302");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$302(java.util.SubList, int)
    // starting method java.util.SubList#access$210(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$210(java.util.SubList)");
    method.setSimpleName("access$210");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$210(java.util.SubList)
    // starting method java.util.SubList#access$208(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$208(java.util.SubList)");
    method.setSimpleName("access$208");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$208(java.util.SubList)

// finishing type java.util.SubList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TaskQueue");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.TaskQueue#queue 

// ignoring field java.util.TaskQueue#size 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TaskQueue#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.TaskQueue#$assertionsDisabled


    // starting method java.util.TaskQueue#TaskQueue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TaskQueue()");
    method.setSimpleName("TaskQueue");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#TaskQueue()
    // starting method java.util.TaskQueue#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#size()
    // starting method java.util.TaskQueue#add(java.util.TimerTask)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.util.TimerTask)");
    method.setSimpleName("add");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#add(java.util.TimerTask)
    // starting method java.util.TaskQueue#getMin()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMin()");
    method.setSimpleName("getMin");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimerTask");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#getMin()
    // starting method java.util.TaskQueue#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimerTask");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#get(int)
    // starting method java.util.TaskQueue#removeMin()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeMin()");
    method.setSimpleName("removeMin");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#removeMin()
    // starting method java.util.TaskQueue#quickRemove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"quickRemove(int)");
    method.setSimpleName("quickRemove");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#quickRemove(int)
    // starting method java.util.TaskQueue#rescheduleMin(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"rescheduleMin(long)");
    method.setSimpleName("rescheduleMin");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#rescheduleMin(long)
    // starting method java.util.TaskQueue#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#isEmpty()
    // starting method java.util.TaskQueue#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#clear()
    // ignoring method java.util.TaskQueue#fixUp(int)
    // ignoring method java.util.TaskQueue#fixDown(int)
    // starting method java.util.TaskQueue#heapify()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"heapify()");
    method.setSimpleName("heapify");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#heapify()

// finishing type java.util.TaskQueue
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Timer$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Timer$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Timer");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Timer$1#this$0


    // starting method java.util.Timer$1#Timer$1(java.util.Timer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer$1(java.util.Timer)");
    method.setSimpleName("Timer$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer$1#Timer$1(java.util.Timer)
    // starting method java.util.Timer$1#finalize()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"finalize()");
    method.setSimpleName("finalize");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Throwable");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.Throwable
    
    // finishing method java.util.Timer$1#finalize()

// finishing type java.util.Timer$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Timer");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Timer#queue 

// ignoring field java.util.Timer#thread 

// ignoring field java.util.Timer#threadReaper 

// ignoring field java.util.Timer#nextSerialNumber 


    // ignoring method java.util.Timer#serialNumber()
    // starting method java.util.Timer#Timer()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer()");
    method.setSimpleName("Timer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#Timer()
    // starting method java.util.Timer#Timer(boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer(boolean)");
    method.setSimpleName("Timer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#Timer(boolean)
    // starting method java.util.Timer#Timer(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer(java.lang.String)");
    method.setSimpleName("Timer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#Timer(java.lang.String)
    // starting method java.util.Timer#Timer(java.lang.String, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer(java.lang.String, boolean)");
    method.setSimpleName("Timer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#Timer(java.lang.String, boolean)
    // starting method java.util.Timer#schedule(java.util.TimerTask, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"schedule(java.util.TimerTask, long)");
    method.setSimpleName("schedule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#schedule(java.util.TimerTask, long)
    // starting method java.util.Timer#schedule(java.util.TimerTask, java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"schedule(java.util.TimerTask, java.util.Date)");
    method.setSimpleName("schedule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#schedule(java.util.TimerTask, java.util.Date)
    // starting method java.util.Timer#schedule(java.util.TimerTask, long, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"schedule(java.util.TimerTask, long, long)");
    method.setSimpleName("schedule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#schedule(java.util.TimerTask, long, long)
    // starting method java.util.Timer#schedule(java.util.TimerTask, java.util.Date, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"schedule(java.util.TimerTask, java.util.Date, long)");
    method.setSimpleName("schedule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#schedule(java.util.TimerTask, java.util.Date, long)
    // starting method java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, long, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"scheduleAtFixedRate(java.util.TimerTask, long, long)");
    method.setSimpleName("scheduleAtFixedRate");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, long, long)
    // starting method java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)");
    method.setSimpleName("scheduleAtFixedRate");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)
    // ignoring method java.util.Timer#sched(java.util.TimerTask, long, long)
    // starting method java.util.Timer#cancel()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"cancel()");
    method.setSimpleName("cancel");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#cancel()
    // starting method java.util.Timer#purge()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"purge()");
    method.setSimpleName("purge");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#purge()
    // starting method java.util.Timer#access$000(java.util.Timer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.Timer)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TaskQueue");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#access$000(java.util.Timer)
    // starting method java.util.Timer#access$100(java.util.Timer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.Timer)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimerThread");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#access$100(java.util.Timer)

// finishing type java.util.Timer
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimerTask");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Runnable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Runnable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Runnable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#lock
	field = newType.addNode(JavaDataField.class,"lock"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#lock

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#state
	field = newType.addNode(JavaDataField.class,"state"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#state

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#VIRGIN
	field = newType.addNode(JavaDataField.class,"VIRGIN"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#VIRGIN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#SCHEDULED
	field = newType.addNode(JavaDataField.class,"SCHEDULED"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#SCHEDULED

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#EXECUTED
	field = newType.addNode(JavaDataField.class,"EXECUTED"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#EXECUTED

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#CANCELLED
	field = newType.addNode(JavaDataField.class,"CANCELLED"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#CANCELLED

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#nextExecutionTime
	field = newType.addNode(JavaDataField.class,"nextExecutionTime"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#nextExecutionTime

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#period
	field = newType.addNode(JavaDataField.class,"period"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#period


    // starting method java.util.TimerTask#TimerTask()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TimerTask()");
    method.setSimpleName("TimerTask");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerTask#TimerTask()
    // starting method java.util.TimerTask#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerTask#run()
    // starting method java.util.TimerTask#cancel()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"cancel()");
    method.setSimpleName("cancel");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerTask#cancel()
    // starting method java.util.TimerTask#scheduledExecutionTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"scheduledExecutionTime()");
    method.setSimpleName("scheduledExecutionTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerTask#scheduledExecutionTime()

// finishing type java.util.TimerTask
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimerThread");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Thread");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerThread#newTasksMayBeScheduled
	field = newType.addNode(JavaDataField.class,"newTasksMayBeScheduled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TimerThread#newTasksMayBeScheduled

// ignoring field java.util.TimerThread#queue 


    // starting method java.util.TimerThread#TimerThread(java.util.TaskQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TimerThread(java.util.TaskQueue)");
    method.setSimpleName("TimerThread");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerThread#TimerThread(java.util.TaskQueue)
    // starting method java.util.TimerThread#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerThread#run()
    // ignoring method java.util.TimerThread#mainLoop()

// finishing type java.util.TimerThread
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface PrivilegedAction 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PrivilegedAction");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface PrivilegedAction 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone$1#val$id
	field = newType.addNode(JavaDataField.class,"val$id"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TimeZone$1#val$id


    // starting method java.util.TimeZone$1#TimeZone$1(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TimeZone$1(java.lang.String)");
    method.setSimpleName("TimeZone$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone$1#TimeZone$1(java.lang.String)
    // starting method java.util.TimeZone$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone$1#run()

// finishing type java.util.TimeZone$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone$DisplayNames");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.TimeZone$DisplayNames#CACHE 


    // ignoring method java.util.TimeZone$DisplayNames#TimeZone$DisplayNames()
    // starting method java.util.TimeZone$DisplayNames#access$000()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000()");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone$DisplayNames#access$000()

// finishing type java.util.TimeZone$DisplayNames
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#SHORT
	field = newType.addNode(JavaDataField.class,"SHORT"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#SHORT

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#LONG
	field = newType.addNode(JavaDataField.class,"LONG"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#LONG

// ignoring field java.util.TimeZone#ONE_MINUTE 

// ignoring field java.util.TimeZone#ONE_HOUR 

// ignoring field java.util.TimeZone#ONE_DAY 

// ignoring field java.util.TimeZone#cachedLocaleData 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#NO_TIMEZONE
	field = newType.addNode(JavaDataField.class,"NO_TIMEZONE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#NO_TIMEZONE

// ignoring field java.util.TimeZone#ID 

// ignoring field java.util.TimeZone#defaultTimeZone 

// ignoring field java.util.TimeZone#defaultZoneTL 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#GMT_ID
	field = newType.addNode(JavaDataField.class,"GMT_ID"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#GMT_ID

// ignoring field java.util.TimeZone#GMT_ID_LENGTH 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#$assertionsDisabled


    // starting method java.util.TimeZone#TimeZone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TimeZone()");
    method.setSimpleName("TimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#TimeZone()
    // starting method java.util.TimeZone#getOffset(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffset(int, int, int, int, int, int)");
    method.setSimpleName("getOffset");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getOffset(int, int, int, int, int, int)
    // starting method java.util.TimeZone#getOffset(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffset(long)");
    method.setSimpleName("getOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getOffset(long)
    // starting method java.util.TimeZone#getOffsets(long, int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffsets(long, int[])");
    method.setSimpleName("getOffsets");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getOffsets(long, int[])
    // starting method java.util.TimeZone#setRawOffset(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setRawOffset(int)");
    method.setSimpleName("setRawOffset");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#setRawOffset(int)
    // starting method java.util.TimeZone#getRawOffset()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getRawOffset()");
    method.setSimpleName("getRawOffset");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getRawOffset()
    // starting method java.util.TimeZone#getID()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getID()");
    method.setSimpleName("getID");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getID()
    // starting method java.util.TimeZone#setID(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setID(java.lang.String)");
    method.setSimpleName("setID");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#setID(java.lang.String)
    // starting method java.util.TimeZone#getDisplayName()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName()");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDisplayName()
    // starting method java.util.TimeZone#getDisplayName(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName(java.util.Locale)");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDisplayName(java.util.Locale)
    // starting method java.util.TimeZone#getDisplayName(boolean, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName(boolean, int)");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDisplayName(boolean, int)
    // starting method java.util.TimeZone#getDisplayName(boolean, int, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName(boolean, int, java.util.Locale)");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDisplayName(boolean, int, java.util.Locale)
    // ignoring method java.util.TimeZone#getDisplayNames(java.lang.String, java.util.Locale)
    // ignoring method java.util.TimeZone#retrieveDisplayNames(java.lang.String, java.util.Locale)
    // starting method java.util.TimeZone#getDSTSavings()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDSTSavings()");
    method.setSimpleName("getDSTSavings");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDSTSavings()
    // starting method java.util.TimeZone#useDaylightTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useDaylightTime()");
    method.setSimpleName("useDaylightTime");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#useDaylightTime()
    // starting method java.util.TimeZone#inDaylightTime(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"inDaylightTime(java.util.Date)");
    method.setSimpleName("inDaylightTime");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#inDaylightTime(java.util.Date)
    // starting method java.util.TimeZone#getTimeZone(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimeZone(java.lang.String)");
    method.setSimpleName("getTimeZone");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getTimeZone(java.lang.String)
    // ignoring method java.util.TimeZone#getTimeZone(java.lang.String, boolean)
    // starting method java.util.TimeZone#getAvailableIDs(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getAvailableIDs(int)");
    method.setSimpleName("getAvailableIDs");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getAvailableIDs(int)
    // starting method java.util.TimeZone#getAvailableIDs()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getAvailableIDs()");
    method.setSimpleName("getAvailableIDs");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getAvailableIDs()
    // ignoring method java.util.TimeZone#getSystemTimeZoneID(java.lang.String, java.lang.String)
    // ignoring method java.util.TimeZone#getSystemGMTOffsetID()
    // starting method java.util.TimeZone#getDefault()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDefault()");
    method.setSimpleName("getDefault");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDefault()
    // starting method java.util.TimeZone#getDefaultRef()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDefaultRef()");
    method.setSimpleName("getDefaultRef");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDefaultRef()
    // ignoring method java.util.TimeZone#setDefaultZone()
    // ignoring method java.util.TimeZone#hasPermission()
    // starting method java.util.TimeZone#setDefault(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setDefault(java.util.TimeZone)");
    method.setSimpleName("setDefault");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#setDefault(java.util.TimeZone)
    // starting method java.util.TimeZone#hasSameRules(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasSameRules(java.util.TimeZone)");
    method.setSimpleName("hasSameRules");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#hasSameRules(java.util.TimeZone)
    // starting method java.util.TimeZone#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#clone()
    // ignoring method java.util.TimeZone#parseCustomTimeZone(java.lang.String)

// finishing type java.util.TimeZone
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TooManyListenersException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Exception");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.TooManyListenersException#TooManyListenersException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TooManyListenersException()");
    method.setSimpleName("TooManyListenersException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TooManyListenersException#TooManyListenersException()
    // starting method java.util.TooManyListenersException#TooManyListenersException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TooManyListenersException(java.lang.String)");
    method.setSimpleName("TooManyListenersException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TooManyListenersException#TooManyListenersException(java.lang.String)

// finishing type java.util.TooManyListenersException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$1#this$0


    // starting method java.util.TreeMap$1#TreeMap$1(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$1(java.util.TreeMap)");
    method.setSimpleName("TreeMap$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#TreeMap$1(java.util.TreeMap)
    // starting method java.util.TreeMap$1#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#iterator()
    // starting method java.util.TreeMap$1#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#size()
    // starting method java.util.TreeMap$1#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#contains(java.lang.Object)
    // starting method java.util.TreeMap$1#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#remove(java.lang.Object)
    // starting method java.util.TreeMap$1#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#clear()

// finishing type java.util.TreeMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$2");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$2#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$2#this$0


    // starting method java.util.TreeMap$2#TreeMap$2(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$2(java.util.TreeMap)");
    method.setSimpleName("TreeMap$2");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#TreeMap$2(java.util.TreeMap)
    // starting method java.util.TreeMap$2#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#iterator()
    // starting method java.util.TreeMap$2#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#size()
    // starting method java.util.TreeMap$2#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#contains(java.lang.Object)
    // starting method java.util.TreeMap$2#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#remove(java.lang.Object)
    // starting method java.util.TreeMap$2#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#clear()

// finishing type java.util.TreeMap$2
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$3");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$3#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$3#this$0


    // starting method java.util.TreeMap$3#TreeMap$3(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$3(java.util.TreeMap)");
    method.setSimpleName("TreeMap$3");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#TreeMap$3(java.util.TreeMap)
    // starting method java.util.TreeMap$3#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#iterator()
    // starting method java.util.TreeMap$3#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#contains(java.lang.Object)
    // starting method java.util.TreeMap$3#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#remove(java.lang.Object)
    // starting method java.util.TreeMap$3#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#size()
    // starting method java.util.TreeMap$3#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#clear()

// finishing type java.util.TreeMap$3
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#key
	field = newType.addNode(JavaDataField.class,"key"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#key

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#value
	field = newType.addNode(JavaDataField.class,"value"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#value

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#left
	field = newType.addNode(JavaDataField.class,"left"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#left

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#right
	field = newType.addNode(JavaDataField.class,"right"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#right

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#parent
	field = newType.addNode(JavaDataField.class,"parent"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#parent

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#color
	field = newType.addNode(JavaDataField.class,"color"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#color


    // starting method java.util.TreeMap$Entry#TreeMap$Entry(java.lang.Object, java.lang.Object, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$Entry(java.lang.Object, java.lang.Object, java.util.TreeMap$Entry)");
    method.setSimpleName("TreeMap$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#TreeMap$Entry(java.lang.Object, java.lang.Object, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#getKey()
    // starting method java.util.TreeMap$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#getValue()
    // starting method java.util.TreeMap$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#setValue(java.lang.Object)
    // starting method java.util.TreeMap$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#equals(java.lang.Object)
    // starting method java.util.TreeMap$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#hashCode()
    // starting method java.util.TreeMap$Entry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#toString()

// finishing type java.util.TreeMap$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TreeMap$PrivateEntryIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$EntryIterator#this$0


    // ignoring method java.util.TreeMap$EntryIterator#TreeMap$EntryIterator(java.util.TreeMap)
    // starting method java.util.TreeMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$EntryIterator#next()
    // starting method java.util.TreeMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$EntryIterator#next()
    // starting method java.util.TreeMap$EntryIterator#TreeMap$EntryIterator(java.util.TreeMap, java.util.TreeMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$EntryIterator(java.util.TreeMap, java.util.TreeMap$1)");
    method.setSimpleName("TreeMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$EntryIterator#TreeMap$EntryIterator(java.util.TreeMap, java.util.TreeMap$1)

// finishing type java.util.TreeMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TreeMap$PrivateEntryIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$KeyIterator#this$0


    // ignoring method java.util.TreeMap$KeyIterator#TreeMap$KeyIterator(java.util.TreeMap)
    // starting method java.util.TreeMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$KeyIterator#next()
    // starting method java.util.TreeMap$KeyIterator#TreeMap$KeyIterator(java.util.TreeMap, java.util.TreeMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$KeyIterator(java.util.TreeMap, java.util.TreeMap$1)");
    method.setSimpleName("TreeMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$KeyIterator#TreeMap$KeyIterator(java.util.TreeMap, java.util.TreeMap$1)

// finishing type java.util.TreeMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$PrivateEntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.TreeMap$PrivateEntryIterator#expectedModCount 

// ignoring field java.util.TreeMap$PrivateEntryIterator#lastReturned 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$PrivateEntryIterator#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$PrivateEntryIterator#next

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$PrivateEntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$PrivateEntryIterator#this$0


    // starting method java.util.TreeMap$PrivateEntryIterator#TreeMap$PrivateEntryIterator(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$PrivateEntryIterator(java.util.TreeMap)");
    method.setSimpleName("TreeMap$PrivateEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#TreeMap$PrivateEntryIterator(java.util.TreeMap)
    // starting method java.util.TreeMap$PrivateEntryIterator#TreeMap$PrivateEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$PrivateEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry)");
    method.setSimpleName("TreeMap$PrivateEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#TreeMap$PrivateEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap$PrivateEntryIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#hasNext()
    // starting method java.util.TreeMap$PrivateEntryIterator#nextEntry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextEntry()");
    method.setSimpleName("nextEntry");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#nextEntry()
    // starting method java.util.TreeMap$PrivateEntryIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#remove()

// finishing type java.util.TreeMap$PrivateEntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMap$EntrySetView");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.TreeMap$SubMap$EntrySetView#size 

// ignoring field java.util.TreeMap$SubMap$EntrySetView#sizeModCount 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$SubMap$EntrySetView#this$1
	field = newType.addNode(JavaDataField.class,"this$1"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$SubMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$SubMap$EntrySetView#this$1


    // ignoring method java.util.TreeMap$SubMap$EntrySetView#TreeMap$SubMap$EntrySetView(java.util.TreeMap$SubMap)
    // starting method java.util.TreeMap$SubMap$EntrySetView#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#size()
    // starting method java.util.TreeMap$SubMap$EntrySetView#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#isEmpty()
    // starting method java.util.TreeMap$SubMap$EntrySetView#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#contains(java.lang.Object)
    // starting method java.util.TreeMap$SubMap$EntrySetView#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#remove(java.lang.Object)
    // starting method java.util.TreeMap$SubMap$EntrySetView#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#iterator()
    // starting method java.util.TreeMap$SubMap$EntrySetView#TreeMap$SubMap$EntrySetView(java.util.TreeMap$SubMap, java.util.TreeMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMap$EntrySetView(java.util.TreeMap$SubMap, java.util.TreeMap$1)");
    method.setSimpleName("TreeMap$SubMap$EntrySetView");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#TreeMap$SubMap$EntrySetView(java.util.TreeMap$SubMap, java.util.TreeMap$1)

// finishing type java.util.TreeMap$SubMap$EntrySetView
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.TreeMap$SubMap#serialVersionUID 

// ignoring field java.util.TreeMap$SubMap#fromStart 

// ignoring field java.util.TreeMap$SubMap#toEnd 

// ignoring field java.util.TreeMap$SubMap#fromKey 

// ignoring field java.util.TreeMap$SubMap#toKey 

// ignoring field java.util.TreeMap$SubMap#entrySet 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$SubMap#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$SubMap#this$0


    // starting method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMap(java.util.TreeMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("TreeMap$SubMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, java.lang.Object, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMap(java.util.TreeMap, java.lang.Object, boolean)");
    method.setSimpleName("TreeMap$SubMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, java.lang.Object, boolean)
    // starting method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, boolean, java.lang.Object, boolean, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMap(java.util.TreeMap, boolean, java.lang.Object, boolean, java.lang.Object)");
    method.setSimpleName("TreeMap$SubMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, boolean, java.lang.Object, boolean, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#isEmpty()
    // starting method java.util.TreeMap$SubMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#containsKey(java.lang.Object)
    // starting method java.util.TreeMap$SubMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#get(java.lang.Object)
    // starting method java.util.TreeMap$SubMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#comparator()
    // starting method java.util.TreeMap$SubMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#firstKey()
    // starting method java.util.TreeMap$SubMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#lastKey()
    // starting method java.util.TreeMap$SubMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#entrySet()
    // starting method java.util.TreeMap$SubMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#headMap(java.lang.Object)
    // starting method java.util.TreeMap$SubMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#tailMap(java.lang.Object)
    // ignoring method java.util.TreeMap$SubMap#inRange(java.lang.Object)
    // ignoring method java.util.TreeMap$SubMap#inRange2(java.lang.Object)
    // starting method java.util.TreeMap$SubMap#access$1700(java.util.TreeMap$SubMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1700(java.util.TreeMap$SubMap, java.lang.Object)");
    method.setSimpleName("access$1700");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$1700(java.util.TreeMap$SubMap, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#access$1800(java.util.TreeMap$SubMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1800(java.util.TreeMap$SubMap)");
    method.setSimpleName("access$1800");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$1800(java.util.TreeMap$SubMap)
    // starting method java.util.TreeMap$SubMap#access$1900(java.util.TreeMap$SubMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1900(java.util.TreeMap$SubMap)");
    method.setSimpleName("access$1900");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$1900(java.util.TreeMap$SubMap)
    // starting method java.util.TreeMap$SubMap#access$2000(java.util.TreeMap$SubMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$2000(java.util.TreeMap$SubMap)");
    method.setSimpleName("access$2000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$2000(java.util.TreeMap$SubMap)
    // starting method java.util.TreeMap$SubMap#access$2100(java.util.TreeMap$SubMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$2100(java.util.TreeMap$SubMap)");
    method.setSimpleName("access$2100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$2100(java.util.TreeMap$SubMap)

// finishing type java.util.TreeMap$SubMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMapEntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TreeMap$PrivateEntryIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.TreeMap$SubMapEntryIterator#firstExcludedKey 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$SubMapEntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$SubMapEntryIterator#this$0


    // starting method java.util.TreeMap$SubMapEntryIterator#TreeMap$SubMapEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMapEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry, java.util.TreeMap$Entry)");
    method.setSimpleName("TreeMap$SubMapEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMapEntryIterator#TreeMap$SubMapEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap$SubMapEntryIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMapEntryIterator#hasNext()
    // starting method java.util.TreeMap$SubMapEntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMapEntryIterator#next()
    // starting method java.util.TreeMap$SubMapEntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMapEntryIterator#next()

// finishing type java.util.TreeMap$SubMapEntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TreeMap$PrivateEntryIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$ValueIterator#this$0


    // ignoring method java.util.TreeMap$ValueIterator#TreeMap$ValueIterator(java.util.TreeMap)
    // starting method java.util.TreeMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$ValueIterator#next()
    // starting method java.util.TreeMap$ValueIterator#TreeMap$ValueIterator(java.util.TreeMap, java.util.TreeMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$ValueIterator(java.util.TreeMap, java.util.TreeMap$1)");
    method.setSimpleName("TreeMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$ValueIterator#TreeMap$ValueIterator(java.util.TreeMap, java.util.TreeMap$1)

// finishing type java.util.TreeMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.TreeMap#comparator 

// ignoring field java.util.TreeMap#root 

// ignoring field java.util.TreeMap#size 

// ignoring field java.util.TreeMap#modCount 

// ignoring field java.util.TreeMap#entrySet 

// ignoring field java.util.TreeMap#RED 

// ignoring field java.util.TreeMap#BLACK 

// ignoring field java.util.TreeMap#serialVersionUID 


    // ignoring method java.util.TreeMap#incrementSize()
    // ignoring method java.util.TreeMap#decrementSize()
    // starting method java.util.TreeMap#TreeMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap()");
    method.setSimpleName("TreeMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#TreeMap()
    // starting method java.util.TreeMap#TreeMap(java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap(java.util.Comparator)");
    method.setSimpleName("TreeMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#TreeMap(java.util.Comparator)
    // starting method java.util.TreeMap#TreeMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap(java.util.Map)");
    method.setSimpleName("TreeMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#TreeMap(java.util.Map)
    // starting method java.util.TreeMap#TreeMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap(java.util.SortedMap)");
    method.setSimpleName("TreeMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#TreeMap(java.util.SortedMap)
    // starting method java.util.TreeMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#size()
    // starting method java.util.TreeMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#containsKey(java.lang.Object)
    // starting method java.util.TreeMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#containsValue(java.lang.Object)
    // ignoring method java.util.TreeMap#valueSearchNull(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#valueSearchNonNull(java.util.TreeMap$Entry, java.lang.Object)
    // starting method java.util.TreeMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#get(java.lang.Object)
    // starting method java.util.TreeMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#comparator()
    // starting method java.util.TreeMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#firstKey()
    // starting method java.util.TreeMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#lastKey()
    // starting method java.util.TreeMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#putAll(java.util.Map)
    // ignoring method java.util.TreeMap#getEntry(java.lang.Object)
    // ignoring method java.util.TreeMap#getCeilEntry(java.lang.Object)
    // ignoring method java.util.TreeMap#getPrecedingEntry(java.lang.Object)
    // ignoring method java.util.TreeMap#key(java.util.TreeMap$Entry)
    // starting method java.util.TreeMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#remove(java.lang.Object)
    // starting method java.util.TreeMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#clear()
    // starting method java.util.TreeMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#clone()
    // starting method java.util.TreeMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#keySet()
    // starting method java.util.TreeMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#values()
    // starting method java.util.TreeMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#entrySet()
    // starting method java.util.TreeMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#headMap(java.lang.Object)
    // starting method java.util.TreeMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#tailMap(java.lang.Object)
    // ignoring method java.util.TreeMap#compare(java.lang.Object, java.lang.Object)
    // ignoring method java.util.TreeMap#valEquals(java.lang.Object, java.lang.Object)
    // ignoring method java.util.TreeMap#firstEntry()
    // ignoring method java.util.TreeMap#lastEntry()
    // ignoring method java.util.TreeMap#successor(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#colorOf(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#parentOf(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#setColor(java.util.TreeMap$Entry, boolean)
    // ignoring method java.util.TreeMap#leftOf(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#rightOf(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#rotateLeft(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#rotateRight(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#fixAfterInsertion(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#deleteEntry(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#fixAfterDeletion(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.TreeMap#readObject(java.io.ObjectInputStream)
    // starting method java.util.TreeMap#readTreeSet(int, java.io.ObjectInputStream, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"readTreeSet(int, java.io.ObjectInputStream, java.lang.Object)");
    method.setSimpleName("readTreeSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","ClassNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.ClassNotFoundException
    
    // finishing method java.util.TreeMap#readTreeSet(int, java.io.ObjectInputStream, java.lang.Object)
    // starting method java.util.TreeMap#addAllForTreeSet(java.util.SortedSet, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAllForTreeSet(java.util.SortedSet, java.lang.Object)");
    method.setSimpleName("addAllForTreeSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#addAllForTreeSet(java.util.SortedSet, java.lang.Object)
    // ignoring method java.util.TreeMap#buildFromSorted(int, java.util.Iterator, java.io.ObjectInputStream, java.lang.Object)
    // ignoring method java.util.TreeMap#buildFromSorted(int, int, int, int, java.util.Iterator, java.io.ObjectInputStream, java.lang.Object)
    // ignoring method java.util.TreeMap#computeRedLevel(int)
    // starting method java.util.TreeMap#access$100(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.TreeMap)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$100(java.util.TreeMap)
    // starting method java.util.TreeMap#access$300(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.util.TreeMap)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$300(java.util.TreeMap)
    // starting method java.util.TreeMap#access$400(java.util.TreeMap, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.TreeMap, java.util.TreeMap$Entry)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$400(java.util.TreeMap, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap#access$500(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$500(java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$500");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$500(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap#access$600(java.util.TreeMap, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$600(java.util.TreeMap, java.util.TreeMap$Entry)");
    method.setSimpleName("access$600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$600(java.util.TreeMap, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap#access$800(java.util.TreeMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$800(java.util.TreeMap, java.lang.Object)");
    method.setSimpleName("access$800");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$800(java.util.TreeMap, java.lang.Object)
    // starting method java.util.TreeMap#access$900(java.util.TreeMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$900(java.util.TreeMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$900");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$900(java.util.TreeMap, java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap#access$1000(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1000(java.util.TreeMap)");
    method.setSimpleName("access$1000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1000(java.util.TreeMap)
    // starting method java.util.TreeMap#access$1100(java.util.TreeMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1100(java.util.TreeMap, java.lang.Object)");
    method.setSimpleName("access$1100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1100(java.util.TreeMap, java.lang.Object)
    // starting method java.util.TreeMap#access$1200(java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1200(java.util.TreeMap$Entry)");
    method.setSimpleName("access$1200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1200(java.util.TreeMap$Entry)
    // starting method java.util.TreeMap#access$1300(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1300(java.util.TreeMap)");
    method.setSimpleName("access$1300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1300(java.util.TreeMap)
    // starting method java.util.TreeMap#access$1400(java.util.TreeMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1400(java.util.TreeMap, java.lang.Object)");
    method.setSimpleName("access$1400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1400(java.util.TreeMap, java.lang.Object)
    // starting method java.util.TreeMap#access$1600(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1600(java.util.TreeMap)");
    method.setSimpleName("access$1600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1600(java.util.TreeMap)

// finishing type java.util.TreeMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedSet 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedSet");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedSet 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.TreeSet#m 

// ignoring field java.util.TreeSet#keySet 

// ignoring field java.util.TreeSet#PRESENT 

// ignoring field java.util.TreeSet#serialVersionUID 


    // ignoring method java.util.TreeSet#TreeSet(java.util.SortedMap)
    // starting method java.util.TreeSet#TreeSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeSet()");
    method.setSimpleName("TreeSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#TreeSet()
    // starting method java.util.TreeSet#TreeSet(java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeSet(java.util.Comparator)");
    method.setSimpleName("TreeSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#TreeSet(java.util.Comparator)
    // starting method java.util.TreeSet#TreeSet(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeSet(java.util.Collection)");
    method.setSimpleName("TreeSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#TreeSet(java.util.Collection)
    // starting method java.util.TreeSet#TreeSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeSet(java.util.SortedSet)");
    method.setSimpleName("TreeSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#TreeSet(java.util.SortedSet)
    // starting method java.util.TreeSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#iterator()
    // starting method java.util.TreeSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#size()
    // starting method java.util.TreeSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#isEmpty()
    // starting method java.util.TreeSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#contains(java.lang.Object)
    // starting method java.util.TreeSet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#add(java.lang.Object)
    // starting method java.util.TreeSet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#remove(java.lang.Object)
    // starting method java.util.TreeSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#clear()
    // starting method java.util.TreeSet#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#addAll(java.util.Collection)
    // starting method java.util.TreeSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#headSet(java.lang.Object)
    // starting method java.util.TreeSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#tailSet(java.lang.Object)
    // starting method java.util.TreeSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#comparator()
    // starting method java.util.TreeSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#first()
    // starting method java.util.TreeSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#last()
    // starting method java.util.TreeSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#clone()
    // ignoring method java.util.TreeSet#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.TreeSet#readObject(java.io.ObjectInputStream)

// finishing type java.util.TreeSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "UnknownFormatConversionException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.UnknownFormatConversionException#serialVersionUID 

// ignoring field java.util.UnknownFormatConversionException#s 


    // starting method java.util.UnknownFormatConversionException#UnknownFormatConversionException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"UnknownFormatConversionException(java.lang.String)");
    method.setSimpleName("UnknownFormatConversionException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatConversionException#UnknownFormatConversionException(java.lang.String)
    // starting method java.util.UnknownFormatConversionException#getConversion()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getConversion()");
    method.setSimpleName("getConversion");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatConversionException#getConversion()
    // starting method java.util.UnknownFormatConversionException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatConversionException#getMessage()

// finishing type java.util.UnknownFormatConversionException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "UnknownFormatFlagsException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.UnknownFormatFlagsException#serialVersionUID 

// ignoring field java.util.UnknownFormatFlagsException#flags 


    // starting method java.util.UnknownFormatFlagsException#UnknownFormatFlagsException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"UnknownFormatFlagsException(java.lang.String)");
    method.setSimpleName("UnknownFormatFlagsException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatFlagsException#UnknownFormatFlagsException(java.lang.String)
    // starting method java.util.UnknownFormatFlagsException#getFlags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFlags()");
    method.setSimpleName("getFlags");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatFlagsException#getFlags()
    // starting method java.util.UnknownFormatFlagsException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatFlagsException#getMessage()

// finishing type java.util.UnknownFormatFlagsException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "UUID");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Comparable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Comparable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparable 

// ignoring field java.util.UUID#serialVersionUID 

// ignoring field java.util.UUID#mostSigBits 

// ignoring field java.util.UUID#leastSigBits 

// ignoring field java.util.UUID#version 

// ignoring field java.util.UUID#variant 

// ignoring field java.util.UUID#timestamp 

// ignoring field java.util.UUID#sequence 

// ignoring field java.util.UUID#node 

// ignoring field java.util.UUID#hashCode 

// ignoring field java.util.UUID#numberGenerator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.UUID#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.UUID#$assertionsDisabled


    // ignoring method java.util.UUID#UUID(byte[])
    // starting method java.util.UUID#UUID(long, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"UUID(long, long)");
    method.setSimpleName("UUID");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#UUID(long, long)
    // starting method java.util.UUID#randomUUID()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"randomUUID()");
    method.setSimpleName("randomUUID");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","UUID");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#randomUUID()
    // starting method java.util.UUID#nameUUIDFromBytes(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nameUUIDFromBytes(byte[])");
    method.setSimpleName("nameUUIDFromBytes");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","UUID");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#nameUUIDFromBytes(byte[])
    // starting method java.util.UUID#fromString(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fromString(java.lang.String)");
    method.setSimpleName("fromString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","UUID");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#fromString(java.lang.String)
    // starting method java.util.UUID#getLeastSignificantBits()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLeastSignificantBits()");
    method.setSimpleName("getLeastSignificantBits");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#getLeastSignificantBits()
    // starting method java.util.UUID#getMostSignificantBits()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMostSignificantBits()");
    method.setSimpleName("getMostSignificantBits");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#getMostSignificantBits()
    // starting method java.util.UUID#version()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"version()");
    method.setSimpleName("version");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#version()
    // starting method java.util.UUID#variant()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"variant()");
    method.setSimpleName("variant");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#variant()
    // starting method java.util.UUID#timestamp()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"timestamp()");
    method.setSimpleName("timestamp");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#timestamp()
    // starting method java.util.UUID#clockSequence()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clockSequence()");
    method.setSimpleName("clockSequence");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#clockSequence()
    // starting method java.util.UUID#node()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"node()");
    method.setSimpleName("node");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#node()
    // starting method java.util.UUID#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#toString()
    // ignoring method java.util.UUID#digits(long, int)
    // starting method java.util.UUID#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#hashCode()
    // starting method java.util.UUID#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#equals(java.lang.Object)
    // starting method java.util.UUID#compareTo(java.util.UUID)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.util.UUID)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#compareTo(java.util.UUID)
    // ignoring method java.util.UUID#readObject(java.io.ObjectInputStream)
    // starting method java.util.UUID#compareTo(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.lang.Object)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#compareTo(java.lang.Object)

// finishing type java.util.UUID
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Vector$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector$1#count
	field = newType.addNode(JavaDataField.class,"count"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Vector$1#count

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Vector");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Vector$1#this$0


    // starting method java.util.Vector$1#Vector$1(java.util.Vector)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector$1(java.util.Vector)");
    method.setSimpleName("Vector$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector$1#Vector$1(java.util.Vector)
    // starting method java.util.Vector$1#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector$1#hasMoreElements()
    // starting method java.util.Vector$1#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector$1#nextElement()

// finishing type java.util.Vector$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Vector");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector#elementData
	field = newType.addNode(JavaDataField.class,"elementData"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Vector#elementData

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector#elementCount
	field = newType.addNode(JavaDataField.class,"elementCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Vector#elementCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector#capacityIncrement
	field = newType.addNode(JavaDataField.class,"capacityIncrement"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Vector#capacityIncrement

// ignoring field java.util.Vector#serialVersionUID 


    // starting method java.util.Vector#Vector(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector(int, int)");
    method.setSimpleName("Vector");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#Vector(int, int)
    // starting method java.util.Vector#Vector(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector(int)");
    method.setSimpleName("Vector");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#Vector(int)
    // starting method java.util.Vector#Vector()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector()");
    method.setSimpleName("Vector");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#Vector()
    // starting method java.util.Vector#Vector(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector(java.util.Collection)");
    method.setSimpleName("Vector");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#Vector(java.util.Collection)
    // starting method java.util.Vector#copyInto(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"copyInto(java.lang.Object[])");
    method.setSimpleName("copyInto");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#copyInto(java.lang.Object[])
    // starting method java.util.Vector#trimToSize()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"trimToSize()");
    method.setSimpleName("trimToSize");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#trimToSize()
    // starting method java.util.Vector#ensureCapacity(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"ensureCapacity(int)");
    method.setSimpleName("ensureCapacity");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#ensureCapacity(int)
    // ignoring method java.util.Vector#ensureCapacityHelper(int)
    // starting method java.util.Vector#setSize(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setSize(int)");
    method.setSimpleName("setSize");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#setSize(int)
    // starting method java.util.Vector#capacity()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"capacity()");
    method.setSimpleName("capacity");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#capacity()
    // starting method java.util.Vector#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#size()
    // starting method java.util.Vector#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#isEmpty()
    // starting method java.util.Vector#elements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elements()");
    method.setSimpleName("elements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#elements()
    // starting method java.util.Vector#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#contains(java.lang.Object)
    // starting method java.util.Vector#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#indexOf(java.lang.Object)
    // starting method java.util.Vector#indexOf(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object, int)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#indexOf(java.lang.Object, int)
    // starting method java.util.Vector#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#lastIndexOf(java.lang.Object)
    // starting method java.util.Vector#lastIndexOf(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object, int)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#lastIndexOf(java.lang.Object, int)
    // starting method java.util.Vector#elementAt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elementAt(int)");
    method.setSimpleName("elementAt");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#elementAt(int)
    // starting method java.util.Vector#firstElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstElement()");
    method.setSimpleName("firstElement");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#firstElement()
    // starting method java.util.Vector#lastElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastElement()");
    method.setSimpleName("lastElement");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#lastElement()
    // starting method java.util.Vector#setElementAt(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setElementAt(java.lang.Object, int)");
    method.setSimpleName("setElementAt");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#setElementAt(java.lang.Object, int)
    // starting method java.util.Vector#removeElementAt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeElementAt(int)");
    method.setSimpleName("removeElementAt");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeElementAt(int)
    // starting method java.util.Vector#insertElementAt(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"insertElementAt(java.lang.Object, int)");
    method.setSimpleName("insertElementAt");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#insertElementAt(java.lang.Object, int)
    // starting method java.util.Vector#addElement(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addElement(java.lang.Object)");
    method.setSimpleName("addElement");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#addElement(java.lang.Object)
    // starting method java.util.Vector#removeElement(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeElement(java.lang.Object)");
    method.setSimpleName("removeElement");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeElement(java.lang.Object)
    // starting method java.util.Vector#removeAllElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAllElements()");
    method.setSimpleName("removeAllElements");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeAllElements()
    // starting method java.util.Vector#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#clone()
    // starting method java.util.Vector#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#toArray()
    // starting method java.util.Vector#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#toArray(java.lang.Object[])
    // starting method java.util.Vector#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#get(int)
    // starting method java.util.Vector#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#set(int, java.lang.Object)
    // starting method java.util.Vector#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#add(java.lang.Object)
    // starting method java.util.Vector#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#remove(java.lang.Object)
    // starting method java.util.Vector#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#add(int, java.lang.Object)
    // starting method java.util.Vector#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#remove(int)
    // starting method java.util.Vector#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#clear()
    // starting method java.util.Vector#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#containsAll(java.util.Collection)
    // starting method java.util.Vector#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#addAll(java.util.Collection)
    // starting method java.util.Vector#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeAll(java.util.Collection)
    // starting method java.util.Vector#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#retainAll(java.util.Collection)
    // starting method java.util.Vector#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#addAll(int, java.util.Collection)
    // starting method java.util.Vector#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#equals(java.lang.Object)
    // starting method java.util.Vector#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#hashCode()
    // starting method java.util.Vector#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#toString()
    // starting method java.util.Vector#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#subList(int, int)
    // starting method java.util.Vector#removeRange(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeRange(int, int)");
    method.setSimpleName("removeRange");
    helper.setMethodData(method,36);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeRange(int, int)
    // ignoring method java.util.Vector#writeObject(java.io.ObjectOutputStream)

// finishing type java.util.Vector
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.WeakHashMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang.ref","WeakReference");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

// ignoring field java.util.WeakHashMap$Entry#value 

// ignoring field java.util.WeakHashMap$Entry#hash 

// ignoring field java.util.WeakHashMap$Entry#next 


    // starting method java.util.WeakHashMap$Entry#WeakHashMap$Entry(java.lang.Object, java.lang.Object, java.lang.ref.ReferenceQueue, int, java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$Entry(java.lang.Object, java.lang.Object, java.lang.ref.ReferenceQueue, int, java.util.WeakHashMap$Entry)");
    method.setSimpleName("WeakHashMap$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#WeakHashMap$Entry(java.lang.Object, java.lang.Object, java.lang.ref.ReferenceQueue, int, java.util.WeakHashMap$Entry)
    // starting method java.util.WeakHashMap$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#getKey()
    // starting method java.util.WeakHashMap$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#getValue()
    // starting method java.util.WeakHashMap$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#setValue(java.lang.Object)
    // starting method java.util.WeakHashMap$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#equals(java.lang.Object)
    // starting method java.util.WeakHashMap$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#hashCode()
    // starting method java.util.WeakHashMap$Entry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#toString()
    // starting method java.util.WeakHashMap$Entry#access$000(java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.WeakHashMap$Entry)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$000(java.util.WeakHashMap$Entry)
    // starting method java.util.WeakHashMap$Entry#access$100(java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.WeakHashMap$Entry)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$100(java.util.WeakHashMap$Entry)
    // starting method java.util.WeakHashMap$Entry#access$102(java.util.WeakHashMap$Entry, java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$102(java.util.WeakHashMap$Entry, java.util.WeakHashMap$Entry)");
    method.setSimpleName("access$102");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$102(java.util.WeakHashMap$Entry, java.util.WeakHashMap$Entry)
    // starting method java.util.WeakHashMap$Entry#access$202(java.util.WeakHashMap$Entry, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$202(java.util.WeakHashMap$Entry, java.lang.Object)");
    method.setSimpleName("access$202");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$202(java.util.WeakHashMap$Entry, java.lang.Object)
    // starting method java.util.WeakHashMap$Entry#access$200(java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.WeakHashMap$Entry)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$200(java.util.WeakHashMap$Entry)

// finishing type java.util.WeakHashMap$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","WeakHashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$EntryIterator#this$0


    // ignoring method java.util.WeakHashMap$EntryIterator#WeakHashMap$EntryIterator(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntryIterator#next()
    // starting method java.util.WeakHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntryIterator#next()
    // starting method java.util.WeakHashMap$EntryIterator#WeakHashMap$EntryIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$EntryIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntryIterator#WeakHashMap$EntryIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$EntrySet#this$0


    // ignoring method java.util.WeakHashMap$EntrySet#WeakHashMap$EntrySet(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#iterator()
    // starting method java.util.WeakHashMap$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#contains(java.lang.Object)
    // starting method java.util.WeakHashMap$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#remove(java.lang.Object)
    // starting method java.util.WeakHashMap$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#size()
    // starting method java.util.WeakHashMap$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#clear()
    // starting method java.util.WeakHashMap$EntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#toArray()
    // starting method java.util.WeakHashMap$EntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#toArray(java.lang.Object[])
    // starting method java.util.WeakHashMap$EntrySet#WeakHashMap$EntrySet(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$EntrySet(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#WeakHashMap$EntrySet(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$HashIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#entry
	field = newType.addNode(JavaDataField.class,"entry"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#entry

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#nextKey
	field = newType.addNode(JavaDataField.class,"nextKey"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#nextKey

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#currentKey
	field = newType.addNode(JavaDataField.class,"currentKey"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#currentKey

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#this$0


    // starting method java.util.WeakHashMap$HashIterator#WeakHashMap$HashIterator(java.util.WeakHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$HashIterator(java.util.WeakHashMap)");
    method.setSimpleName("WeakHashMap$HashIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$HashIterator#WeakHashMap$HashIterator(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$HashIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$HashIterator#hasNext()
    // starting method java.util.WeakHashMap$HashIterator#nextEntry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextEntry()");
    method.setSimpleName("nextEntry");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$HashIterator#nextEntry()
    // starting method java.util.WeakHashMap$HashIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$HashIterator#remove()

// finishing type java.util.WeakHashMap$HashIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","WeakHashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$KeyIterator#this$0


    // ignoring method java.util.WeakHashMap$KeyIterator#WeakHashMap$KeyIterator(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeyIterator#next()
    // starting method java.util.WeakHashMap$KeyIterator#WeakHashMap$KeyIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$KeyIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeyIterator#WeakHashMap$KeyIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$KeySet#this$0


    // ignoring method java.util.WeakHashMap$KeySet#WeakHashMap$KeySet(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#iterator()
    // starting method java.util.WeakHashMap$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#size()
    // starting method java.util.WeakHashMap$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#contains(java.lang.Object)
    // starting method java.util.WeakHashMap$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#remove(java.lang.Object)
    // starting method java.util.WeakHashMap$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#clear()
    // starting method java.util.WeakHashMap$KeySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#toArray()
    // starting method java.util.WeakHashMap$KeySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#toArray(java.lang.Object[])
    // starting method java.util.WeakHashMap$KeySet#WeakHashMap$KeySet(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$KeySet(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#WeakHashMap$KeySet(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","WeakHashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$ValueIterator#this$0


    // ignoring method java.util.WeakHashMap$ValueIterator#WeakHashMap$ValueIterator(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$ValueIterator#next()
    // starting method java.util.WeakHashMap$ValueIterator#WeakHashMap$ValueIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$ValueIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$ValueIterator#WeakHashMap$ValueIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$Values");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$Values#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$Values#this$0


    // ignoring method java.util.WeakHashMap$Values#WeakHashMap$Values(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$Values#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#iterator()
    // starting method java.util.WeakHashMap$Values#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#size()
    // starting method java.util.WeakHashMap$Values#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#contains(java.lang.Object)
    // starting method java.util.WeakHashMap$Values#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#clear()
    // starting method java.util.WeakHashMap$Values#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#toArray()
    // starting method java.util.WeakHashMap$Values#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#toArray(java.lang.Object[])
    // starting method java.util.WeakHashMap$Values#WeakHashMap$Values(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$Values(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$Values");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#WeakHashMap$Values(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$Values
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 

// ignoring field java.util.WeakHashMap#DEFAULT_INITIAL_CAPACITY 

// ignoring field java.util.WeakHashMap#MAXIMUM_CAPACITY 

// ignoring field java.util.WeakHashMap#DEFAULT_LOAD_FACTOR 

// ignoring field java.util.WeakHashMap#table 

// ignoring field java.util.WeakHashMap#size 

// ignoring field java.util.WeakHashMap#threshold 

// ignoring field java.util.WeakHashMap#loadFactor 

// ignoring field java.util.WeakHashMap#queue 

// ignoring field java.util.WeakHashMap#modCount 

// ignoring field java.util.WeakHashMap#NULL_KEY 

// ignoring field java.util.WeakHashMap#entrySet 


    // starting method java.util.WeakHashMap#WeakHashMap(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap(int, float)");
    method.setSimpleName("WeakHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#WeakHashMap(int, float)
    // starting method java.util.WeakHashMap#WeakHashMap(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap(int)");
    method.setSimpleName("WeakHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#WeakHashMap(int)
    // starting method java.util.WeakHashMap#WeakHashMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap()");
    method.setSimpleName("WeakHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#WeakHashMap()
    // starting method java.util.WeakHashMap#WeakHashMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap(java.util.Map)");
    method.setSimpleName("WeakHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#WeakHashMap(java.util.Map)
    // ignoring method java.util.WeakHashMap#maskNull(java.lang.Object)
    // ignoring method java.util.WeakHashMap#unmaskNull(java.lang.Object)
    // starting method java.util.WeakHashMap#eq(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"eq(java.lang.Object, java.lang.Object)");
    method.setSimpleName("eq");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#eq(java.lang.Object, java.lang.Object)
    // starting method java.util.WeakHashMap#indexFor(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexFor(int, int)");
    method.setSimpleName("indexFor");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#indexFor(int, int)
    // ignoring method java.util.WeakHashMap#expungeStaleEntries()
    // ignoring method java.util.WeakHashMap#getTable()
    // starting method java.util.WeakHashMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#size()
    // starting method java.util.WeakHashMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#isEmpty()
    // starting method java.util.WeakHashMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#get(java.lang.Object)
    // starting method java.util.WeakHashMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#containsKey(java.lang.Object)
    // starting method java.util.WeakHashMap#getEntry(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getEntry(java.lang.Object)");
    method.setSimpleName("getEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#getEntry(java.lang.Object)
    // starting method java.util.WeakHashMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.WeakHashMap#resize(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"resize(int)");
    method.setSimpleName("resize");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#resize(int)
    // ignoring method java.util.WeakHashMap#transfer(java.util.WeakHashMap$Entry[], java.util.WeakHashMap$Entry[])
    // starting method java.util.WeakHashMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#putAll(java.util.Map)
    // starting method java.util.WeakHashMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#remove(java.lang.Object)
    // starting method java.util.WeakHashMap#removeMapping(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeMapping(java.lang.Object)");
    method.setSimpleName("removeMapping");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#removeMapping(java.lang.Object)
    // starting method java.util.WeakHashMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#clear()
    // starting method java.util.WeakHashMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#containsValue(java.lang.Object)
    // ignoring method java.util.WeakHashMap#containsNullValue()
    // starting method java.util.WeakHashMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#keySet()
    // starting method java.util.WeakHashMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#values()
    // starting method java.util.WeakHashMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#entrySet()
    // starting method java.util.WeakHashMap#access$300(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.lang.Object)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#access$300(java.lang.Object)
    // starting method java.util.WeakHashMap#access$400(java.util.WeakHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.WeakHashMap)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#access$400(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap#access$500(java.util.WeakHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$500(java.util.WeakHashMap)");
    method.setSimpleName("access$500");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#access$500(java.util.WeakHashMap)

// finishing type java.util.WeakHashMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.XMLUtils$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$EH");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ErrorHandler 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"org.xml.sax","ErrorHandler");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ErrorHandler 


    // ignoring method java.util.XMLUtils$EH#XMLUtils$EH()
    // starting method java.util.XMLUtils$EH#error(org.xml.sax.SAXParseException)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"error(org.xml.sax.SAXParseException)");
    method.setSimpleName("error");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
    
    // finishing method java.util.XMLUtils$EH#error(org.xml.sax.SAXParseException)
    // starting method java.util.XMLUtils$EH#fatalError(org.xml.sax.SAXParseException)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fatalError(org.xml.sax.SAXParseException)");
    method.setSimpleName("fatalError");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
    
    // finishing method java.util.XMLUtils$EH#fatalError(org.xml.sax.SAXParseException)
    // starting method java.util.XMLUtils$EH#warning(org.xml.sax.SAXParseException)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"warning(org.xml.sax.SAXParseException)");
    method.setSimpleName("warning");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
    
    // finishing method java.util.XMLUtils$EH#warning(org.xml.sax.SAXParseException)
    // starting method java.util.XMLUtils$EH#XMLUtils$EH(java.util.XMLUtils$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"XMLUtils$EH(java.util.XMLUtils$1)");
    method.setSimpleName("XMLUtils$EH");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.XMLUtils$EH#XMLUtils$EH(java.util.XMLUtils$1)

// finishing type java.util.XMLUtils$EH
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$Resolver");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface EntityResolver 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"org.xml.sax","EntityResolver");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface EntityResolver 


    // ignoring method java.util.XMLUtils$Resolver#XMLUtils$Resolver()
    // starting method java.util.XMLUtils$Resolver#resolveEntity(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"resolveEntity(java.lang.String, java.lang.String)");
    method.setSimpleName("resolveEntity");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","InputSource");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
    
    // finishing method java.util.XMLUtils$Resolver#resolveEntity(java.lang.String, java.lang.String)
    // starting method java.util.XMLUtils$Resolver#XMLUtils$Resolver(java.util.XMLUtils$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"XMLUtils$Resolver(java.util.XMLUtils$1)");
    method.setSimpleName("XMLUtils$Resolver");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.XMLUtils$Resolver#XMLUtils$Resolver(java.util.XMLUtils$1)

// finishing type java.util.XMLUtils$Resolver
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.XMLUtils#PROPS_DTD_URI 

// ignoring field java.util.XMLUtils#PROPS_DTD 

// ignoring field java.util.XMLUtils#EXTERNAL_XML_VERSION 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.XMLUtils#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.XMLUtils#$assertionsDisabled


    // starting method java.util.XMLUtils#XMLUtils()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"XMLUtils()");
    method.setSimpleName("XMLUtils");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.XMLUtils#XMLUtils()
    // starting method java.util.XMLUtils#load(java.util.Properties, java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"load(java.util.Properties, java.io.InputStream)");
    method.setSimpleName("load");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.util","InvalidPropertiesFormatException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.util.InvalidPropertiesFormatException
    
    // finishing method java.util.XMLUtils#load(java.util.Properties, java.io.InputStream)
    // starting method java.util.XMLUtils#getLoadingDoc(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLoadingDoc(java.io.InputStream)");
    method.setSimpleName("getLoadingDoc");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "org.w3c.dom","Document");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.XMLUtils#getLoadingDoc(java.io.InputStream)
    // starting method java.util.XMLUtils#importProperties(java.util.Properties, org.w3c.dom.Element)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"importProperties(java.util.Properties, org.w3c.dom.Element)");
    method.setSimpleName("importProperties");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.XMLUtils#importProperties(java.util.Properties, org.w3c.dom.Element)
    // starting method java.util.XMLUtils#save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String)");
    method.setSimpleName("save");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.XMLUtils#save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String)
    // starting method java.util.XMLUtils#emitDocument(org.w3c.dom.Document, java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"emitDocument(org.w3c.dom.Document, java.io.OutputStream, java.lang.String)");
    method.setSimpleName("emitDocument");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.XMLUtils#emitDocument(org.w3c.dom.Document, java.io.OutputStream, java.lang.String)

// finishing type java.util.XMLUtils
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 


    // starting method java.util.AbstractCollection#AbstractCollection()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractCollection()");
    method.setSimpleName("AbstractCollection");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#AbstractCollection()
    // starting method java.util.AbstractCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#iterator()
    // starting method java.util.AbstractCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#size()
    // starting method java.util.AbstractCollection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#isEmpty()
    // starting method java.util.AbstractCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#contains(java.lang.Object)
    // starting method java.util.AbstractCollection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#toArray()
    // starting method java.util.AbstractCollection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#toArray(java.lang.Object[])
    // starting method java.util.AbstractCollection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#add(java.lang.Object)
    // starting method java.util.AbstractCollection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#remove(java.lang.Object)
    // starting method java.util.AbstractCollection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#containsAll(java.util.Collection)
    // starting method java.util.AbstractCollection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#addAll(java.util.Collection)
    // starting method java.util.AbstractCollection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#removeAll(java.util.Collection)
    // starting method java.util.AbstractCollection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#retainAll(java.util.Collection)
    // starting method java.util.AbstractCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#clear()
    // starting method java.util.AbstractCollection#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractCollection#toString()

// finishing type java.util.AbstractCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.AbstractList$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$Itr");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$Itr#cursor
	field = newType.addNode(JavaDataField.class,"cursor"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$Itr#cursor

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$Itr#lastRet
	field = newType.addNode(JavaDataField.class,"lastRet"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$Itr#lastRet

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$Itr#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$Itr#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$Itr#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$Itr#this$0


    // ignoring method java.util.AbstractList$Itr#AbstractList$Itr(java.util.AbstractList)
    // starting method java.util.AbstractList$Itr#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#hasNext()
    // starting method java.util.AbstractList$Itr#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#next()
    // starting method java.util.AbstractList$Itr#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#remove()
    // starting method java.util.AbstractList$Itr#checkForComodification()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkForComodification()");
    method.setSimpleName("checkForComodification");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#checkForComodification()
    // starting method java.util.AbstractList$Itr#AbstractList$Itr(java.util.AbstractList, java.util.AbstractList$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractList$Itr(java.util.AbstractList, java.util.AbstractList$1)");
    method.setSimpleName("AbstractList$Itr");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$Itr#AbstractList$Itr(java.util.AbstractList, java.util.AbstractList$1)

// finishing type java.util.AbstractList$Itr
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList$ListItr");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList$Itr");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList$ListItr#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractList$ListItr#this$0


    // starting method java.util.AbstractList$ListItr#AbstractList$ListItr(java.util.AbstractList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractList$ListItr(java.util.AbstractList, int)");
    method.setSimpleName("AbstractList$ListItr");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#AbstractList$ListItr(java.util.AbstractList, int)
    // starting method java.util.AbstractList$ListItr#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#hasPrevious()
    // starting method java.util.AbstractList$ListItr#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#previous()
    // starting method java.util.AbstractList$ListItr#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#nextIndex()
    // starting method java.util.AbstractList$ListItr#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#previousIndex()
    // starting method java.util.AbstractList$ListItr#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#set(java.lang.Object)
    // starting method java.util.AbstractList$ListItr#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList$ListItr#add(java.lang.Object)

// finishing type java.util.AbstractList$ListItr
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractList#modCount
	field = newType.addNode(JavaDataField.class,"modCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 132, isArray, arrayDimensions);
    // finishing field java.util.AbstractList#modCount


    // starting method java.util.AbstractList#AbstractList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractList()");
    method.setSimpleName("AbstractList");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#AbstractList()
    // starting method java.util.AbstractList#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#add(java.lang.Object)
    // starting method java.util.AbstractList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#get(int)
    // starting method java.util.AbstractList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#set(int, java.lang.Object)
    // starting method java.util.AbstractList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#add(int, java.lang.Object)
    // starting method java.util.AbstractList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#remove(int)
    // starting method java.util.AbstractList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#indexOf(java.lang.Object)
    // starting method java.util.AbstractList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#lastIndexOf(java.lang.Object)
    // starting method java.util.AbstractList#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#clear()
    // starting method java.util.AbstractList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#addAll(int, java.util.Collection)
    // starting method java.util.AbstractList#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#iterator()
    // starting method java.util.AbstractList#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#listIterator()
    // starting method java.util.AbstractList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#listIterator(int)
    // starting method java.util.AbstractList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#subList(int, int)
    // starting method java.util.AbstractList#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#equals(java.lang.Object)
    // starting method java.util.AbstractList#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#hashCode()
    // starting method java.util.AbstractList#removeRange(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeRange(int, int)");
    method.setSimpleName("removeRange");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractList#removeRange(int, int)

// finishing type java.util.AbstractList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$1$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.AbstractMap$1$1#i 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$1$1#this$1
	field = newType.addNode(JavaDataField.class,"this$1"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractMap$1");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$1$1#this$1


    // starting method java.util.AbstractMap$1$1#AbstractMap$1$1(java.util.AbstractMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$1$1(java.util.AbstractMap$1)");
    method.setSimpleName("AbstractMap$1$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1$1#AbstractMap$1$1(java.util.AbstractMap$1)
    // starting method java.util.AbstractMap$1$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1$1#hasNext()
    // starting method java.util.AbstractMap$1$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1$1#next()
    // starting method java.util.AbstractMap$1$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1$1#remove()

// finishing type java.util.AbstractMap$1$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$1#this$0


    // starting method java.util.AbstractMap$1#AbstractMap$1(java.util.AbstractMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$1(java.util.AbstractMap)");
    method.setSimpleName("AbstractMap$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1#AbstractMap$1(java.util.AbstractMap)
    // starting method java.util.AbstractMap$1#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1#iterator()
    // starting method java.util.AbstractMap$1#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1#size()
    // starting method java.util.AbstractMap$1#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$1#contains(java.lang.Object)

// finishing type java.util.AbstractMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$2$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.AbstractMap$2$1#i 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$2$1#this$1
	field = newType.addNode(JavaDataField.class,"this$1"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractMap$2");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$2$1#this$1


    // starting method java.util.AbstractMap$2$1#AbstractMap$2$1(java.util.AbstractMap$2)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$2$1(java.util.AbstractMap$2)");
    method.setSimpleName("AbstractMap$2$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2$1#AbstractMap$2$1(java.util.AbstractMap$2)
    // starting method java.util.AbstractMap$2$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2$1#hasNext()
    // starting method java.util.AbstractMap$2$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2$1#next()
    // starting method java.util.AbstractMap$2$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2$1#remove()

// finishing type java.util.AbstractMap$2$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$2");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$2#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$2#this$0


    // starting method java.util.AbstractMap$2#AbstractMap$2(java.util.AbstractMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$2(java.util.AbstractMap)");
    method.setSimpleName("AbstractMap$2");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2#AbstractMap$2(java.util.AbstractMap)
    // starting method java.util.AbstractMap$2#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2#iterator()
    // starting method java.util.AbstractMap$2#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2#size()
    // starting method java.util.AbstractMap$2#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$2#contains(java.lang.Object)

// finishing type java.util.AbstractMap$2
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap$SimpleEntry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$SimpleEntry#key
	field = newType.addNode(JavaDataField.class,"key"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$SimpleEntry#key

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap$SimpleEntry#value
	field = newType.addNode(JavaDataField.class,"value"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap$SimpleEntry#value


    // starting method java.util.AbstractMap$SimpleEntry#AbstractMap$SimpleEntry(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$SimpleEntry(java.lang.Object, java.lang.Object)");
    method.setSimpleName("AbstractMap$SimpleEntry");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#AbstractMap$SimpleEntry(java.lang.Object, java.lang.Object)
    // starting method java.util.AbstractMap$SimpleEntry#AbstractMap$SimpleEntry(java.util.Map$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap$SimpleEntry(java.util.Map$Entry)");
    method.setSimpleName("AbstractMap$SimpleEntry");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#AbstractMap$SimpleEntry(java.util.Map$Entry)
    // starting method java.util.AbstractMap$SimpleEntry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#getKey()
    // starting method java.util.AbstractMap$SimpleEntry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#getValue()
    // starting method java.util.AbstractMap$SimpleEntry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#setValue(java.lang.Object)
    // starting method java.util.AbstractMap$SimpleEntry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#equals(java.lang.Object)
    // starting method java.util.AbstractMap$SimpleEntry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#hashCode()
    // starting method java.util.AbstractMap$SimpleEntry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap$SimpleEntry#toString()
    // ignoring method java.util.AbstractMap$SimpleEntry#eq(java.lang.Object, java.lang.Object)

// finishing type java.util.AbstractMap$SimpleEntry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap#keySet
	field = newType.addNode(JavaDataField.class,"keySet"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    helper.insertFieldData(field, fieldType, 192, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap#keySet

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.AbstractMap#values
	field = newType.addNode(JavaDataField.class,"values"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 192, isArray, arrayDimensions);
    // finishing field java.util.AbstractMap#values


    // starting method java.util.AbstractMap#AbstractMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractMap()");
    method.setSimpleName("AbstractMap");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#AbstractMap()
    // starting method java.util.AbstractMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#size()
    // starting method java.util.AbstractMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#isEmpty()
    // starting method java.util.AbstractMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#containsValue(java.lang.Object)
    // starting method java.util.AbstractMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#containsKey(java.lang.Object)
    // starting method java.util.AbstractMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#get(java.lang.Object)
    // starting method java.util.AbstractMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.AbstractMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#remove(java.lang.Object)
    // starting method java.util.AbstractMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#putAll(java.util.Map)
    // starting method java.util.AbstractMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#clear()
    // starting method java.util.AbstractMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#keySet()
    // starting method java.util.AbstractMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#values()
    // starting method java.util.AbstractMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#entrySet()
    // starting method java.util.AbstractMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#equals(java.lang.Object)
    // starting method java.util.AbstractMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#hashCode()
    // starting method java.util.AbstractMap#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractMap#toString()
    // starting method java.util.AbstractMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","CloneNotSupportedException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.CloneNotSupportedException
    
    // finishing method java.util.AbstractMap#clone()

// finishing type java.util.AbstractMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractQueue");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Queue 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Queue");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Queue 


    // starting method java.util.AbstractQueue#AbstractQueue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractQueue()");
    method.setSimpleName("AbstractQueue");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#AbstractQueue()
    // starting method java.util.AbstractQueue#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#add(java.lang.Object)
    // starting method java.util.AbstractQueue#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#remove()
    // starting method java.util.AbstractQueue#element()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"element()");
    method.setSimpleName("element");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#element()
    // starting method java.util.AbstractQueue#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#clear()
    // starting method java.util.AbstractQueue#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractQueue#addAll(java.util.Collection)

// finishing type java.util.AbstractQueue
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractSequentialList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.AbstractSequentialList#AbstractSequentialList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractSequentialList()");
    method.setSimpleName("AbstractSequentialList");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#AbstractSequentialList()
    // starting method java.util.AbstractSequentialList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#get(int)
    // starting method java.util.AbstractSequentialList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#set(int, java.lang.Object)
    // starting method java.util.AbstractSequentialList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#add(int, java.lang.Object)
    // starting method java.util.AbstractSequentialList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#remove(int)
    // starting method java.util.AbstractSequentialList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#addAll(int, java.util.Collection)
    // starting method java.util.AbstractSequentialList#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#iterator()
    // starting method java.util.AbstractSequentialList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSequentialList#listIterator(int)

// finishing type java.util.AbstractSequentialList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "AbstractSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 


    // starting method java.util.AbstractSet#AbstractSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"AbstractSet()");
    method.setSimpleName("AbstractSet");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSet#AbstractSet()
    // starting method java.util.AbstractSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSet#equals(java.lang.Object)
    // starting method java.util.AbstractSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSet#hashCode()
    // starting method java.util.AbstractSet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.AbstractSet#removeAll(java.util.Collection)

// finishing type java.util.AbstractSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ArrayList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.ArrayList#serialVersionUID 

// ignoring field java.util.ArrayList#elementData 

// ignoring field java.util.ArrayList#size 


    // starting method java.util.ArrayList#ArrayList(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ArrayList(int)");
    method.setSimpleName("ArrayList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#ArrayList(int)
    // starting method java.util.ArrayList#ArrayList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ArrayList()");
    method.setSimpleName("ArrayList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#ArrayList()
    // starting method java.util.ArrayList#ArrayList(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ArrayList(java.util.Collection)");
    method.setSimpleName("ArrayList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#ArrayList(java.util.Collection)
    // starting method java.util.ArrayList#trimToSize()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"trimToSize()");
    method.setSimpleName("trimToSize");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#trimToSize()
    // starting method java.util.ArrayList#ensureCapacity(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"ensureCapacity(int)");
    method.setSimpleName("ensureCapacity");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#ensureCapacity(int)
    // starting method java.util.ArrayList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#size()
    // starting method java.util.ArrayList#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#isEmpty()
    // starting method java.util.ArrayList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#contains(java.lang.Object)
    // starting method java.util.ArrayList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#indexOf(java.lang.Object)
    // starting method java.util.ArrayList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#lastIndexOf(java.lang.Object)
    // starting method java.util.ArrayList#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#clone()
    // starting method java.util.ArrayList#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#toArray()
    // starting method java.util.ArrayList#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#toArray(java.lang.Object[])
    // starting method java.util.ArrayList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#get(int)
    // starting method java.util.ArrayList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#set(int, java.lang.Object)
    // starting method java.util.ArrayList#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#add(java.lang.Object)
    // starting method java.util.ArrayList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#add(int, java.lang.Object)
    // starting method java.util.ArrayList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#remove(int)
    // starting method java.util.ArrayList#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#remove(java.lang.Object)
    // ignoring method java.util.ArrayList#fastRemove(int)
    // starting method java.util.ArrayList#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#clear()
    // starting method java.util.ArrayList#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#addAll(java.util.Collection)
    // starting method java.util.ArrayList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#addAll(int, java.util.Collection)
    // starting method java.util.ArrayList#removeRange(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeRange(int, int)");
    method.setSimpleName("removeRange");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ArrayList#removeRange(int, int)
    // ignoring method java.util.ArrayList#RangeCheck(int)
    // ignoring method java.util.ArrayList#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.ArrayList#readObject(java.io.ObjectInputStream)

// finishing type java.util.ArrayList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Arrays$ArrayList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Arrays$ArrayList#serialVersionUID 

// ignoring field java.util.Arrays$ArrayList#a 


    // starting method java.util.Arrays$ArrayList#Arrays$ArrayList(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Arrays$ArrayList(java.lang.Object[])");
    method.setSimpleName("Arrays$ArrayList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#Arrays$ArrayList(java.lang.Object[])
    // starting method java.util.Arrays$ArrayList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#size()
    // starting method java.util.Arrays$ArrayList#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#toArray()
    // starting method java.util.Arrays$ArrayList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#get(int)
    // starting method java.util.Arrays$ArrayList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#set(int, java.lang.Object)
    // starting method java.util.Arrays$ArrayList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#indexOf(java.lang.Object)
    // starting method java.util.Arrays$ArrayList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays$ArrayList#contains(java.lang.Object)

// finishing type java.util.Arrays$ArrayList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Arrays");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Arrays#INSERTIONSORT_THRESHOLD 


    // ignoring method java.util.Arrays#Arrays()
    // starting method java.util.Arrays#sort(long[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(long[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(long[])
    // starting method java.util.Arrays#sort(long[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(long[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(long[], int, int)
    // starting method java.util.Arrays#sort(int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(int[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(int[])
    // starting method java.util.Arrays#sort(int[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(int[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(int[], int, int)
    // starting method java.util.Arrays#sort(short[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(short[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(short[])
    // starting method java.util.Arrays#sort(short[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(short[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(short[], int, int)
    // starting method java.util.Arrays#sort(char[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(char[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(char[])
    // starting method java.util.Arrays#sort(char[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(char[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(char[], int, int)
    // starting method java.util.Arrays#sort(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(byte[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(byte[])
    // starting method java.util.Arrays#sort(byte[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(byte[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(byte[], int, int)
    // starting method java.util.Arrays#sort(double[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(double[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(double[])
    // starting method java.util.Arrays#sort(double[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(double[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(double[], int, int)
    // starting method java.util.Arrays#sort(float[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(float[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(float[])
    // starting method java.util.Arrays#sort(float[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(float[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(float[], int, int)
    // ignoring method java.util.Arrays#sort2(double[], int, int)
    // ignoring method java.util.Arrays#sort2(float[], int, int)
    // ignoring method java.util.Arrays#sort1(long[], int, int)
    // ignoring method java.util.Arrays#swap(long[], int, int)
    // ignoring method java.util.Arrays#vecswap(long[], int, int, int)
    // ignoring method java.util.Arrays#med3(long[], int, int, int)
    // ignoring method java.util.Arrays#sort1(int[], int, int)
    // ignoring method java.util.Arrays#swap(int[], int, int)
    // ignoring method java.util.Arrays#vecswap(int[], int, int, int)
    // ignoring method java.util.Arrays#med3(int[], int, int, int)
    // ignoring method java.util.Arrays#sort1(short[], int, int)
    // ignoring method java.util.Arrays#swap(short[], int, int)
    // ignoring method java.util.Arrays#vecswap(short[], int, int, int)
    // ignoring method java.util.Arrays#med3(short[], int, int, int)
    // ignoring method java.util.Arrays#sort1(char[], int, int)
    // ignoring method java.util.Arrays#swap(char[], int, int)
    // ignoring method java.util.Arrays#vecswap(char[], int, int, int)
    // ignoring method java.util.Arrays#med3(char[], int, int, int)
    // ignoring method java.util.Arrays#sort1(byte[], int, int)
    // ignoring method java.util.Arrays#swap(byte[], int, int)
    // ignoring method java.util.Arrays#vecswap(byte[], int, int, int)
    // ignoring method java.util.Arrays#med3(byte[], int, int, int)
    // ignoring method java.util.Arrays#sort1(double[], int, int)
    // ignoring method java.util.Arrays#swap(double[], int, int)
    // ignoring method java.util.Arrays#vecswap(double[], int, int, int)
    // ignoring method java.util.Arrays#med3(double[], int, int, int)
    // ignoring method java.util.Arrays#sort1(float[], int, int)
    // ignoring method java.util.Arrays#swap(float[], int, int)
    // ignoring method java.util.Arrays#vecswap(float[], int, int, int)
    // ignoring method java.util.Arrays#med3(float[], int, int, int)
    // starting method java.util.Arrays#sort(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.lang.Object[])");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(java.lang.Object[])
    // starting method java.util.Arrays#sort(java.lang.Object[], int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.lang.Object[], int, int)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(java.lang.Object[], int, int)
    // ignoring method java.util.Arrays#cloneSubarray(java.lang.Object[], int, int)
    // ignoring method java.util.Arrays#mergeSort(java.lang.Object[], java.lang.Object[], int, int, int)
    // ignoring method java.util.Arrays#swap(java.lang.Object[], int, int)
    // starting method java.util.Arrays#sort(java.lang.Object[], java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.lang.Object[], java.util.Comparator)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(java.lang.Object[], java.util.Comparator)
    // starting method java.util.Arrays#sort(java.lang.Object[], int, int, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.lang.Object[], int, int, java.util.Comparator)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#sort(java.lang.Object[], int, int, java.util.Comparator)
    // ignoring method java.util.Arrays#mergeSort(java.lang.Object[], java.lang.Object[], int, int, int, java.util.Comparator)
    // ignoring method java.util.Arrays#rangeCheck(int, int, int)
    // starting method java.util.Arrays#binarySearch(long[], long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(long[], long)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(long[], long)
    // starting method java.util.Arrays#binarySearch(int[], int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(int[], int)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(int[], int)
    // starting method java.util.Arrays#binarySearch(short[], short)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(short[], short)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(short[], short)
    // starting method java.util.Arrays#binarySearch(char[], char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(char[], char)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(char[], char)
    // starting method java.util.Arrays#binarySearch(byte[], byte)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(byte[], byte)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(byte[], byte)
    // starting method java.util.Arrays#binarySearch(double[], double)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(double[], double)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(double[], double)
    // ignoring method java.util.Arrays#binarySearch(double[], double, int, int)
    // starting method java.util.Arrays#binarySearch(float[], float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(float[], float)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(float[], float)
    // ignoring method java.util.Arrays#binarySearch(float[], float, int, int)
    // starting method java.util.Arrays#binarySearch(java.lang.Object[], java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(java.lang.Object[], java.lang.Object)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(java.lang.Object[], java.lang.Object)
    // starting method java.util.Arrays#binarySearch(java.lang.Object[], java.lang.Object, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(java.lang.Object[], java.lang.Object, java.util.Comparator)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#binarySearch(java.lang.Object[], java.lang.Object, java.util.Comparator)
    // starting method java.util.Arrays#equals(long[], long[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(long[], long[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(long[], long[])
    // starting method java.util.Arrays#equals(int[], int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(int[], int[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(int[], int[])
    // starting method java.util.Arrays#equals(short[], short[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(short[], short[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(short[], short[])
    // starting method java.util.Arrays#equals(char[], char[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(char[], char[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(char[], char[])
    // starting method java.util.Arrays#equals(byte[], byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(byte[], byte[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(byte[], byte[])
    // starting method java.util.Arrays#equals(boolean[], boolean[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(boolean[], boolean[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(boolean[], boolean[])
    // starting method java.util.Arrays#equals(double[], double[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(double[], double[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(double[], double[])
    // starting method java.util.Arrays#equals(float[], float[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(float[], float[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(float[], float[])
    // starting method java.util.Arrays#equals(java.lang.Object[], java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object[], java.lang.Object[])");
    method.setSimpleName("equals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#equals(java.lang.Object[], java.lang.Object[])
    // starting method java.util.Arrays#fill(long[], long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(long[], long)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(long[], long)
    // starting method java.util.Arrays#fill(long[], int, int, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(long[], int, int, long)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(long[], int, int, long)
    // starting method java.util.Arrays#fill(int[], int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(int[], int)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(int[], int)
    // starting method java.util.Arrays#fill(int[], int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(int[], int, int, int)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(int[], int, int, int)
    // starting method java.util.Arrays#fill(short[], short)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(short[], short)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(short[], short)
    // starting method java.util.Arrays#fill(short[], int, int, short)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(short[], int, int, short)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(short[], int, int, short)
    // starting method java.util.Arrays#fill(char[], char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(char[], char)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(char[], char)
    // starting method java.util.Arrays#fill(char[], int, int, char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(char[], int, int, char)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(char[], int, int, char)
    // starting method java.util.Arrays#fill(byte[], byte)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(byte[], byte)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(byte[], byte)
    // starting method java.util.Arrays#fill(byte[], int, int, byte)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(byte[], int, int, byte)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(byte[], int, int, byte)
    // starting method java.util.Arrays#fill(boolean[], boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(boolean[], boolean)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(boolean[], boolean)
    // starting method java.util.Arrays#fill(boolean[], int, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(boolean[], int, int, boolean)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(boolean[], int, int, boolean)
    // starting method java.util.Arrays#fill(double[], double)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(double[], double)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(double[], double)
    // starting method java.util.Arrays#fill(double[], int, int, double)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(double[], int, int, double)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(double[], int, int, double)
    // starting method java.util.Arrays#fill(float[], float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(float[], float)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(float[], float)
    // starting method java.util.Arrays#fill(float[], int, int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(float[], int, int, float)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(float[], int, int, float)
    // starting method java.util.Arrays#fill(java.lang.Object[], java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(java.lang.Object[], java.lang.Object)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(java.lang.Object[], java.lang.Object)
    // starting method java.util.Arrays#fill(java.lang.Object[], int, int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(java.lang.Object[], int, int, java.lang.Object)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#fill(java.lang.Object[], int, int, java.lang.Object)
    // starting method java.util.Arrays#asList(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"asList(java.lang.Object[])");
    method.setSimpleName("asList");
    helper.setMethodData(method,137);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#asList(java.lang.Object[])
    // starting method java.util.Arrays#hashCode(long[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(long[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(long[])
    // starting method java.util.Arrays#hashCode(int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(int[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(int[])
    // starting method java.util.Arrays#hashCode(short[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(short[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(short[])
    // starting method java.util.Arrays#hashCode(char[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(char[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(char[])
    // starting method java.util.Arrays#hashCode(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(byte[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(byte[])
    // starting method java.util.Arrays#hashCode(boolean[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(boolean[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(boolean[])
    // starting method java.util.Arrays#hashCode(float[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(float[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(float[])
    // starting method java.util.Arrays#hashCode(double[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(double[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(double[])
    // starting method java.util.Arrays#hashCode(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode(java.lang.Object[])");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#hashCode(java.lang.Object[])
    // starting method java.util.Arrays#deepHashCode(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deepHashCode(java.lang.Object[])");
    method.setSimpleName("deepHashCode");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#deepHashCode(java.lang.Object[])
    // starting method java.util.Arrays#deepEquals(java.lang.Object[], java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deepEquals(java.lang.Object[], java.lang.Object[])");
    method.setSimpleName("deepEquals");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#deepEquals(java.lang.Object[], java.lang.Object[])
    // starting method java.util.Arrays#toString(long[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(long[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(long[])
    // starting method java.util.Arrays#toString(int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(int[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(int[])
    // starting method java.util.Arrays#toString(short[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(short[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(short[])
    // starting method java.util.Arrays#toString(char[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(char[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(char[])
    // starting method java.util.Arrays#toString(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(byte[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(byte[])
    // starting method java.util.Arrays#toString(boolean[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(boolean[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(boolean[])
    // starting method java.util.Arrays#toString(float[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(float[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(float[])
    // starting method java.util.Arrays#toString(double[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(double[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(double[])
    // starting method java.util.Arrays#toString(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(java.lang.Object[])");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#toString(java.lang.Object[])
    // starting method java.util.Arrays#deepToString(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deepToString(java.lang.Object[])");
    method.setSimpleName("deepToString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Arrays#deepToString(java.lang.Object[])
    // ignoring method java.util.Arrays#deepToString(java.lang.Object[], java.lang.StringBuilder, java.util.Set)

// finishing type java.util.Arrays
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "BitSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.BitSet#ADDRESS_BITS_PER_UNIT 

// ignoring field java.util.BitSet#BITS_PER_UNIT 

// ignoring field java.util.BitSet#BIT_INDEX_MASK 

// ignoring field java.util.BitSet#WORD_MASK 

// ignoring field java.util.BitSet#bits 

// ignoring field java.util.BitSet#unitsInUse 

// ignoring field java.util.BitSet#serialVersionUID 

// ignoring field java.util.BitSet#trailingZeroTable 


    // ignoring method java.util.BitSet#unitIndex(int)
    // ignoring method java.util.BitSet#bit(int)
    // ignoring method java.util.BitSet#recalculateUnitsInUse()
    // starting method java.util.BitSet#BitSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"BitSet()");
    method.setSimpleName("BitSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#BitSet()
    // starting method java.util.BitSet#BitSet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"BitSet(int)");
    method.setSimpleName("BitSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#BitSet(int)
    // ignoring method java.util.BitSet#ensureCapacity(int)
    // starting method java.util.BitSet#flip(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"flip(int)");
    method.setSimpleName("flip");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#flip(int)
    // starting method java.util.BitSet#flip(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"flip(int, int)");
    method.setSimpleName("flip");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#flip(int, int)
    // ignoring method java.util.BitSet#bitsRightOf(int)
    // ignoring method java.util.BitSet#bitsLeftOf(int)
    // starting method java.util.BitSet#set(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#set(int)
    // starting method java.util.BitSet#set(int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, boolean)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#set(int, boolean)
    // starting method java.util.BitSet#set(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#set(int, int)
    // starting method java.util.BitSet#set(int, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int, boolean)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#set(int, int, boolean)
    // starting method java.util.BitSet#clear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear(int)");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#clear(int)
    // starting method java.util.BitSet#clear(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear(int, int)");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#clear(int, int)
    // starting method java.util.BitSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#clear()
    // starting method java.util.BitSet#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#get(int)
    // starting method java.util.BitSet#get(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int, int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","BitSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#get(int, int)
    // ignoring method java.util.BitSet#getBits(int)
    // starting method java.util.BitSet#nextSetBit(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextSetBit(int)");
    method.setSimpleName("nextSetBit");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#nextSetBit(int)
    // ignoring method java.util.BitSet#trailingZeroCnt(long)
    // starting method java.util.BitSet#nextClearBit(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextClearBit(int)");
    method.setSimpleName("nextClearBit");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#nextClearBit(int)
    // starting method java.util.BitSet#length()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"length()");
    method.setSimpleName("length");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#length()
    // ignoring method java.util.BitSet#bitLen(int)
    // starting method java.util.BitSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#isEmpty()
    // starting method java.util.BitSet#intersects(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"intersects(java.util.BitSet)");
    method.setSimpleName("intersects");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#intersects(java.util.BitSet)
    // starting method java.util.BitSet#cardinality()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"cardinality()");
    method.setSimpleName("cardinality");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#cardinality()
    // ignoring method java.util.BitSet#bitCount(long)
    // starting method java.util.BitSet#and(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"and(java.util.BitSet)");
    method.setSimpleName("and");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#and(java.util.BitSet)
    // starting method java.util.BitSet#or(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"or(java.util.BitSet)");
    method.setSimpleName("or");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#or(java.util.BitSet)
    // starting method java.util.BitSet#xor(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"xor(java.util.BitSet)");
    method.setSimpleName("xor");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#xor(java.util.BitSet)
    // starting method java.util.BitSet#andNot(java.util.BitSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"andNot(java.util.BitSet)");
    method.setSimpleName("andNot");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#andNot(java.util.BitSet)
    // starting method java.util.BitSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#hashCode()
    // starting method java.util.BitSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#size()
    // starting method java.util.BitSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#equals(java.lang.Object)
    // starting method java.util.BitSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#clone()
    // ignoring method java.util.BitSet#readObject(java.io.ObjectInputStream)
    // starting method java.util.BitSet#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.BitSet#toString()

// finishing type java.util.BitSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Calendar$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface PrivilegedExceptionAction 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PrivilegedExceptionAction");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface PrivilegedExceptionAction 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar$1#val$input
	field = newType.addNode(JavaDataField.class,"val$input"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.io","ObjectInputStream");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Calendar$1#val$input

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Calendar$1#this$0


    // starting method java.util.Calendar$1#Calendar$1(java.util.Calendar, java.io.ObjectInputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Calendar$1(java.util.Calendar, java.io.ObjectInputStream)");
    method.setSimpleName("Calendar$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","ClassNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.ClassNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Calendar$1#Calendar$1(java.util.Calendar, java.io.ObjectInputStream)
    // starting method java.util.Calendar$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "sun.util.calendar","ZoneInfo");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Exception");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.Exception
    
    // finishing method java.util.Calendar$1#run()
    // starting method java.util.Calendar$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Exception");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.Exception
    
    // finishing method java.util.Calendar$1#run()

// finishing type java.util.Calendar$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Calendar$CalendarAccessControlContext");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Calendar$CalendarAccessControlContext#INSTANCE 


    // ignoring method java.util.Calendar$CalendarAccessControlContext#Calendar$CalendarAccessControlContext()
    // starting method java.util.Calendar$CalendarAccessControlContext#access$000()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000()");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.security","AccessControlContext");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar$CalendarAccessControlContext#access$000()

// finishing type java.util.Calendar$CalendarAccessControlContext
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Calendar");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Comparable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Comparable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ERA
	field = newType.addNode(JavaDataField.class,"ERA"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ERA

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#YEAR
	field = newType.addNode(JavaDataField.class,"YEAR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#YEAR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MONTH
	field = newType.addNode(JavaDataField.class,"MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEEK_OF_YEAR
	field = newType.addNode(JavaDataField.class,"WEEK_OF_YEAR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEEK_OF_YEAR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEEK_OF_MONTH
	field = newType.addNode(JavaDataField.class,"WEEK_OF_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEEK_OF_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DATE
	field = newType.addNode(JavaDataField.class,"DATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DATE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_MONTH
	field = newType.addNode(JavaDataField.class,"DAY_OF_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_YEAR
	field = newType.addNode(JavaDataField.class,"DAY_OF_YEAR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_YEAR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_WEEK
	field = newType.addNode(JavaDataField.class,"DAY_OF_WEEK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_WEEK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_WEEK_IN_MONTH
	field = newType.addNode(JavaDataField.class,"DAY_OF_WEEK_IN_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_WEEK_IN_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#AM_PM
	field = newType.addNode(JavaDataField.class,"AM_PM"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#AM_PM

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#HOUR
	field = newType.addNode(JavaDataField.class,"HOUR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#HOUR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#HOUR_OF_DAY
	field = newType.addNode(JavaDataField.class,"HOUR_OF_DAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#HOUR_OF_DAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MINUTE
	field = newType.addNode(JavaDataField.class,"MINUTE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MINUTE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SECOND
	field = newType.addNode(JavaDataField.class,"SECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MILLISECOND
	field = newType.addNode(JavaDataField.class,"MILLISECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MILLISECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ZONE_OFFSET
	field = newType.addNode(JavaDataField.class,"ZONE_OFFSET"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ZONE_OFFSET

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DST_OFFSET
	field = newType.addNode(JavaDataField.class,"DST_OFFSET"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DST_OFFSET

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#FIELD_COUNT
	field = newType.addNode(JavaDataField.class,"FIELD_COUNT"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#FIELD_COUNT

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SUNDAY
	field = newType.addNode(JavaDataField.class,"SUNDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SUNDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MONDAY
	field = newType.addNode(JavaDataField.class,"MONDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MONDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#TUESDAY
	field = newType.addNode(JavaDataField.class,"TUESDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#TUESDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEDNESDAY
	field = newType.addNode(JavaDataField.class,"WEDNESDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEDNESDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#THURSDAY
	field = newType.addNode(JavaDataField.class,"THURSDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#THURSDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#FRIDAY
	field = newType.addNode(JavaDataField.class,"FRIDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#FRIDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SATURDAY
	field = newType.addNode(JavaDataField.class,"SATURDAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SATURDAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#JANUARY
	field = newType.addNode(JavaDataField.class,"JANUARY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#JANUARY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#FEBRUARY
	field = newType.addNode(JavaDataField.class,"FEBRUARY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#FEBRUARY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MARCH
	field = newType.addNode(JavaDataField.class,"MARCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MARCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#APRIL
	field = newType.addNode(JavaDataField.class,"APRIL"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#APRIL

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MAY
	field = newType.addNode(JavaDataField.class,"MAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#JUNE
	field = newType.addNode(JavaDataField.class,"JUNE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#JUNE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#JULY
	field = newType.addNode(JavaDataField.class,"JULY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#JULY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#AUGUST
	field = newType.addNode(JavaDataField.class,"AUGUST"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#AUGUST

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SEPTEMBER
	field = newType.addNode(JavaDataField.class,"SEPTEMBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SEPTEMBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#OCTOBER
	field = newType.addNode(JavaDataField.class,"OCTOBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#OCTOBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#NOVEMBER
	field = newType.addNode(JavaDataField.class,"NOVEMBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#NOVEMBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DECEMBER
	field = newType.addNode(JavaDataField.class,"DECEMBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DECEMBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#UNDECIMBER
	field = newType.addNode(JavaDataField.class,"UNDECIMBER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#UNDECIMBER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#AM
	field = newType.addNode(JavaDataField.class,"AM"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#AM

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#PM
	field = newType.addNode(JavaDataField.class,"PM"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Calendar#PM

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#fields
	field = newType.addNode(JavaDataField.class,"fields"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#fields

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#isSet
	field = newType.addNode(JavaDataField.class,"isSet"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#isSet

// ignoring field java.util.Calendar#stamp 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#time
	field = newType.addNode(JavaDataField.class,"time"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#time

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#isTimeSet
	field = newType.addNode(JavaDataField.class,"isTimeSet"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#isTimeSet

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#areFieldsSet
	field = newType.addNode(JavaDataField.class,"areFieldsSet"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Calendar#areFieldsSet

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#areAllFieldsSet
	field = newType.addNode(JavaDataField.class,"areAllFieldsSet"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 128, isArray, arrayDimensions);
    // finishing field java.util.Calendar#areAllFieldsSet

// ignoring field java.util.Calendar#lenient 

// ignoring field java.util.Calendar#zone 

// ignoring field java.util.Calendar#sharedZone 

// ignoring field java.util.Calendar#firstDayOfWeek 

// ignoring field java.util.Calendar#minimalDaysInFirstWeek 

// ignoring field java.util.Calendar#cachedLocaleData 

// ignoring field java.util.Calendar#UNSET 

// ignoring field java.util.Calendar#COMPUTED 

// ignoring field java.util.Calendar#MINIMUM_USER_STAMP 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ALL_FIELDS
	field = newType.addNode(JavaDataField.class,"ALL_FIELDS"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ALL_FIELDS

// ignoring field java.util.Calendar#nextStamp 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#currentSerialVersion
	field = newType.addNode(JavaDataField.class,"currentSerialVersion"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#currentSerialVersion

// ignoring field java.util.Calendar#serialVersionOnStream 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ERA_MASK
	field = newType.addNode(JavaDataField.class,"ERA_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ERA_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#YEAR_MASK
	field = newType.addNode(JavaDataField.class,"YEAR_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#YEAR_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MONTH_MASK
	field = newType.addNode(JavaDataField.class,"MONTH_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MONTH_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEEK_OF_YEAR_MASK
	field = newType.addNode(JavaDataField.class,"WEEK_OF_YEAR_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEEK_OF_YEAR_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#WEEK_OF_MONTH_MASK
	field = newType.addNode(JavaDataField.class,"WEEK_OF_MONTH_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#WEEK_OF_MONTH_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_MONTH_MASK
	field = newType.addNode(JavaDataField.class,"DAY_OF_MONTH_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_MONTH_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DATE_MASK
	field = newType.addNode(JavaDataField.class,"DATE_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DATE_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_YEAR_MASK
	field = newType.addNode(JavaDataField.class,"DAY_OF_YEAR_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_YEAR_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_WEEK_MASK
	field = newType.addNode(JavaDataField.class,"DAY_OF_WEEK_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_WEEK_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DAY_OF_WEEK_IN_MONTH_MASK
	field = newType.addNode(JavaDataField.class,"DAY_OF_WEEK_IN_MONTH_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DAY_OF_WEEK_IN_MONTH_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#AM_PM_MASK
	field = newType.addNode(JavaDataField.class,"AM_PM_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#AM_PM_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#HOUR_MASK
	field = newType.addNode(JavaDataField.class,"HOUR_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#HOUR_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#HOUR_OF_DAY_MASK
	field = newType.addNode(JavaDataField.class,"HOUR_OF_DAY_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#HOUR_OF_DAY_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MINUTE_MASK
	field = newType.addNode(JavaDataField.class,"MINUTE_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MINUTE_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#SECOND_MASK
	field = newType.addNode(JavaDataField.class,"SECOND_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#SECOND_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#MILLISECOND_MASK
	field = newType.addNode(JavaDataField.class,"MILLISECOND_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#MILLISECOND_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#ZONE_OFFSET_MASK
	field = newType.addNode(JavaDataField.class,"ZONE_OFFSET_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#ZONE_OFFSET_MASK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#DST_OFFSET_MASK
	field = newType.addNode(JavaDataField.class,"DST_OFFSET_MASK"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Calendar#DST_OFFSET_MASK

// ignoring field java.util.Calendar#FIELD_NAME 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Calendar#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.Calendar#$assertionsDisabled


    // starting method java.util.Calendar#Calendar()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Calendar()");
    method.setSimpleName("Calendar");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#Calendar()
    // starting method java.util.Calendar#Calendar(java.util.TimeZone, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Calendar(java.util.TimeZone, java.util.Locale)");
    method.setSimpleName("Calendar");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#Calendar(java.util.TimeZone, java.util.Locale)
    // starting method java.util.Calendar#getInstance()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance()");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getInstance()
    // starting method java.util.Calendar#getInstance(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.util.TimeZone)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getInstance(java.util.TimeZone)
    // starting method java.util.Calendar#getInstance(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.util.Locale)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getInstance(java.util.Locale)
    // starting method java.util.Calendar#getInstance(java.util.TimeZone, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.util.TimeZone, java.util.Locale)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Calendar");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getInstance(java.util.TimeZone, java.util.Locale)
    // ignoring method java.util.Calendar#createCalendar(java.util.TimeZone, java.util.Locale)
    // starting method java.util.Calendar#getAvailableLocales()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getAvailableLocales()");
    method.setSimpleName("getAvailableLocales");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getAvailableLocales()
    // starting method java.util.Calendar#computeTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"computeTime()");
    method.setSimpleName("computeTime");
    helper.setMethodData(method,1028);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#computeTime()
    // starting method java.util.Calendar#computeFields()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"computeFields()");
    method.setSimpleName("computeFields");
    helper.setMethodData(method,1028);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#computeFields()
    // starting method java.util.Calendar#getTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTime()");
    method.setSimpleName("getTime");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Date");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getTime()
    // starting method java.util.Calendar#setTime(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTime(java.util.Date)");
    method.setSimpleName("setTime");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setTime(java.util.Date)
    // starting method java.util.Calendar#getTimeInMillis()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimeInMillis()");
    method.setSimpleName("getTimeInMillis");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getTimeInMillis()
    // starting method java.util.Calendar#setTimeInMillis(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTimeInMillis(long)");
    method.setSimpleName("setTimeInMillis");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setTimeInMillis(long)
    // starting method java.util.Calendar#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#get(int)
    // starting method java.util.Calendar#internalGet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"internalGet(int)");
    method.setSimpleName("internalGet");
    helper.setMethodData(method,20);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#internalGet(int)
    // starting method java.util.Calendar#internalSet(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"internalSet(int, int)");
    method.setSimpleName("internalSet");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#internalSet(int, int)
    // starting method java.util.Calendar#set(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#set(int, int)
    // starting method java.util.Calendar#set(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#set(int, int, int)
    // starting method java.util.Calendar#set(int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int, int, int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#set(int, int, int, int, int)
    // starting method java.util.Calendar#set(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, int, int, int, int, int)");
    method.setSimpleName("set");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#set(int, int, int, int, int, int)
    // starting method java.util.Calendar#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#clear()
    // starting method java.util.Calendar#clear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear(int)");
    method.setSimpleName("clear");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#clear(int)
    // starting method java.util.Calendar#isSet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isSet(int)");
    method.setSimpleName("isSet");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isSet(int)
    // starting method java.util.Calendar#complete()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complete()");
    method.setSimpleName("complete");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#complete()
    // starting method java.util.Calendar#isExternallySet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isExternallySet(int)");
    method.setSimpleName("isExternallySet");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isExternallySet(int)
    // starting method java.util.Calendar#getSetStateFields()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSetStateFields()");
    method.setSimpleName("getSetStateFields");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getSetStateFields()
    // starting method java.util.Calendar#setFieldsComputed(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setFieldsComputed(int)");
    method.setSimpleName("setFieldsComputed");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setFieldsComputed(int)
    // starting method java.util.Calendar#setFieldsNormalized(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setFieldsNormalized(int)");
    method.setSimpleName("setFieldsNormalized");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setFieldsNormalized(int)
    // starting method java.util.Calendar#isPartiallyNormalized()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isPartiallyNormalized()");
    method.setSimpleName("isPartiallyNormalized");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isPartiallyNormalized()
    // starting method java.util.Calendar#isFullyNormalized()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isFullyNormalized()");
    method.setSimpleName("isFullyNormalized");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isFullyNormalized()
    // starting method java.util.Calendar#setUnnormalized()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setUnnormalized()");
    method.setSimpleName("setUnnormalized");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setUnnormalized()
    // starting method java.util.Calendar#isFieldSet(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isFieldSet(int, int)");
    method.setSimpleName("isFieldSet");
    helper.setMethodData(method,24);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isFieldSet(int, int)
    // starting method java.util.Calendar#selectFields()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"selectFields()");
    method.setSimpleName("selectFields");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#selectFields()
    // ignoring method java.util.Calendar#aggregateStamp(int, int)
    // starting method java.util.Calendar#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#equals(java.lang.Object)
    // starting method java.util.Calendar#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#hashCode()
    // starting method java.util.Calendar#before(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"before(java.lang.Object)");
    method.setSimpleName("before");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#before(java.lang.Object)
    // starting method java.util.Calendar#after(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"after(java.lang.Object)");
    method.setSimpleName("after");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#after(java.lang.Object)
    // starting method java.util.Calendar#compareTo(java.util.Calendar)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.util.Calendar)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#compareTo(java.util.Calendar)
    // starting method java.util.Calendar#add(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, int)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#add(int, int)
    // starting method java.util.Calendar#roll(int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"roll(int, boolean)");
    method.setSimpleName("roll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#roll(int, boolean)
    // starting method java.util.Calendar#roll(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"roll(int, int)");
    method.setSimpleName("roll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#roll(int, int)
    // starting method java.util.Calendar#setTimeZone(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTimeZone(java.util.TimeZone)");
    method.setSimpleName("setTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setTimeZone(java.util.TimeZone)
    // starting method java.util.Calendar#getTimeZone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimeZone()");
    method.setSimpleName("getTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getTimeZone()
    // starting method java.util.Calendar#getZone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getZone()");
    method.setSimpleName("getZone");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getZone()
    // starting method java.util.Calendar#setZoneShared(boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setZoneShared(boolean)");
    method.setSimpleName("setZoneShared");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setZoneShared(boolean)
    // starting method java.util.Calendar#setLenient(boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setLenient(boolean)");
    method.setSimpleName("setLenient");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setLenient(boolean)
    // starting method java.util.Calendar#isLenient()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isLenient()");
    method.setSimpleName("isLenient");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#isLenient()
    // starting method java.util.Calendar#setFirstDayOfWeek(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setFirstDayOfWeek(int)");
    method.setSimpleName("setFirstDayOfWeek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setFirstDayOfWeek(int)
    // starting method java.util.Calendar#getFirstDayOfWeek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFirstDayOfWeek()");
    method.setSimpleName("getFirstDayOfWeek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getFirstDayOfWeek()
    // starting method java.util.Calendar#setMinimalDaysInFirstWeek(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setMinimalDaysInFirstWeek(int)");
    method.setSimpleName("setMinimalDaysInFirstWeek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#setMinimalDaysInFirstWeek(int)
    // starting method java.util.Calendar#getMinimalDaysInFirstWeek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMinimalDaysInFirstWeek()");
    method.setSimpleName("getMinimalDaysInFirstWeek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getMinimalDaysInFirstWeek()
    // starting method java.util.Calendar#getMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMinimum(int)");
    method.setSimpleName("getMinimum");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getMinimum(int)
    // starting method java.util.Calendar#getMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMaximum(int)");
    method.setSimpleName("getMaximum");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getMaximum(int)
    // starting method java.util.Calendar#getGreatestMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getGreatestMinimum(int)");
    method.setSimpleName("getGreatestMinimum");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getGreatestMinimum(int)
    // starting method java.util.Calendar#getLeastMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLeastMaximum(int)");
    method.setSimpleName("getLeastMaximum");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getLeastMaximum(int)
    // starting method java.util.Calendar#getActualMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActualMinimum(int)");
    method.setSimpleName("getActualMinimum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getActualMinimum(int)
    // starting method java.util.Calendar#getActualMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActualMaximum(int)");
    method.setSimpleName("getActualMaximum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getActualMaximum(int)
    // starting method java.util.Calendar#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#clone()
    // starting method java.util.Calendar#getFieldName(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFieldName(int)");
    method.setSimpleName("getFieldName");
    helper.setMethodData(method,24);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#getFieldName(int)
    // starting method java.util.Calendar#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#toString()
    // ignoring method java.util.Calendar#appendValue(java.lang.StringBuilder, java.lang.String, boolean, long)
    // ignoring method java.util.Calendar#setWeekCountData(java.util.Locale)
    // ignoring method java.util.Calendar#updateTime()
    // ignoring method java.util.Calendar#compareTo(long)
    // ignoring method java.util.Calendar#getMillisOf(java.util.Calendar)
    // ignoring method java.util.Calendar#adjustStamp()
    // ignoring method java.util.Calendar#invalidateWeekFields()
    // ignoring method java.util.Calendar#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.Calendar#readObject(java.io.ObjectInputStream)
    // starting method java.util.Calendar#compareTo(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.lang.Object)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Calendar#compareTo(java.lang.Object)

// finishing type java.util.Calendar
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Collection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Iterable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterable 


    // starting method java.util.Collection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#size()
    // starting method java.util.Collection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#isEmpty()
    // starting method java.util.Collection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#contains(java.lang.Object)
    // starting method java.util.Collection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#iterator()
    // starting method java.util.Collection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#toArray()
    // starting method java.util.Collection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#toArray(java.lang.Object[])
    // starting method java.util.Collection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#add(java.lang.Object)
    // starting method java.util.Collection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#remove(java.lang.Object)
    // starting method java.util.Collection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#containsAll(java.util.Collection)
    // starting method java.util.Collection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#addAll(java.util.Collection)
    // starting method java.util.Collection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#removeAll(java.util.Collection)
    // starting method java.util.Collection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#retainAll(java.util.Collection)
    // starting method java.util.Collection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#clear()
    // starting method java.util.Collection#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#equals(java.lang.Object)
    // starting method java.util.Collection#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collection#hashCode()

// finishing type java.util.Collection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$1#val$c
	field = newType.addNode(JavaDataField.class,"val$c"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$1#val$c


    // starting method java.util.Collections$1#Collections$1(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$1(java.util.Collection)");
    method.setSimpleName("Collections$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$1#Collections$1(java.util.Collection)
    // starting method java.util.Collections$1#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$1#hasMoreElements()
    // starting method java.util.Collections$1#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$1#nextElement()

// finishing type java.util.Collections$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedCollection$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.Collections$CheckedCollection$1#it 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedCollection$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$CheckedCollection");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedCollection$1#this$0


    // starting method java.util.Collections$CheckedCollection$1#Collections$CheckedCollection$1(java.util.Collections$CheckedCollection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedCollection$1(java.util.Collections$CheckedCollection)");
    method.setSimpleName("Collections$CheckedCollection$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection$1#Collections$CheckedCollection$1(java.util.Collections$CheckedCollection)
    // starting method java.util.Collections$CheckedCollection$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection$1#hasNext()
    // starting method java.util.Collections$CheckedCollection$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection$1#next()
    // starting method java.util.Collections$CheckedCollection$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection$1#remove()

// finishing type java.util.Collections$CheckedCollection$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedCollection#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedCollection#c
	field = newType.addNode(JavaDataField.class,"c"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedCollection#c

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedCollection#type
	field = newType.addNode(JavaDataField.class,"type"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedCollection#type

// ignoring field java.util.Collections$CheckedCollection#zeroLengthElementArray 


    // starting method java.util.Collections$CheckedCollection#typeCheck(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"typeCheck(java.lang.Object)");
    method.setSimpleName("typeCheck");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#typeCheck(java.lang.Object)
    // starting method java.util.Collections$CheckedCollection#Collections$CheckedCollection(java.util.Collection, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedCollection(java.util.Collection, java.lang.Class)");
    method.setSimpleName("Collections$CheckedCollection");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#Collections$CheckedCollection(java.util.Collection, java.lang.Class)
    // starting method java.util.Collections$CheckedCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#size()
    // starting method java.util.Collections$CheckedCollection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#isEmpty()
    // starting method java.util.Collections$CheckedCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#contains(java.lang.Object)
    // starting method java.util.Collections$CheckedCollection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#toArray()
    // starting method java.util.Collections$CheckedCollection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#toArray(java.lang.Object[])
    // starting method java.util.Collections$CheckedCollection#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#toString()
    // starting method java.util.Collections$CheckedCollection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#remove(java.lang.Object)
    // starting method java.util.Collections$CheckedCollection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#containsAll(java.util.Collection)
    // starting method java.util.Collections$CheckedCollection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#removeAll(java.util.Collection)
    // starting method java.util.Collections$CheckedCollection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#retainAll(java.util.Collection)
    // starting method java.util.Collections$CheckedCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#clear()
    // starting method java.util.Collections$CheckedCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#iterator()
    // starting method java.util.Collections$CheckedCollection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#add(java.lang.Object)
    // starting method java.util.Collections$CheckedCollection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#addAll(java.util.Collection)
    // starting method java.util.Collections$CheckedCollection#zeroLengthElementArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"zeroLengthElementArray()");
    method.setSimpleName("zeroLengthElementArray");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedCollection#zeroLengthElementArray()

// finishing type java.util.Collections$CheckedCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedList$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList$1#val$index
	field = newType.addNode(JavaDataField.class,"val$index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList$1#val$index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$CheckedList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList$1#this$0


    // starting method java.util.Collections$CheckedList$1#Collections$CheckedList$1(java.util.Collections$CheckedList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedList$1(java.util.Collections$CheckedList, int)");
    method.setSimpleName("Collections$CheckedList$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#Collections$CheckedList$1(java.util.Collections$CheckedList, int)
    // starting method java.util.Collections$CheckedList$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#hasNext()
    // starting method java.util.Collections$CheckedList$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#next()
    // starting method java.util.Collections$CheckedList$1#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#hasPrevious()
    // starting method java.util.Collections$CheckedList$1#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#previous()
    // starting method java.util.Collections$CheckedList$1#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#nextIndex()
    // starting method java.util.Collections$CheckedList$1#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#previousIndex()
    // starting method java.util.Collections$CheckedList$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#remove()
    // starting method java.util.Collections$CheckedList$1#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#set(java.lang.Object)
    // starting method java.util.Collections$CheckedList$1#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList$1#add(java.lang.Object)

// finishing type java.util.Collections$CheckedList$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedList#list
	field = newType.addNode(JavaDataField.class,"list"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedList#list


    // starting method java.util.Collections$CheckedList#Collections$CheckedList(java.util.List, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedList(java.util.List, java.lang.Class)");
    method.setSimpleName("Collections$CheckedList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#Collections$CheckedList(java.util.List, java.lang.Class)
    // starting method java.util.Collections$CheckedList#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#equals(java.lang.Object)
    // starting method java.util.Collections$CheckedList#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#hashCode()
    // starting method java.util.Collections$CheckedList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#get(int)
    // starting method java.util.Collections$CheckedList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#remove(int)
    // starting method java.util.Collections$CheckedList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#indexOf(java.lang.Object)
    // starting method java.util.Collections$CheckedList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#lastIndexOf(java.lang.Object)
    // starting method java.util.Collections$CheckedList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#set(int, java.lang.Object)
    // starting method java.util.Collections$CheckedList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#add(int, java.lang.Object)
    // starting method java.util.Collections$CheckedList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#addAll(int, java.util.Collection)
    // starting method java.util.Collections$CheckedList#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#listIterator()
    // starting method java.util.Collections$CheckedList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#listIterator(int)
    // starting method java.util.Collections$CheckedList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedList#subList(int, int)

// finishing type java.util.Collections$CheckedList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap$CheckedEntrySet$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap$CheckedEntrySet$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap$CheckedEntrySet$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$CheckedMap$CheckedEntrySet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap$CheckedEntrySet$1#this$0


    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#Collections$CheckedMap$CheckedEntrySet$1(java.util.Collections$CheckedMap$CheckedEntrySet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedMap$CheckedEntrySet$1(java.util.Collections$CheckedMap$CheckedEntrySet)");
    method.setSimpleName("Collections$CheckedMap$CheckedEntrySet$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#Collections$CheckedMap$CheckedEntrySet$1(java.util.Collections$CheckedMap$CheckedEntrySet)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#hasNext()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#remove()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#next()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$1#next()

// finishing type java.util.Collections$CheckedMap$CheckedEntrySet$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet$CheckedEntry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

// ignoring field java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#e 

// ignoring field java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#valueType 


    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#Collections$CheckedMap$CheckedEntrySet$CheckedEntry(java.util.Map$Entry, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedMap$CheckedEntrySet$CheckedEntry(java.util.Map$Entry, java.lang.Class)");
    method.setSimpleName("Collections$CheckedMap$CheckedEntrySet$CheckedEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#Collections$CheckedMap$CheckedEntrySet$CheckedEntry(java.util.Map$Entry, java.lang.Class)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#getKey()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#getValue()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#hashCode()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#toString()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#setValue(java.lang.Object)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry#equals(java.lang.Object)

// finishing type java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap$CheckedEntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap$CheckedEntrySet#s
	field = newType.addNode(JavaDataField.class,"s"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap$CheckedEntrySet#s

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap$CheckedEntrySet#valueType
	field = newType.addNode(JavaDataField.class,"valueType"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap$CheckedEntrySet#valueType


    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#Collections$CheckedMap$CheckedEntrySet(java.util.Set, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedMap$CheckedEntrySet(java.util.Set, java.lang.Class)");
    method.setSimpleName("Collections$CheckedMap$CheckedEntrySet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#Collections$CheckedMap$CheckedEntrySet(java.util.Set, java.lang.Class)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#size()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#isEmpty()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#toString()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#hashCode()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#remove(java.lang.Object)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#removeAll(java.util.Collection)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#retainAll(java.util.Collection)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#clear()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#add(java.util.Map$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.util.Map$Entry)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#add(java.util.Map$Entry)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#addAll(java.util.Collection)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#iterator()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#toArray()
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#toArray(java.lang.Object[])
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#contains(java.lang.Object)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#containsAll(java.util.Collection)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#equals(java.lang.Object)
    // starting method java.util.Collections$CheckedMap$CheckedEntrySet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap$CheckedEntrySet#add(java.lang.Object)

// finishing type java.util.Collections$CheckedMap$CheckedEntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedMap#serialVersionUID 

// ignoring field java.util.Collections$CheckedMap#m 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap#keyType
	field = newType.addNode(JavaDataField.class,"keyType"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap#keyType

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CheckedMap#valueType
	field = newType.addNode(JavaDataField.class,"valueType"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$CheckedMap#valueType

// ignoring field java.util.Collections$CheckedMap#zeroLengthKeyArray 

// ignoring field java.util.Collections$CheckedMap#zeroLengthValueArray 

// ignoring field java.util.Collections$CheckedMap#entrySet 


    // ignoring method java.util.Collections$CheckedMap#typeCheck(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$CheckedMap#Collections$CheckedMap(java.util.Map, java.lang.Class, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedMap(java.util.Map, java.lang.Class, java.lang.Class)");
    method.setSimpleName("Collections$CheckedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#Collections$CheckedMap(java.util.Map, java.lang.Class, java.lang.Class)
    // starting method java.util.Collections$CheckedMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#size()
    // starting method java.util.Collections$CheckedMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#isEmpty()
    // starting method java.util.Collections$CheckedMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#get(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#remove(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#clear()
    // starting method java.util.Collections$CheckedMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#keySet()
    // starting method java.util.Collections$CheckedMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#values()
    // starting method java.util.Collections$CheckedMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#equals(java.lang.Object)
    // starting method java.util.Collections$CheckedMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#hashCode()
    // starting method java.util.Collections$CheckedMap#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#toString()
    // starting method java.util.Collections$CheckedMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$CheckedMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#putAll(java.util.Map)
    // ignoring method java.util.Collections$CheckedMap#zeroLengthKeyArray()
    // ignoring method java.util.Collections$CheckedMap#zeroLengthValueArray()
    // starting method java.util.Collections$CheckedMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedMap#entrySet()

// finishing type java.util.Collections$CheckedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedRandomAccessList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 

// ignoring field java.util.Collections$CheckedRandomAccessList#serialVersionUID 


    // starting method java.util.Collections$CheckedRandomAccessList#Collections$CheckedRandomAccessList(java.util.List, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedRandomAccessList(java.util.List, java.lang.Class)");
    method.setSimpleName("Collections$CheckedRandomAccessList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedRandomAccessList#Collections$CheckedRandomAccessList(java.util.List, java.lang.Class)
    // starting method java.util.Collections$CheckedRandomAccessList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedRandomAccessList#subList(int, int)

// finishing type java.util.Collections$CheckedRandomAccessList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedSet#serialVersionUID 


    // starting method java.util.Collections$CheckedSet#Collections$CheckedSet(java.util.Set, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedSet(java.util.Set, java.lang.Class)");
    method.setSimpleName("Collections$CheckedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSet#Collections$CheckedSet(java.util.Set, java.lang.Class)
    // starting method java.util.Collections$CheckedSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSet#equals(java.lang.Object)
    // starting method java.util.Collections$CheckedSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSet#hashCode()

// finishing type java.util.Collections$CheckedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSortedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedSortedMap#serialVersionUID 

// ignoring field java.util.Collections$CheckedSortedMap#sm 


    // starting method java.util.Collections$CheckedSortedMap#Collections$CheckedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)");
    method.setSimpleName("Collections$CheckedSortedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#Collections$CheckedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)
    // starting method java.util.Collections$CheckedSortedMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#comparator()
    // starting method java.util.Collections$CheckedSortedMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#firstKey()
    // starting method java.util.Collections$CheckedSortedMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#lastKey()
    // starting method java.util.Collections$CheckedSortedMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$CheckedSortedMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#headMap(java.lang.Object)
    // starting method java.util.Collections$CheckedSortedMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedMap#tailMap(java.lang.Object)

// finishing type java.util.Collections$CheckedSortedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CheckedSortedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$CheckedSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedSet 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedSet");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedSet 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$CheckedSortedSet#serialVersionUID 

// ignoring field java.util.Collections$CheckedSortedSet#ss 


    // starting method java.util.Collections$CheckedSortedSet#Collections$CheckedSortedSet(java.util.SortedSet, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CheckedSortedSet(java.util.SortedSet, java.lang.Class)");
    method.setSimpleName("Collections$CheckedSortedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#Collections$CheckedSortedSet(java.util.SortedSet, java.lang.Class)
    // starting method java.util.Collections$CheckedSortedSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#comparator()
    // starting method java.util.Collections$CheckedSortedSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#first()
    // starting method java.util.Collections$CheckedSortedSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#last()
    // starting method java.util.Collections$CheckedSortedSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$CheckedSortedSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#headSet(java.lang.Object)
    // starting method java.util.Collections$CheckedSortedSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CheckedSortedSet#tailSet(java.lang.Object)

// finishing type java.util.Collections$CheckedSortedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$CopiesList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CopiesList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$CopiesList#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CopiesList#n
	field = newType.addNode(JavaDataField.class,"n"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CopiesList#n

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$CopiesList#element
	field = newType.addNode(JavaDataField.class,"element"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$CopiesList#element


    // starting method java.util.Collections$CopiesList#Collections$CopiesList(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$CopiesList(int, java.lang.Object)");
    method.setSimpleName("Collections$CopiesList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CopiesList#Collections$CopiesList(int, java.lang.Object)
    // starting method java.util.Collections$CopiesList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CopiesList#size()
    // starting method java.util.Collections$CopiesList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CopiesList#contains(java.lang.Object)
    // starting method java.util.Collections$CopiesList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$CopiesList#get(int)

// finishing type java.util.Collections$CopiesList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptyList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$EmptyList#serialVersionUID 


    // ignoring method java.util.Collections$EmptyList#Collections$EmptyList()
    // starting method java.util.Collections$EmptyList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyList#size()
    // starting method java.util.Collections$EmptyList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyList#contains(java.lang.Object)
    // starting method java.util.Collections$EmptyList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyList#get(int)
    // ignoring method java.util.Collections$EmptyList#readResolve()
    // starting method java.util.Collections$EmptyList#Collections$EmptyList(java.util.Collections$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$EmptyList(java.util.Collections$1)");
    method.setSimpleName("Collections$EmptyList");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyList#Collections$EmptyList(java.util.Collections$1)

// finishing type java.util.Collections$EmptyList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptyMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$EmptyMap#serialVersionUID 


    // ignoring method java.util.Collections$EmptyMap#Collections$EmptyMap()
    // starting method java.util.Collections$EmptyMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#size()
    // starting method java.util.Collections$EmptyMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#isEmpty()
    // starting method java.util.Collections$EmptyMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$EmptyMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$EmptyMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#get(java.lang.Object)
    // starting method java.util.Collections$EmptyMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#keySet()
    // starting method java.util.Collections$EmptyMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#values()
    // starting method java.util.Collections$EmptyMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#entrySet()
    // starting method java.util.Collections$EmptyMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#equals(java.lang.Object)
    // starting method java.util.Collections$EmptyMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#hashCode()
    // ignoring method java.util.Collections$EmptyMap#readResolve()
    // starting method java.util.Collections$EmptyMap#Collections$EmptyMap(java.util.Collections$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$EmptyMap(java.util.Collections$1)");
    method.setSimpleName("Collections$EmptyMap");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptyMap#Collections$EmptyMap(java.util.Collections$1)

// finishing type java.util.Collections$EmptyMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptySet$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$EmptySet$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$EmptySet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$EmptySet$1#this$0


    // starting method java.util.Collections$EmptySet$1#Collections$EmptySet$1(java.util.Collections$EmptySet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$EmptySet$1(java.util.Collections$EmptySet)");
    method.setSimpleName("Collections$EmptySet$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet$1#Collections$EmptySet$1(java.util.Collections$EmptySet)
    // starting method java.util.Collections$EmptySet$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet$1#hasNext()
    // starting method java.util.Collections$EmptySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet$1#next()
    // starting method java.util.Collections$EmptySet$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet$1#remove()

// finishing type java.util.Collections$EmptySet$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$EmptySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$EmptySet#serialVersionUID 


    // ignoring method java.util.Collections$EmptySet#Collections$EmptySet()
    // starting method java.util.Collections$EmptySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet#iterator()
    // starting method java.util.Collections$EmptySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet#size()
    // starting method java.util.Collections$EmptySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet#contains(java.lang.Object)
    // ignoring method java.util.Collections$EmptySet#readResolve()
    // starting method java.util.Collections$EmptySet#Collections$EmptySet(java.util.Collections$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$EmptySet(java.util.Collections$1)");
    method.setSimpleName("Collections$EmptySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$EmptySet#Collections$EmptySet(java.util.Collections$1)

// finishing type java.util.Collections$EmptySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$ReverseComparator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Comparator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Comparator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparator 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$ReverseComparator#serialVersionUID 


    // ignoring method java.util.Collections$ReverseComparator#Collections$ReverseComparator()
    // starting method java.util.Collections$ReverseComparator#compare(java.lang.Comparable, java.lang.Comparable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compare(java.lang.Comparable, java.lang.Comparable)");
    method.setSimpleName("compare");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator#compare(java.lang.Comparable, java.lang.Comparable)
    // starting method java.util.Collections$ReverseComparator#compare(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compare(java.lang.Object, java.lang.Object)");
    method.setSimpleName("compare");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator#compare(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$ReverseComparator#Collections$ReverseComparator(java.util.Collections$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$ReverseComparator(java.util.Collections$1)");
    method.setSimpleName("Collections$ReverseComparator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator#Collections$ReverseComparator(java.util.Collections$1)

// finishing type java.util.Collections$ReverseComparator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$ReverseComparator2");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Comparator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Comparator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparator 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$ReverseComparator2#serialVersionUID 

// ignoring field java.util.Collections$ReverseComparator2#cmp 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$ReverseComparator2#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.Collections$ReverseComparator2#$assertionsDisabled


    // starting method java.util.Collections$ReverseComparator2#Collections$ReverseComparator2(java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$ReverseComparator2(java.util.Comparator)");
    method.setSimpleName("Collections$ReverseComparator2");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator2#Collections$ReverseComparator2(java.util.Comparator)
    // starting method java.util.Collections$ReverseComparator2#compare(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compare(java.lang.Object, java.lang.Object)");
    method.setSimpleName("compare");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$ReverseComparator2#compare(java.lang.Object, java.lang.Object)

// finishing type java.util.Collections$ReverseComparator2
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Collections$SelfComparable");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Comparable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Comparable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparable 



// finishing type java.util.Collections$SelfComparable
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SingletonList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$SingletonList#serialVersionUID

// ignoring field java.util.Collections$SingletonList#element 


    // starting method java.util.Collections$SingletonList#Collections$SingletonList(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonList(java.lang.Object)");
    method.setSimpleName("Collections$SingletonList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonList#Collections$SingletonList(java.lang.Object)
    // starting method java.util.Collections$SingletonList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonList#size()
    // starting method java.util.Collections$SingletonList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonList#contains(java.lang.Object)
    // starting method java.util.Collections$SingletonList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonList#get(int)

// finishing type java.util.Collections$SingletonList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonMap$ImmutableEntry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SingletonMap$ImmutableEntry#k
	field = newType.addNode(JavaDataField.class,"k"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$SingletonMap$ImmutableEntry#k

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SingletonMap$ImmutableEntry#v
	field = newType.addNode(JavaDataField.class,"v"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.Collections$SingletonMap$ImmutableEntry#v


    // starting method java.util.Collections$SingletonMap$ImmutableEntry#Collections$SingletonMap$ImmutableEntry(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonMap$ImmutableEntry(java.lang.Object, java.lang.Object)");
    method.setSimpleName("Collections$SingletonMap$ImmutableEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#Collections$SingletonMap$ImmutableEntry(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#getKey()
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#getValue()
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#setValue(java.lang.Object)
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#equals(java.lang.Object)
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#hashCode()
    // starting method java.util.Collections$SingletonMap$ImmutableEntry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap$ImmutableEntry#toString()

// finishing type java.util.Collections$SingletonMap$ImmutableEntry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$SingletonMap#serialVersionUID 

// ignoring field java.util.Collections$SingletonMap#k 

// ignoring field java.util.Collections$SingletonMap#v 

// ignoring field java.util.Collections$SingletonMap#keySet 

// ignoring field java.util.Collections$SingletonMap#entrySet 

// ignoring field java.util.Collections$SingletonMap#values 


    // starting method java.util.Collections$SingletonMap#Collections$SingletonMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("Collections$SingletonMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#Collections$SingletonMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SingletonMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#size()
    // starting method java.util.Collections$SingletonMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#isEmpty()
    // starting method java.util.Collections$SingletonMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$SingletonMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$SingletonMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#get(java.lang.Object)
    // starting method java.util.Collections$SingletonMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#keySet()
    // starting method java.util.Collections$SingletonMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#entrySet()
    // starting method java.util.Collections$SingletonMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonMap#values()

// finishing type java.util.Collections$SingletonMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonSet$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.Collections$SingletonSet$1#hasNext 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SingletonSet$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$SingletonSet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$SingletonSet$1#this$0


    // starting method java.util.Collections$SingletonSet$1#Collections$SingletonSet$1(java.util.Collections$SingletonSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonSet$1(java.util.Collections$SingletonSet)");
    method.setSimpleName("Collections$SingletonSet$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet$1#Collections$SingletonSet$1(java.util.Collections$SingletonSet)
    // starting method java.util.Collections$SingletonSet$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet$1#hasNext()
    // starting method java.util.Collections$SingletonSet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet$1#next()
    // starting method java.util.Collections$SingletonSet$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet$1#remove()

// finishing type java.util.Collections$SingletonSet$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SingletonSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$SingletonSet#serialVersionUID 

// ignoring field java.util.Collections$SingletonSet#element 


    // starting method java.util.Collections$SingletonSet#Collections$SingletonSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SingletonSet(java.lang.Object)");
    method.setSimpleName("Collections$SingletonSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#Collections$SingletonSet(java.lang.Object)
    // starting method java.util.Collections$SingletonSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#iterator()
    // starting method java.util.Collections$SingletonSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#size()
    // starting method java.util.Collections$SingletonSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#contains(java.lang.Object)
    // starting method java.util.Collections$SingletonSet#access$400(java.util.Collections$SingletonSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.Collections$SingletonSet)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SingletonSet#access$400(java.util.Collections$SingletonSet)

// finishing type java.util.Collections$SingletonSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$SynchronizedCollection#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedCollection#c
	field = newType.addNode(JavaDataField.class,"c"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedCollection#c

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedCollection#mutex
	field = newType.addNode(JavaDataField.class,"mutex"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedCollection#mutex


    // starting method java.util.Collections$SynchronizedCollection#Collections$SynchronizedCollection(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedCollection(java.util.Collection)");
    method.setSimpleName("Collections$SynchronizedCollection");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#Collections$SynchronizedCollection(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#Collections$SynchronizedCollection(java.util.Collection, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedCollection(java.util.Collection, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedCollection");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#Collections$SynchronizedCollection(java.util.Collection, java.lang.Object)
    // starting method java.util.Collections$SynchronizedCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#size()
    // starting method java.util.Collections$SynchronizedCollection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#isEmpty()
    // starting method java.util.Collections$SynchronizedCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#contains(java.lang.Object)
    // starting method java.util.Collections$SynchronizedCollection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#toArray()
    // starting method java.util.Collections$SynchronizedCollection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#toArray(java.lang.Object[])
    // starting method java.util.Collections$SynchronizedCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#iterator()
    // starting method java.util.Collections$SynchronizedCollection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#add(java.lang.Object)
    // starting method java.util.Collections$SynchronizedCollection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#remove(java.lang.Object)
    // starting method java.util.Collections$SynchronizedCollection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#containsAll(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#addAll(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#removeAll(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#retainAll(java.util.Collection)
    // starting method java.util.Collections$SynchronizedCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#clear()
    // starting method java.util.Collections$SynchronizedCollection#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedCollection#toString()
    // ignoring method java.util.Collections$SynchronizedCollection#writeObject(java.io.ObjectOutputStream)

// finishing type java.util.Collections$SynchronizedCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedList#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedList#list
	field = newType.addNode(JavaDataField.class,"list"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedList#list


    // starting method java.util.Collections$SynchronizedList#Collections$SynchronizedList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedList(java.util.List)");
    method.setSimpleName("Collections$SynchronizedList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#Collections$SynchronizedList(java.util.List)
    // starting method java.util.Collections$SynchronizedList#Collections$SynchronizedList(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedList(java.util.List, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#Collections$SynchronizedList(java.util.List, java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#equals(java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#hashCode()
    // starting method java.util.Collections$SynchronizedList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#get(int)
    // starting method java.util.Collections$SynchronizedList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#set(int, java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#add(int, java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#remove(int)
    // starting method java.util.Collections$SynchronizedList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#indexOf(java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#lastIndexOf(java.lang.Object)
    // starting method java.util.Collections$SynchronizedList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#addAll(int, java.util.Collection)
    // starting method java.util.Collections$SynchronizedList#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#listIterator()
    // starting method java.util.Collections$SynchronizedList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#listIterator(int)
    // starting method java.util.Collections$SynchronizedList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedList#subList(int, int)
    // ignoring method java.util.Collections$SynchronizedList#readResolve()

// finishing type java.util.Collections$SynchronizedList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$SynchronizedMap#serialVersionUID 

// ignoring field java.util.Collections$SynchronizedMap#m 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedMap#mutex
	field = newType.addNode(JavaDataField.class,"mutex"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedMap#mutex

// ignoring field java.util.Collections$SynchronizedMap#keySet 

// ignoring field java.util.Collections$SynchronizedMap#entrySet 

// ignoring field java.util.Collections$SynchronizedMap#values 


    // starting method java.util.Collections$SynchronizedMap#Collections$SynchronizedMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedMap(java.util.Map)");
    method.setSimpleName("Collections$SynchronizedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#Collections$SynchronizedMap(java.util.Map)
    // starting method java.util.Collections$SynchronizedMap#Collections$SynchronizedMap(java.util.Map, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedMap(java.util.Map, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#Collections$SynchronizedMap(java.util.Map, java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#size()
    // starting method java.util.Collections$SynchronizedMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#isEmpty()
    // starting method java.util.Collections$SynchronizedMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#get(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#remove(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#putAll(java.util.Map)
    // starting method java.util.Collections$SynchronizedMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#clear()
    // starting method java.util.Collections$SynchronizedMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#keySet()
    // starting method java.util.Collections$SynchronizedMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#entrySet()
    // starting method java.util.Collections$SynchronizedMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#values()
    // starting method java.util.Collections$SynchronizedMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#equals(java.lang.Object)
    // starting method java.util.Collections$SynchronizedMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#hashCode()
    // starting method java.util.Collections$SynchronizedMap#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedMap#toString()
    // ignoring method java.util.Collections$SynchronizedMap#writeObject(java.io.ObjectOutputStream)

// finishing type java.util.Collections$SynchronizedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedRandomAccessList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$SynchronizedRandomAccessList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$SynchronizedRandomAccessList#serialVersionUID


    // starting method java.util.Collections$SynchronizedRandomAccessList#Collections$SynchronizedRandomAccessList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedRandomAccessList(java.util.List)");
    method.setSimpleName("Collections$SynchronizedRandomAccessList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedRandomAccessList#Collections$SynchronizedRandomAccessList(java.util.List)
    // starting method java.util.Collections$SynchronizedRandomAccessList#Collections$SynchronizedRandomAccessList(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedRandomAccessList(java.util.List, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedRandomAccessList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedRandomAccessList#Collections$SynchronizedRandomAccessList(java.util.List, java.lang.Object)
    // starting method java.util.Collections$SynchronizedRandomAccessList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedRandomAccessList#subList(int, int)
    // ignoring method java.util.Collections$SynchronizedRandomAccessList#writeReplace()

// finishing type java.util.Collections$SynchronizedRandomAccessList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 

// ignoring field java.util.Collections$SynchronizedSet#serialVersionUID 


    // starting method java.util.Collections$SynchronizedSet#Collections$SynchronizedSet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSet(java.util.Set)");
    method.setSimpleName("Collections$SynchronizedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSet#Collections$SynchronizedSet(java.util.Set)
    // starting method java.util.Collections$SynchronizedSet#Collections$SynchronizedSet(java.util.Set, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSet(java.util.Set, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSet#Collections$SynchronizedSet(java.util.Set, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSet#equals(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSet#hashCode()

// finishing type java.util.Collections$SynchronizedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSortedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 

// ignoring field java.util.Collections$SynchronizedSortedMap#serialVersionUID 

// ignoring field java.util.Collections$SynchronizedSortedMap#sm 


    // starting method java.util.Collections$SynchronizedSortedMap#Collections$SynchronizedSortedMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSortedMap(java.util.SortedMap)");
    method.setSimpleName("Collections$SynchronizedSortedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#Collections$SynchronizedSortedMap(java.util.SortedMap)
    // starting method java.util.Collections$SynchronizedSortedMap#Collections$SynchronizedSortedMap(java.util.SortedMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSortedMap(java.util.SortedMap, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedSortedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#Collections$SynchronizedSortedMap(java.util.SortedMap, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#comparator()
    // starting method java.util.Collections$SynchronizedSortedMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#headMap(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#tailMap(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#firstKey()
    // starting method java.util.Collections$SynchronizedSortedMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedMap#lastKey()

// finishing type java.util.Collections$SynchronizedSortedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$SynchronizedSortedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$SynchronizedSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedSet 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedSet");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedSet 

// ignoring field java.util.Collections$SynchronizedSortedSet#serialVersionUID 

// ignoring field java.util.Collections$SynchronizedSortedSet#ss 


    // starting method java.util.Collections$SynchronizedSortedSet#Collections$SynchronizedSortedSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSortedSet(java.util.SortedSet)");
    method.setSimpleName("Collections$SynchronizedSortedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#Collections$SynchronizedSortedSet(java.util.SortedSet)
    // starting method java.util.Collections$SynchronizedSortedSet#Collections$SynchronizedSortedSet(java.util.SortedSet, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$SynchronizedSortedSet(java.util.SortedSet, java.lang.Object)");
    method.setSimpleName("Collections$SynchronizedSortedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#Collections$SynchronizedSortedSet(java.util.SortedSet, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#comparator()
    // starting method java.util.Collections$SynchronizedSortedSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#headSet(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#tailSet(java.lang.Object)
    // starting method java.util.Collections$SynchronizedSortedSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#first()
    // starting method java.util.Collections$SynchronizedSortedSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$SynchronizedSortedSet#last()

// finishing type java.util.Collections$SynchronizedSortedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableCollection$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableCollection$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableCollection$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableCollection$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$UnmodifiableCollection");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableCollection$1#this$0


    // starting method java.util.Collections$UnmodifiableCollection$1#Collections$UnmodifiableCollection$1(java.util.Collections$UnmodifiableCollection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableCollection$1(java.util.Collections$UnmodifiableCollection)");
    method.setSimpleName("Collections$UnmodifiableCollection$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection$1#Collections$UnmodifiableCollection$1(java.util.Collections$UnmodifiableCollection)
    // starting method java.util.Collections$UnmodifiableCollection$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection$1#hasNext()
    // starting method java.util.Collections$UnmodifiableCollection$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection$1#next()
    // starting method java.util.Collections$UnmodifiableCollection$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection$1#remove()

// finishing type java.util.Collections$UnmodifiableCollection$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableCollection#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableCollection#c
	field = newType.addNode(JavaDataField.class,"c"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableCollection#c


    // starting method java.util.Collections$UnmodifiableCollection#Collections$UnmodifiableCollection(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableCollection(java.util.Collection)");
    method.setSimpleName("Collections$UnmodifiableCollection");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#Collections$UnmodifiableCollection(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#size()
    // starting method java.util.Collections$UnmodifiableCollection#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#isEmpty()
    // starting method java.util.Collections$UnmodifiableCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#contains(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableCollection#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#toArray()
    // starting method java.util.Collections$UnmodifiableCollection#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#toArray(java.lang.Object[])
    // starting method java.util.Collections$UnmodifiableCollection#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#toString()
    // starting method java.util.Collections$UnmodifiableCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#iterator()
    // starting method java.util.Collections$UnmodifiableCollection#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#add(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableCollection#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#remove(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableCollection#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#containsAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#addAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#removeAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#retainAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableCollection#clear()

// finishing type java.util.Collections$UnmodifiableCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableList$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList$1#val$index
	field = newType.addNode(JavaDataField.class,"val$index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList$1#val$index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$UnmodifiableList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList$1#this$0


    // starting method java.util.Collections$UnmodifiableList$1#Collections$UnmodifiableList$1(java.util.Collections$UnmodifiableList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableList$1(java.util.Collections$UnmodifiableList, int)");
    method.setSimpleName("Collections$UnmodifiableList$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#Collections$UnmodifiableList$1(java.util.Collections$UnmodifiableList, int)
    // starting method java.util.Collections$UnmodifiableList$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#hasNext()
    // starting method java.util.Collections$UnmodifiableList$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#next()
    // starting method java.util.Collections$UnmodifiableList$1#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#hasPrevious()
    // starting method java.util.Collections$UnmodifiableList$1#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#previous()
    // starting method java.util.Collections$UnmodifiableList$1#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#nextIndex()
    // starting method java.util.Collections$UnmodifiableList$1#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#previousIndex()
    // starting method java.util.Collections$UnmodifiableList$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#remove()
    // starting method java.util.Collections$UnmodifiableList$1#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#set(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList$1#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList$1#add(java.lang.Object)

// finishing type java.util.Collections$UnmodifiableList$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableList#list
	field = newType.addNode(JavaDataField.class,"list"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableList#list


    // starting method java.util.Collections$UnmodifiableList#Collections$UnmodifiableList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableList(java.util.List)");
    method.setSimpleName("Collections$UnmodifiableList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#Collections$UnmodifiableList(java.util.List)
    // starting method java.util.Collections$UnmodifiableList#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#equals(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#hashCode()
    // starting method java.util.Collections$UnmodifiableList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#get(int)
    // starting method java.util.Collections$UnmodifiableList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#set(int, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#add(int, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#remove(int)
    // starting method java.util.Collections$UnmodifiableList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#indexOf(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#lastIndexOf(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#addAll(int, java.util.Collection)
    // starting method java.util.Collections$UnmodifiableList#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#listIterator()
    // starting method java.util.Collections$UnmodifiableList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#listIterator(int)
    // starting method java.util.Collections$UnmodifiableList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableList#subList(int, int)
    // ignoring method java.util.Collections$UnmodifiableList#readResolve()

// finishing type java.util.Collections$UnmodifiableList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#i
	field = newType.addNode(JavaDataField.class,"i"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#i

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collections$UnmodifiableMap$UnmodifiableEntrySet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#this$0


    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#Collections$UnmodifiableMap$UnmodifiableEntrySet$1(java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableMap$UnmodifiableEntrySet$1(java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet)");
    method.setSimpleName("Collections$UnmodifiableMap$UnmodifiableEntrySet$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#Collections$UnmodifiableMap$UnmodifiableEntrySet$1(java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#hasNext()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#next()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#remove()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1#next()

// finishing type java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

// ignoring field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#e 


    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(java.util.Map$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(java.util.Map$Entry)");
    method.setSimpleName("Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry(java.util.Map$Entry)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#getKey()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#getValue()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#setValue(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#hashCode()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#equals(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry#toString()

// finishing type java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap$UnmodifiableEntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#serialVersionUID 


    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#Collections$UnmodifiableMap$UnmodifiableEntrySet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableMap$UnmodifiableEntrySet(java.util.Set)");
    method.setSimpleName("Collections$UnmodifiableMap$UnmodifiableEntrySet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#Collections$UnmodifiableMap$UnmodifiableEntrySet(java.util.Set)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#iterator()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#toArray()
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#toArray(java.lang.Object[])
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#contains(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#containsAll(java.util.Collection)
    // starting method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet#equals(java.lang.Object)

// finishing type java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableMap#serialVersionUID 

// ignoring field java.util.Collections$UnmodifiableMap#m 

// ignoring field java.util.Collections$UnmodifiableMap#keySet 

// ignoring field java.util.Collections$UnmodifiableMap#entrySet 

// ignoring field java.util.Collections$UnmodifiableMap#values 


    // starting method java.util.Collections$UnmodifiableMap#Collections$UnmodifiableMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableMap(java.util.Map)");
    method.setSimpleName("Collections$UnmodifiableMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#Collections$UnmodifiableMap(java.util.Map)
    // starting method java.util.Collections$UnmodifiableMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#size()
    // starting method java.util.Collections$UnmodifiableMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#isEmpty()
    // starting method java.util.Collections$UnmodifiableMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#containsKey(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#containsValue(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#get(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#remove(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#putAll(java.util.Map)
    // starting method java.util.Collections$UnmodifiableMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#clear()
    // starting method java.util.Collections$UnmodifiableMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#keySet()
    // starting method java.util.Collections$UnmodifiableMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#entrySet()
    // starting method java.util.Collections$UnmodifiableMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#values()
    // starting method java.util.Collections$UnmodifiableMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#equals(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#hashCode()
    // starting method java.util.Collections$UnmodifiableMap#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableMap#toString()

// finishing type java.util.Collections$UnmodifiableMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableRandomAccessList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 

// ignoring field java.util.Collections$UnmodifiableRandomAccessList#serialVersionUID 


    // starting method java.util.Collections$UnmodifiableRandomAccessList#Collections$UnmodifiableRandomAccessList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableRandomAccessList(java.util.List)");
    method.setSimpleName("Collections$UnmodifiableRandomAccessList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableRandomAccessList#Collections$UnmodifiableRandomAccessList(java.util.List)
    // starting method java.util.Collections$UnmodifiableRandomAccessList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableRandomAccessList#subList(int, int)
    // ignoring method java.util.Collections$UnmodifiableRandomAccessList#writeReplace()

// finishing type java.util.Collections$UnmodifiableRandomAccessList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableSet#serialVersionUID 


    // starting method java.util.Collections$UnmodifiableSet#Collections$UnmodifiableSet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableSet(java.util.Set)");
    method.setSimpleName("Collections$UnmodifiableSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSet#Collections$UnmodifiableSet(java.util.Set)
    // starting method java.util.Collections$UnmodifiableSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSet#equals(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSet#hashCode()

// finishing type java.util.Collections$UnmodifiableSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSortedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableSortedMap#serialVersionUID 

// ignoring field java.util.Collections$UnmodifiableSortedMap#sm 


    // starting method java.util.Collections$UnmodifiableSortedMap#Collections$UnmodifiableSortedMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableSortedMap(java.util.SortedMap)");
    method.setSimpleName("Collections$UnmodifiableSortedMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#Collections$UnmodifiableSortedMap(java.util.SortedMap)
    // starting method java.util.Collections$UnmodifiableSortedMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#comparator()
    // starting method java.util.Collections$UnmodifiableSortedMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#headMap(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#tailMap(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#firstKey()
    // starting method java.util.Collections$UnmodifiableSortedMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedMap#lastKey()

// finishing type java.util.Collections$UnmodifiableSortedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections$UnmodifiableSortedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collections$UnmodifiableSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedSet 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedSet");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedSet 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Collections$UnmodifiableSortedSet#serialVersionUID 

// ignoring field java.util.Collections$UnmodifiableSortedSet#ss 


    // starting method java.util.Collections$UnmodifiableSortedSet#Collections$UnmodifiableSortedSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Collections$UnmodifiableSortedSet(java.util.SortedSet)");
    method.setSimpleName("Collections$UnmodifiableSortedSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#Collections$UnmodifiableSortedSet(java.util.SortedSet)
    // starting method java.util.Collections$UnmodifiableSortedSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#comparator()
    // starting method java.util.Collections$UnmodifiableSortedSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#headSet(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#tailSet(java.lang.Object)
    // starting method java.util.Collections$UnmodifiableSortedSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#first()
    // starting method java.util.Collections$UnmodifiableSortedSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections$UnmodifiableSortedSet#last()

// finishing type java.util.Collections$UnmodifiableSortedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Collections");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Collections#BINARYSEARCH_THRESHOLD 

// ignoring field java.util.Collections#REVERSE_THRESHOLD 

// ignoring field java.util.Collections#SHUFFLE_THRESHOLD 

// ignoring field java.util.Collections#FILL_THRESHOLD 

// ignoring field java.util.Collections#ROTATE_THRESHOLD 

// ignoring field java.util.Collections#COPY_THRESHOLD 

// ignoring field java.util.Collections#REPLACEALL_THRESHOLD 

// ignoring field java.util.Collections#INDEXOFSUBLIST_THRESHOLD 

// ignoring field java.util.Collections#r 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections#EMPTY_SET
	field = newType.addNode(JavaDataField.class,"EMPTY_SET"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Collections#EMPTY_SET

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections#EMPTY_LIST
	field = newType.addNode(JavaDataField.class,"EMPTY_LIST"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Collections#EMPTY_LIST

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Collections#EMPTY_MAP
	field = newType.addNode(JavaDataField.class,"EMPTY_MAP"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Collections#EMPTY_MAP

// ignoring field java.util.Collections#REVERSE_ORDER 


    // ignoring method java.util.Collections#Collections()
    // starting method java.util.Collections#sort(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.util.List)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#sort(java.util.List)
    // starting method java.util.Collections#sort(java.util.List, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"sort(java.util.List, java.util.Comparator)");
    method.setSimpleName("sort");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#sort(java.util.List, java.util.Comparator)
    // starting method java.util.Collections#binarySearch(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(java.util.List, java.lang.Object)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#binarySearch(java.util.List, java.lang.Object)
    // ignoring method java.util.Collections#indexedBinarySearch(java.util.List, java.lang.Object)
    // ignoring method java.util.Collections#iteratorBinarySearch(java.util.List, java.lang.Object)
    // ignoring method java.util.Collections#get(java.util.ListIterator, int)
    // starting method java.util.Collections#binarySearch(java.util.List, java.lang.Object, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"binarySearch(java.util.List, java.lang.Object, java.util.Comparator)");
    method.setSimpleName("binarySearch");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#binarySearch(java.util.List, java.lang.Object, java.util.Comparator)
    // ignoring method java.util.Collections#indexedBinarySearch(java.util.List, java.lang.Object, java.util.Comparator)
    // ignoring method java.util.Collections#iteratorBinarySearch(java.util.List, java.lang.Object, java.util.Comparator)
    // starting method java.util.Collections#reverse(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"reverse(java.util.List)");
    method.setSimpleName("reverse");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#reverse(java.util.List)
    // starting method java.util.Collections#shuffle(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"shuffle(java.util.List)");
    method.setSimpleName("shuffle");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#shuffle(java.util.List)
    // starting method java.util.Collections#shuffle(java.util.List, java.util.Random)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"shuffle(java.util.List, java.util.Random)");
    method.setSimpleName("shuffle");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#shuffle(java.util.List, java.util.Random)
    // starting method java.util.Collections#swap(java.util.List, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"swap(java.util.List, int, int)");
    method.setSimpleName("swap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#swap(java.util.List, int, int)
    // ignoring method java.util.Collections#swap(java.lang.Object[], int, int)
    // starting method java.util.Collections#fill(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fill(java.util.List, java.lang.Object)");
    method.setSimpleName("fill");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#fill(java.util.List, java.lang.Object)
    // starting method java.util.Collections#copy(java.util.List, java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"copy(java.util.List, java.util.List)");
    method.setSimpleName("copy");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#copy(java.util.List, java.util.List)
    // starting method java.util.Collections#min(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"min(java.util.Collection)");
    method.setSimpleName("min");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#min(java.util.Collection)
    // starting method java.util.Collections#min(java.util.Collection, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"min(java.util.Collection, java.util.Comparator)");
    method.setSimpleName("min");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#min(java.util.Collection, java.util.Comparator)
    // starting method java.util.Collections#max(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"max(java.util.Collection)");
    method.setSimpleName("max");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#max(java.util.Collection)
    // starting method java.util.Collections#max(java.util.Collection, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"max(java.util.Collection, java.util.Comparator)");
    method.setSimpleName("max");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#max(java.util.Collection, java.util.Comparator)
    // starting method java.util.Collections#rotate(java.util.List, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"rotate(java.util.List, int)");
    method.setSimpleName("rotate");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#rotate(java.util.List, int)
    // ignoring method java.util.Collections#rotate1(java.util.List, int)
    // ignoring method java.util.Collections#rotate2(java.util.List, int)
    // starting method java.util.Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"replaceAll(java.util.List, java.lang.Object, java.lang.Object)");
    method.setSimpleName("replaceAll");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
    // starting method java.util.Collections#indexOfSubList(java.util.List, java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOfSubList(java.util.List, java.util.List)");
    method.setSimpleName("indexOfSubList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#indexOfSubList(java.util.List, java.util.List)
    // starting method java.util.Collections#lastIndexOfSubList(java.util.List, java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOfSubList(java.util.List, java.util.List)");
    method.setSimpleName("lastIndexOfSubList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#lastIndexOfSubList(java.util.List, java.util.List)
    // starting method java.util.Collections#unmodifiableCollection(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableCollection(java.util.Collection)");
    method.setSimpleName("unmodifiableCollection");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableCollection(java.util.Collection)
    // starting method java.util.Collections#unmodifiableSet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableSet(java.util.Set)");
    method.setSimpleName("unmodifiableSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableSet(java.util.Set)
    // starting method java.util.Collections#unmodifiableSortedSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableSortedSet(java.util.SortedSet)");
    method.setSimpleName("unmodifiableSortedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableSortedSet(java.util.SortedSet)
    // starting method java.util.Collections#unmodifiableList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableList(java.util.List)");
    method.setSimpleName("unmodifiableList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableList(java.util.List)
    // starting method java.util.Collections#unmodifiableMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableMap(java.util.Map)");
    method.setSimpleName("unmodifiableMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableMap(java.util.Map)
    // starting method java.util.Collections#unmodifiableSortedMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmodifiableSortedMap(java.util.SortedMap)");
    method.setSimpleName("unmodifiableSortedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#unmodifiableSortedMap(java.util.SortedMap)
    // starting method java.util.Collections#synchronizedCollection(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedCollection(java.util.Collection)");
    method.setSimpleName("synchronizedCollection");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedCollection(java.util.Collection)
    // starting method java.util.Collections#synchronizedCollection(java.util.Collection, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedCollection(java.util.Collection, java.lang.Object)");
    method.setSimpleName("synchronizedCollection");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedCollection(java.util.Collection, java.lang.Object)
    // starting method java.util.Collections#synchronizedSet(java.util.Set)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedSet(java.util.Set)");
    method.setSimpleName("synchronizedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedSet(java.util.Set)
    // starting method java.util.Collections#synchronizedSet(java.util.Set, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedSet(java.util.Set, java.lang.Object)");
    method.setSimpleName("synchronizedSet");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedSet(java.util.Set, java.lang.Object)
    // starting method java.util.Collections#synchronizedSortedSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedSortedSet(java.util.SortedSet)");
    method.setSimpleName("synchronizedSortedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedSortedSet(java.util.SortedSet)
    // starting method java.util.Collections#synchronizedList(java.util.List)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedList(java.util.List)");
    method.setSimpleName("synchronizedList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedList(java.util.List)
    // starting method java.util.Collections#synchronizedList(java.util.List, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedList(java.util.List, java.lang.Object)");
    method.setSimpleName("synchronizedList");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedList(java.util.List, java.lang.Object)
    // starting method java.util.Collections#synchronizedMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedMap(java.util.Map)");
    method.setSimpleName("synchronizedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedMap(java.util.Map)
    // starting method java.util.Collections#synchronizedSortedMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"synchronizedSortedMap(java.util.SortedMap)");
    method.setSimpleName("synchronizedSortedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#synchronizedSortedMap(java.util.SortedMap)
    // starting method java.util.Collections#checkedCollection(java.util.Collection, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedCollection(java.util.Collection, java.lang.Class)");
    method.setSimpleName("checkedCollection");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedCollection(java.util.Collection, java.lang.Class)
    // starting method java.util.Collections#checkedSet(java.util.Set, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedSet(java.util.Set, java.lang.Class)");
    method.setSimpleName("checkedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedSet(java.util.Set, java.lang.Class)
    // starting method java.util.Collections#checkedSortedSet(java.util.SortedSet, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedSortedSet(java.util.SortedSet, java.lang.Class)");
    method.setSimpleName("checkedSortedSet");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedSortedSet(java.util.SortedSet, java.lang.Class)
    // starting method java.util.Collections#checkedList(java.util.List, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedList(java.util.List, java.lang.Class)");
    method.setSimpleName("checkedList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedList(java.util.List, java.lang.Class)
    // starting method java.util.Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedMap(java.util.Map, java.lang.Class, java.lang.Class)");
    method.setSimpleName("checkedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
    // starting method java.util.Collections#checkedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)");
    method.setSimpleName("checkedSortedMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#checkedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)
    // starting method java.util.Collections#emptySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"emptySet()");
    method.setSimpleName("emptySet");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#emptySet()
    // starting method java.util.Collections#emptyList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"emptyList()");
    method.setSimpleName("emptyList");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#emptyList()
    // starting method java.util.Collections#emptyMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"emptyMap()");
    method.setSimpleName("emptyMap");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#emptyMap()
    // starting method java.util.Collections#singleton(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"singleton(java.lang.Object)");
    method.setSimpleName("singleton");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#singleton(java.lang.Object)
    // starting method java.util.Collections#singletonList(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"singletonList(java.lang.Object)");
    method.setSimpleName("singletonList");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#singletonList(java.lang.Object)
    // starting method java.util.Collections#singletonMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"singletonMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("singletonMap");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#singletonMap(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections#nCopies(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nCopies(int, java.lang.Object)");
    method.setSimpleName("nCopies");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#nCopies(int, java.lang.Object)
    // starting method java.util.Collections#reverseOrder()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"reverseOrder()");
    method.setSimpleName("reverseOrder");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#reverseOrder()
    // starting method java.util.Collections#reverseOrder(java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"reverseOrder(java.util.Comparator)");
    method.setSimpleName("reverseOrder");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#reverseOrder(java.util.Comparator)
    // starting method java.util.Collections#enumeration(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"enumeration(java.util.Collection)");
    method.setSimpleName("enumeration");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#enumeration(java.util.Collection)
    // starting method java.util.Collections#list(java.util.Enumeration)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"list(java.util.Enumeration)");
    method.setSimpleName("list");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ArrayList");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#list(java.util.Enumeration)
    // ignoring method java.util.Collections#eq(java.lang.Object, java.lang.Object)
    // starting method java.util.Collections#frequency(java.util.Collection, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"frequency(java.util.Collection, java.lang.Object)");
    method.setSimpleName("frequency");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#frequency(java.util.Collection, java.lang.Object)
    // starting method java.util.Collections#disjoint(java.util.Collection, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"disjoint(java.util.Collection, java.util.Collection)");
    method.setSimpleName("disjoint");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#disjoint(java.util.Collection, java.util.Collection)
    // starting method java.util.Collections#addAll(java.util.Collection, java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection, java.lang.Object[])");
    method.setSimpleName("addAll");
    helper.setMethodData(method,137);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#addAll(java.util.Collection, java.lang.Object[])
    // starting method java.util.Collections#access$000(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Collections#access$000(java.lang.Object, java.lang.Object)

// finishing type java.util.Collections
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Comparator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Comparator#compare(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compare(java.lang.Object, java.lang.Object)");
    method.setSimpleName("compare");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Comparator#compare(java.lang.Object, java.lang.Object)
    // starting method java.util.Comparator#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Comparator#equals(java.lang.Object)

// finishing type java.util.Comparator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ConcurrentModificationException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","RuntimeException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.ConcurrentModificationException#ConcurrentModificationException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ConcurrentModificationException()");
    method.setSimpleName("ConcurrentModificationException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ConcurrentModificationException#ConcurrentModificationException()
    // starting method java.util.ConcurrentModificationException#ConcurrentModificationException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ConcurrentModificationException(java.lang.String)");
    method.setSimpleName("ConcurrentModificationException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ConcurrentModificationException#ConcurrentModificationException(java.lang.String)

// finishing type java.util.ConcurrentModificationException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Currency$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface PrivilegedAction 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PrivilegedAction");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface PrivilegedAction 


    // starting method java.util.Currency$1#Currency$1()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Currency$1()");
    method.setSimpleName("Currency$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency$1#Currency$1()
    // starting method java.util.Currency$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency$1#run()

// finishing type java.util.Currency$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Currency");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Currency#serialVersionUID 

// ignoring field java.util.Currency#currencyCode 

// ignoring field java.util.Currency#defaultFractionDigits 

// ignoring field java.util.Currency#instances 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#mainTable
	field = newType.addNode(JavaDataField.class,"mainTable"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#mainTable

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scCutOverTimes
	field = newType.addNode(JavaDataField.class,"scCutOverTimes"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scCutOverTimes

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scOldCurrencies
	field = newType.addNode(JavaDataField.class,"scOldCurrencies"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scOldCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scNewCurrencies
	field = newType.addNode(JavaDataField.class,"scNewCurrencies"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scNewCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scOldCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"scOldCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scOldCurrenciesDFD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#scNewCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"scNewCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#scNewCurrenciesDFD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#otherCurrencies
	field = newType.addNode(JavaDataField.class,"otherCurrencies"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#otherCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Currency#otherCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"otherCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 8, isArray, arrayDimensions);
    // finishing field java.util.Currency#otherCurrenciesDFD

// ignoring field java.util.Currency#A_TO_Z 

// ignoring field java.util.Currency#INVALID_COUNTRY_ENTRY 

// ignoring field java.util.Currency#COUNTRY_WITHOUT_CURRENCY_ENTRY 

// ignoring field java.util.Currency#SIMPLE_CASE_COUNTRY_MASK 

// ignoring field java.util.Currency#SIMPLE_CASE_COUNTRY_FINAL_CHAR_MASK 

// ignoring field java.util.Currency#SIMPLE_CASE_COUNTRY_DEFAULT_DIGITS_MASK 

// ignoring field java.util.Currency#SIMPLE_CASE_COUNTRY_DEFAULT_DIGITS_SHIFT 

// ignoring field java.util.Currency#SPECIAL_CASE_COUNTRY_MASK 

// ignoring field java.util.Currency#SPECIAL_CASE_COUNTRY_INDEX_MASK 

// ignoring field java.util.Currency#SPECIAL_CASE_COUNTRY_INDEX_DELTA 

// ignoring field java.util.Currency#COUNTRY_TYPE_MASK 


    // ignoring method java.util.Currency#Currency(java.lang.String, int)
    // starting method java.util.Currency#getInstance(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.lang.String)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Currency");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getInstance(java.lang.String)
    // ignoring method java.util.Currency#getInstance(java.lang.String, int)
    // starting method java.util.Currency#getInstance(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getInstance(java.util.Locale)");
    method.setSimpleName("getInstance");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Currency");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getInstance(java.util.Locale)
    // starting method java.util.Currency#getCurrencyCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getCurrencyCode()");
    method.setSimpleName("getCurrencyCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getCurrencyCode()
    // starting method java.util.Currency#getSymbol()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSymbol()");
    method.setSimpleName("getSymbol");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getSymbol()
    // starting method java.util.Currency#getSymbol(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSymbol(java.util.Locale)");
    method.setSimpleName("getSymbol");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getSymbol(java.util.Locale)
    // starting method java.util.Currency#getDefaultFractionDigits()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDefaultFractionDigits()");
    method.setSimpleName("getDefaultFractionDigits");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#getDefaultFractionDigits()
    // starting method java.util.Currency#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Currency#toString()
    // ignoring method java.util.Currency#readResolve()
    // ignoring method java.util.Currency#getMainTableEntry(char, char)

// finishing type java.util.Currency
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "CurrencyData");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#mainTable
	field = newType.addNode(JavaDataField.class,"mainTable"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#mainTable

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scCutOverTimes
	field = newType.addNode(JavaDataField.class,"scCutOverTimes"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scCutOverTimes

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scOldCurrencies
	field = newType.addNode(JavaDataField.class,"scOldCurrencies"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scOldCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scNewCurrencies
	field = newType.addNode(JavaDataField.class,"scNewCurrencies"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scNewCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scOldCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"scOldCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scOldCurrenciesDFD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#scNewCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"scNewCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#scNewCurrenciesDFD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#otherCurrencies
	field = newType.addNode(JavaDataField.class,"otherCurrencies"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#otherCurrencies

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.CurrencyData#otherCurrenciesDFD
	field = newType.addNode(JavaDataField.class,"otherCurrenciesDFD"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.CurrencyData#otherCurrenciesDFD


    // starting method java.util.CurrencyData#CurrencyData()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"CurrencyData()");
    method.setSimpleName("CurrencyData");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.CurrencyData#CurrencyData()

// finishing type java.util.CurrencyData
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Date");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Comparable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Comparable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparable 

// ignoring field java.util.Date#gcal 

// ignoring field java.util.Date#jcal 

// ignoring field java.util.Date#fastTime 

// ignoring field java.util.Date#cdate 

// ignoring field java.util.Date#defaultCenturyStart 

// ignoring field java.util.Date#serialVersionUID 

// ignoring field java.util.Date#wtb 

// ignoring field java.util.Date#ttb 


    // starting method java.util.Date#Date()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date()");
    method.setSimpleName("Date");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date()
    // starting method java.util.Date#Date(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(long)");
    method.setSimpleName("Date");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(long)
    // starting method java.util.Date#Date(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(int, int, int)");
    method.setSimpleName("Date");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(int, int, int)
    // starting method java.util.Date#Date(int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(int, int, int, int, int)");
    method.setSimpleName("Date");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(int, int, int, int, int)
    // starting method java.util.Date#Date(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(int, int, int, int, int, int)");
    method.setSimpleName("Date");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(int, int, int, int, int, int)
    // starting method java.util.Date#Date(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Date(java.lang.String)");
    method.setSimpleName("Date");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#Date(java.lang.String)
    // starting method java.util.Date#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#clone()
    // starting method java.util.Date#UTC(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"UTC(int, int, int, int, int, int)");
    method.setSimpleName("UTC");
    helper.setMethodData(method,131081);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#UTC(int, int, int, int, int, int)
    // starting method java.util.Date#parse(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"parse(java.lang.String)");
    method.setSimpleName("parse");
    helper.setMethodData(method,131081);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#parse(java.lang.String)
    // starting method java.util.Date#getYear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getYear()");
    method.setSimpleName("getYear");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getYear()
    // starting method java.util.Date#setYear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setYear(int)");
    method.setSimpleName("setYear");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setYear(int)
    // starting method java.util.Date#getMonth()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMonth()");
    method.setSimpleName("getMonth");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getMonth()
    // starting method java.util.Date#setMonth(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setMonth(int)");
    method.setSimpleName("setMonth");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setMonth(int)
    // starting method java.util.Date#getDate()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDate()");
    method.setSimpleName("getDate");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getDate()
    // starting method java.util.Date#setDate(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setDate(int)");
    method.setSimpleName("setDate");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setDate(int)
    // starting method java.util.Date#getDay()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDay()");
    method.setSimpleName("getDay");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getDay()
    // starting method java.util.Date#getHours()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getHours()");
    method.setSimpleName("getHours");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getHours()
    // starting method java.util.Date#setHours(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setHours(int)");
    method.setSimpleName("setHours");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setHours(int)
    // starting method java.util.Date#getMinutes()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMinutes()");
    method.setSimpleName("getMinutes");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getMinutes()
    // starting method java.util.Date#setMinutes(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setMinutes(int)");
    method.setSimpleName("setMinutes");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setMinutes(int)
    // starting method java.util.Date#getSeconds()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSeconds()");
    method.setSimpleName("getSeconds");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getSeconds()
    // starting method java.util.Date#setSeconds(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setSeconds(int)");
    method.setSimpleName("setSeconds");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setSeconds(int)
    // starting method java.util.Date#getTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTime()");
    method.setSimpleName("getTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getTime()
    // ignoring method java.util.Date#getTimeImpl()
    // starting method java.util.Date#setTime(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTime(long)");
    method.setSimpleName("setTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#setTime(long)
    // starting method java.util.Date#before(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"before(java.util.Date)");
    method.setSimpleName("before");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#before(java.util.Date)
    // starting method java.util.Date#after(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"after(java.util.Date)");
    method.setSimpleName("after");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#after(java.util.Date)
    // starting method java.util.Date#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#equals(java.lang.Object)
    // starting method java.util.Date#getMillisOf(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMillisOf(java.util.Date)");
    method.setSimpleName("getMillisOf");
    helper.setMethodData(method,24);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getMillisOf(java.util.Date)
    // starting method java.util.Date#compareTo(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.util.Date)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#compareTo(java.util.Date)
    // starting method java.util.Date#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#hashCode()
    // starting method java.util.Date#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#toString()
    // ignoring method java.util.Date#convertToAbbr(java.lang.StringBuilder, java.lang.String)
    // starting method java.util.Date#toLocaleString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toLocaleString()");
    method.setSimpleName("toLocaleString");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#toLocaleString()
    // starting method java.util.Date#toGMTString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toGMTString()");
    method.setSimpleName("toGMTString");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#toGMTString()
    // starting method java.util.Date#getTimezoneOffset()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimezoneOffset()");
    method.setSimpleName("getTimezoneOffset");
    helper.setMethodData(method,131073);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#getTimezoneOffset()
    // ignoring method java.util.Date#getCalendarDate()
    // ignoring method java.util.Date#normalize()
    // ignoring method java.util.Date#normalize(sun.util.calendar.BaseCalendar$Date)
    // ignoring method java.util.Date#getCalendarSystem(int)
    // ignoring method java.util.Date#getCalendarSystem(long)
    // ignoring method java.util.Date#getCalendarSystem(sun.util.calendar.BaseCalendar$Date)
    // ignoring method java.util.Date#getJulianCalendar()
    // ignoring method java.util.Date#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.Date#readObject(java.io.ObjectInputStream)
    // starting method java.util.Date#compareTo(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.lang.Object)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Date#compareTo(java.lang.Object)

// finishing type java.util.Date
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Dictionary");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Dictionary#Dictionary()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Dictionary()");
    method.setSimpleName("Dictionary");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#Dictionary()
    // starting method java.util.Dictionary#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#size()
    // starting method java.util.Dictionary#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#isEmpty()
    // starting method java.util.Dictionary#keys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keys()");
    method.setSimpleName("keys");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#keys()
    // starting method java.util.Dictionary#elements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elements()");
    method.setSimpleName("elements");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#elements()
    // starting method java.util.Dictionary#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#get(java.lang.Object)
    // starting method java.util.Dictionary#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Dictionary#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Dictionary#remove(java.lang.Object)

// finishing type java.util.Dictionary
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "DuplicateFormatFlagsException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.DuplicateFormatFlagsException#serialVersionUID 

// ignoring field java.util.DuplicateFormatFlagsException#flags 


    // starting method java.util.DuplicateFormatFlagsException#DuplicateFormatFlagsException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"DuplicateFormatFlagsException(java.lang.String)");
    method.setSimpleName("DuplicateFormatFlagsException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.DuplicateFormatFlagsException#DuplicateFormatFlagsException(java.lang.String)
    // starting method java.util.DuplicateFormatFlagsException#getFlags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFlags()");
    method.setSimpleName("getFlags");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.DuplicateFormatFlagsException#getFlags()
    // starting method java.util.DuplicateFormatFlagsException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.DuplicateFormatFlagsException#getMessage()

// finishing type java.util.DuplicateFormatFlagsException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EmptyStackException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","RuntimeException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.EmptyStackException#EmptyStackException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EmptyStackException()");
    method.setSimpleName("EmptyStackException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EmptyStackException#EmptyStackException()

// finishing type java.util.EmptyStackException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Enumeration");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Enumeration#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Enumeration#hasMoreElements()
    // starting method java.util.Enumeration#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Enumeration#nextElement()

// finishing type java.util.Enumeration
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.EnumMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumMap$EnumMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EntryIterator#this$0


    // ignoring method java.util.EnumMap$EntryIterator#EnumMap$EntryIterator(java.util.EnumMap)
    // starting method java.util.EnumMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#next()
    // starting method java.util.EnumMap$EntryIterator#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Enum");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#getKey()
    // starting method java.util.EnumMap$EntryIterator#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#getValue()
    // starting method java.util.EnumMap$EntryIterator#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#setValue(java.lang.Object)
    // starting method java.util.EnumMap$EntryIterator#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#equals(java.lang.Object)
    // starting method java.util.EnumMap$EntryIterator#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#hashCode()
    // starting method java.util.EnumMap$EntryIterator#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#toString()
    // ignoring method java.util.EnumMap$EntryIterator#checkLastReturnedIndexForEntryUse()
    // starting method java.util.EnumMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#next()
    // starting method java.util.EnumMap$EntryIterator#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#getKey()
    // starting method java.util.EnumMap$EntryIterator#EnumMap$EntryIterator(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$EntryIterator(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntryIterator#EnumMap$EntryIterator(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EntrySet#this$0


    // ignoring method java.util.EnumMap$EntrySet#EnumMap$EntrySet(java.util.EnumMap)
    // starting method java.util.EnumMap$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#iterator()
    // starting method java.util.EnumMap$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#contains(java.lang.Object)
    // starting method java.util.EnumMap$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#remove(java.lang.Object)
    // starting method java.util.EnumMap$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#size()
    // starting method java.util.EnumMap$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#clear()
    // starting method java.util.EnumMap$EntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#toArray()
    // starting method java.util.EnumMap$EntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#toArray(java.lang.Object[])
    // ignoring method java.util.EnumMap$EntrySet#fillEntryArray(java.lang.Object[])
    // starting method java.util.EnumMap$EntrySet#EnumMap$EntrySet(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$EntrySet(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EntrySet#EnumMap$EntrySet(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$EnumMapIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EnumMapIterator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EnumMapIterator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EnumMapIterator#lastReturnedIndex
	field = newType.addNode(JavaDataField.class,"lastReturnedIndex"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EnumMapIterator#lastReturnedIndex

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$EnumMapIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$EnumMapIterator#this$0


    // ignoring method java.util.EnumMap$EnumMapIterator#EnumMap$EnumMapIterator(java.util.EnumMap)
    // starting method java.util.EnumMap$EnumMapIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EnumMapIterator#hasNext()
    // starting method java.util.EnumMap$EnumMapIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EnumMapIterator#remove()
    // ignoring method java.util.EnumMap$EnumMapIterator#checkLastReturnedIndex()
    // starting method java.util.EnumMap$EnumMapIterator#EnumMap$EnumMapIterator(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$EnumMapIterator(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$EnumMapIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$EnumMapIterator#EnumMap$EnumMapIterator(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$EnumMapIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumMap$EnumMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$KeyIterator#this$0


    // ignoring method java.util.EnumMap$KeyIterator#EnumMap$KeyIterator(java.util.EnumMap)
    // starting method java.util.EnumMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Enum");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeyIterator#next()
    // starting method java.util.EnumMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeyIterator#next()
    // starting method java.util.EnumMap$KeyIterator#EnumMap$KeyIterator(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$KeyIterator(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeyIterator#EnumMap$KeyIterator(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$KeySet#this$0


    // ignoring method java.util.EnumMap$KeySet#EnumMap$KeySet(java.util.EnumMap)
    // starting method java.util.EnumMap$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#iterator()
    // starting method java.util.EnumMap$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#size()
    // starting method java.util.EnumMap$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#contains(java.lang.Object)
    // starting method java.util.EnumMap$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#remove(java.lang.Object)
    // starting method java.util.EnumMap$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#clear()
    // starting method java.util.EnumMap$KeySet#EnumMap$KeySet(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$KeySet(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$KeySet#EnumMap$KeySet(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumMap$EnumMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$ValueIterator#this$0


    // ignoring method java.util.EnumMap$ValueIterator#EnumMap$ValueIterator(java.util.EnumMap)
    // starting method java.util.EnumMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$ValueIterator#next()
    // starting method java.util.EnumMap$ValueIterator#EnumMap$ValueIterator(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$ValueIterator(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$ValueIterator#EnumMap$ValueIterator(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap$Values");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumMap$Values#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.EnumMap$Values#this$0


    // ignoring method java.util.EnumMap$Values#EnumMap$Values(java.util.EnumMap)
    // starting method java.util.EnumMap$Values#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#iterator()
    // starting method java.util.EnumMap$Values#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#size()
    // starting method java.util.EnumMap$Values#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#contains(java.lang.Object)
    // starting method java.util.EnumMap$Values#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#remove(java.lang.Object)
    // starting method java.util.EnumMap$Values#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#clear()
    // starting method java.util.EnumMap$Values#EnumMap$Values(java.util.EnumMap, java.util.EnumMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap$Values(java.util.EnumMap, java.util.EnumMap$1)");
    method.setSimpleName("EnumMap$Values");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap$Values#EnumMap$Values(java.util.EnumMap, java.util.EnumMap$1)

// finishing type java.util.EnumMap$Values
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 

// ignoring field java.util.EnumMap#keyType 

// ignoring field java.util.EnumMap#keyUniverse 

// ignoring field java.util.EnumMap#vals 

// ignoring field java.util.EnumMap#size 

// ignoring field java.util.EnumMap#NULL 

// ignoring field java.util.EnumMap#ZERO_LENGTH_ENUM_ARRAY 

// ignoring field java.util.EnumMap#entrySet 

// ignoring field java.util.EnumMap#serialVersionUID 


    // ignoring method java.util.EnumMap#maskNull(java.lang.Object)
    // ignoring method java.util.EnumMap#unmaskNull(java.lang.Object)
    // starting method java.util.EnumMap#EnumMap(java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap(java.lang.Class)");
    method.setSimpleName("EnumMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#EnumMap(java.lang.Class)
    // starting method java.util.EnumMap#EnumMap(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap(java.util.EnumMap)");
    method.setSimpleName("EnumMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#EnumMap(java.util.EnumMap)
    // starting method java.util.EnumMap#EnumMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumMap(java.util.Map)");
    method.setSimpleName("EnumMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#EnumMap(java.util.Map)
    // starting method java.util.EnumMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#size()
    // starting method java.util.EnumMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#containsValue(java.lang.Object)
    // starting method java.util.EnumMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#containsKey(java.lang.Object)
    // ignoring method java.util.EnumMap#containsMapping(java.lang.Object, java.lang.Object)
    // starting method java.util.EnumMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#get(java.lang.Object)
    // starting method java.util.EnumMap#put(java.lang.Enum, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Enum, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#put(java.lang.Enum, java.lang.Object)
    // starting method java.util.EnumMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#remove(java.lang.Object)
    // ignoring method java.util.EnumMap#removeMapping(java.lang.Object, java.lang.Object)
    // ignoring method java.util.EnumMap#isValidKey(java.lang.Object)
    // starting method java.util.EnumMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#putAll(java.util.Map)
    // starting method java.util.EnumMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#clear()
    // starting method java.util.EnumMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#keySet()
    // starting method java.util.EnumMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#values()
    // starting method java.util.EnumMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#entrySet()
    // starting method java.util.EnumMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#equals(java.lang.Object)
    // starting method java.util.EnumMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#clone()
    // ignoring method java.util.EnumMap#typeCheck(java.lang.Enum)
    // ignoring method java.util.EnumMap#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.EnumMap#readObject(java.io.ObjectInputStream)
    // starting method java.util.EnumMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","CloneNotSupportedException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.CloneNotSupportedException
    
    // finishing method java.util.EnumMap#clone()
    // starting method java.util.EnumMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.EnumMap#access$200(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.EnumMap)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$200(java.util.EnumMap)
    // starting method java.util.EnumMap#access$500(java.util.EnumMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$500(java.util.EnumMap, java.lang.Object)");
    method.setSimpleName("access$500");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$500(java.util.EnumMap, java.lang.Object)
    // starting method java.util.EnumMap#access$600(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$600(java.util.EnumMap)");
    method.setSimpleName("access$600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$600(java.util.EnumMap)
    // starting method java.util.EnumMap#access$210(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$210(java.util.EnumMap)");
    method.setSimpleName("access$210");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$210(java.util.EnumMap)
    // starting method java.util.EnumMap#access$900(java.util.EnumMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$900(java.util.EnumMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$900");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$900(java.util.EnumMap, java.lang.Object, java.lang.Object)
    // starting method java.util.EnumMap#access$1000(java.util.EnumMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1000(java.util.EnumMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$1000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$1000(java.util.EnumMap, java.lang.Object, java.lang.Object)
    // starting method java.util.EnumMap#access$1100(java.util.EnumMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1100(java.util.EnumMap)");
    method.setSimpleName("access$1100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$1100(java.util.EnumMap)
    // starting method java.util.EnumMap#access$1200(java.util.EnumMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1200(java.util.EnumMap, java.lang.Object)");
    method.setSimpleName("access$1200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$1200(java.util.EnumMap, java.lang.Object)
    // starting method java.util.EnumMap#access$1400()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1400()");
    method.setSimpleName("access$1400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumMap#access$1400()

// finishing type java.util.EnumMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumSet$SerializationProxy");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.EnumSet$SerializationProxy#elementType 

// ignoring field java.util.EnumSet$SerializationProxy#elements 

// ignoring field java.util.EnumSet$SerializationProxy#serialVersionUID 


    // starting method java.util.EnumSet$SerializationProxy#EnumSet$SerializationProxy(java.util.EnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumSet$SerializationProxy(java.util.EnumSet)");
    method.setSimpleName("EnumSet$SerializationProxy");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet$SerializationProxy#EnumSet$SerializationProxy(java.util.EnumSet)
    // ignoring method java.util.EnumSet$SerializationProxy#readResolve()

// finishing type java.util.EnumSet$SerializationProxy
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EnumSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumSet#elementType
	field = newType.addNode(JavaDataField.class,"elementType"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.EnumSet#elementType

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EnumSet#universe
	field = newType.addNode(JavaDataField.class,"universe"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.EnumSet#universe

// ignoring field java.util.EnumSet#ZERO_LENGTH_ENUM_ARRAY 


    // starting method java.util.EnumSet#EnumSet(java.lang.Class, java.lang.Enum[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EnumSet(java.lang.Class, java.lang.Enum[])");
    method.setSimpleName("EnumSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#EnumSet(java.lang.Class, java.lang.Enum[])
    // starting method java.util.EnumSet#noneOf(java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"noneOf(java.lang.Class)");
    method.setSimpleName("noneOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#noneOf(java.lang.Class)
    // starting method java.util.EnumSet#allOf(java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"allOf(java.lang.Class)");
    method.setSimpleName("allOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#allOf(java.lang.Class)
    // starting method java.util.EnumSet#addAll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll()");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1024);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#addAll()
    // starting method java.util.EnumSet#copyOf(java.util.EnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"copyOf(java.util.EnumSet)");
    method.setSimpleName("copyOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#copyOf(java.util.EnumSet)
    // starting method java.util.EnumSet#copyOf(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"copyOf(java.util.Collection)");
    method.setSimpleName("copyOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#copyOf(java.util.Collection)
    // starting method java.util.EnumSet#complementOf(java.util.EnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complementOf(java.util.EnumSet)");
    method.setSimpleName("complementOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#complementOf(java.util.EnumSet)
    // starting method java.util.EnumSet#of(java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("of");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"of(java.lang.Enum, java.lang.Enum[])");
    method.setSimpleName("of");
    helper.setMethodData(method,137);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#of(java.lang.Enum, java.lang.Enum[])
    // starting method java.util.EnumSet#range(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"range(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("range");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#range(java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#addRange(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addRange(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("addRange");
    helper.setMethodData(method,1024);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#addRange(java.lang.Enum, java.lang.Enum)
    // starting method java.util.EnumSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#clone()
    // starting method java.util.EnumSet#complement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complement()");
    method.setSimpleName("complement");
    helper.setMethodData(method,1024);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#complement()
    // starting method java.util.EnumSet#typeCheck(java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"typeCheck(java.lang.Enum)");
    method.setSimpleName("typeCheck");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#typeCheck(java.lang.Enum)
    // starting method java.util.EnumSet#writeReplace()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"writeReplace()");
    method.setSimpleName("writeReplace");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#writeReplace()
    // starting method java.util.EnumSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","CloneNotSupportedException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.CloneNotSupportedException
    
    // finishing method java.util.EnumSet#clone()
    // starting method java.util.EnumSet#access$000()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000()");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EnumSet#access$000()

// finishing type java.util.EnumSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "EventListener");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.EventListener
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EventListenerProxy");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface EventListener 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EventListener");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface EventListener 

// ignoring field java.util.EventListenerProxy#listener 


    // starting method java.util.EventListenerProxy#EventListenerProxy(java.util.EventListener)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EventListenerProxy(java.util.EventListener)");
    method.setSimpleName("EventListenerProxy");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventListenerProxy#EventListenerProxy(java.util.EventListener)
    // starting method java.util.EventListenerProxy#getListener()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getListener()");
    method.setSimpleName("getListener");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EventListener");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventListenerProxy#getListener()

// finishing type java.util.EventListenerProxy
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "EventObject");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.EventObject#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.EventObject#source
	field = newType.addNode(JavaDataField.class,"source"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 132, isArray, arrayDimensions);
    // finishing field java.util.EventObject#source


    // starting method java.util.EventObject#EventObject(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"EventObject(java.lang.Object)");
    method.setSimpleName("EventObject");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventObject#EventObject(java.lang.Object)
    // starting method java.util.EventObject#getSource()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getSource()");
    method.setSimpleName("getSource");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventObject#getSource()
    // starting method java.util.EventObject#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.EventObject#toString()

// finishing type java.util.EventObject
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "FormatFlagsConversionMismatchException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.FormatFlagsConversionMismatchException#serialVersionUID 

// ignoring field java.util.FormatFlagsConversionMismatchException#f 

// ignoring field java.util.FormatFlagsConversionMismatchException#c 


    // starting method java.util.FormatFlagsConversionMismatchException#FormatFlagsConversionMismatchException(java.lang.String, char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"FormatFlagsConversionMismatchException(java.lang.String, char)");
    method.setSimpleName("FormatFlagsConversionMismatchException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatFlagsConversionMismatchException#FormatFlagsConversionMismatchException(java.lang.String, char)
    // starting method java.util.FormatFlagsConversionMismatchException#getFlags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFlags()");
    method.setSimpleName("getFlags");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatFlagsConversionMismatchException#getFlags()
    // starting method java.util.FormatFlagsConversionMismatchException#getConversion()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getConversion()");
    method.setSimpleName("getConversion");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "char");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatFlagsConversionMismatchException#getConversion()
    // starting method java.util.FormatFlagsConversionMismatchException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatFlagsConversionMismatchException#getMessage()

// finishing type java.util.FormatFlagsConversionMismatchException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Formattable");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Formattable#formatTo(java.util.Formatter, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"formatTo(java.util.Formatter, int, int, int)");
    method.setSimpleName("formatTo");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formattable#formatTo(java.util.Formatter, int, int, int)

// finishing type java.util.Formattable
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "FormattableFlags");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.FormattableFlags#LEFT_JUSTIFY
	field = newType.addNode(JavaDataField.class,"LEFT_JUSTIFY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.FormattableFlags#LEFT_JUSTIFY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.FormattableFlags#UPPERCASE
	field = newType.addNode(JavaDataField.class,"UPPERCASE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.FormattableFlags#UPPERCASE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.FormattableFlags#ALTERNATE
	field = newType.addNode(JavaDataField.class,"ALTERNATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.FormattableFlags#ALTERNATE


    // ignoring method java.util.FormattableFlags#FormattableFlags()

// finishing type java.util.FormattableFlags
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeEnum.class,"java.util", "Formatter$BigDecimalLayoutForm");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Enum");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$BigDecimalLayoutForm#SCIENTIFIC
	field = newType.addNode(JavaDataField.class,"SCIENTIFIC"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$BigDecimalLayoutForm");
    helper.insertFieldData(field, fieldType, 16409, isArray, arrayDimensions);
    // finishing field java.util.Formatter$BigDecimalLayoutForm#SCIENTIFIC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$BigDecimalLayoutForm#DECIMAL_FLOAT
	field = newType.addNode(JavaDataField.class,"DECIMAL_FLOAT"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$BigDecimalLayoutForm");
    helper.insertFieldData(field, fieldType, 16409, isArray, arrayDimensions);
    // finishing field java.util.Formatter$BigDecimalLayoutForm#DECIMAL_FLOAT

// ignoring field java.util.Formatter$BigDecimalLayoutForm#$VALUES 


    // starting method java.util.Formatter$BigDecimalLayoutForm#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$BigDecimalLayoutForm#values()
    // starting method java.util.Formatter$BigDecimalLayoutForm#valueOf(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"valueOf(java.lang.String)");
    method.setSimpleName("valueOf");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$BigDecimalLayoutForm");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$BigDecimalLayoutForm#valueOf(java.lang.String)
    // ignoring method java.util.Formatter$BigDecimalLayoutForm#Formatter$BigDecimalLayoutForm(java.lang.String, int)

// finishing type java.util.Formatter$BigDecimalLayoutForm
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$Conversion");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#DECIMAL_INTEGER
	field = newType.addNode(JavaDataField.class,"DECIMAL_INTEGER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#DECIMAL_INTEGER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#OCTAL_INTEGER
	field = newType.addNode(JavaDataField.class,"OCTAL_INTEGER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#OCTAL_INTEGER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HEXADECIMAL_INTEGER
	field = newType.addNode(JavaDataField.class,"HEXADECIMAL_INTEGER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HEXADECIMAL_INTEGER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HEXADECIMAL_INTEGER_UPPER
	field = newType.addNode(JavaDataField.class,"HEXADECIMAL_INTEGER_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HEXADECIMAL_INTEGER_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#SCIENTIFIC
	field = newType.addNode(JavaDataField.class,"SCIENTIFIC"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#SCIENTIFIC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#SCIENTIFIC_UPPER
	field = newType.addNode(JavaDataField.class,"SCIENTIFIC_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#SCIENTIFIC_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#GENERAL
	field = newType.addNode(JavaDataField.class,"GENERAL"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#GENERAL

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#GENERAL_UPPER
	field = newType.addNode(JavaDataField.class,"GENERAL_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#GENERAL_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#DECIMAL_FLOAT
	field = newType.addNode(JavaDataField.class,"DECIMAL_FLOAT"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#DECIMAL_FLOAT

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HEXADECIMAL_FLOAT
	field = newType.addNode(JavaDataField.class,"HEXADECIMAL_FLOAT"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HEXADECIMAL_FLOAT

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HEXADECIMAL_FLOAT_UPPER
	field = newType.addNode(JavaDataField.class,"HEXADECIMAL_FLOAT_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HEXADECIMAL_FLOAT_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#CHARACTER
	field = newType.addNode(JavaDataField.class,"CHARACTER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#CHARACTER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#CHARACTER_UPPER
	field = newType.addNode(JavaDataField.class,"CHARACTER_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#CHARACTER_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#DATE_TIME
	field = newType.addNode(JavaDataField.class,"DATE_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#DATE_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#DATE_TIME_UPPER
	field = newType.addNode(JavaDataField.class,"DATE_TIME_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#DATE_TIME_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#BOOLEAN
	field = newType.addNode(JavaDataField.class,"BOOLEAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#BOOLEAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#BOOLEAN_UPPER
	field = newType.addNode(JavaDataField.class,"BOOLEAN_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#BOOLEAN_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#STRING
	field = newType.addNode(JavaDataField.class,"STRING"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#STRING

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#STRING_UPPER
	field = newType.addNode(JavaDataField.class,"STRING_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#STRING_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HASHCODE
	field = newType.addNode(JavaDataField.class,"HASHCODE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HASHCODE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#HASHCODE_UPPER
	field = newType.addNode(JavaDataField.class,"HASHCODE_UPPER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#HASHCODE_UPPER

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#LINE_SEPARATOR
	field = newType.addNode(JavaDataField.class,"LINE_SEPARATOR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#LINE_SEPARATOR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Conversion#PERCENT_SIGN
	field = newType.addNode(JavaDataField.class,"PERCENT_SIGN"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Conversion#PERCENT_SIGN


    // ignoring method java.util.Formatter$Conversion#Formatter$Conversion()
    // starting method java.util.Formatter$Conversion#isValid(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isValid(char)");
    method.setSimpleName("isValid");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isValid(char)
    // starting method java.util.Formatter$Conversion#isGeneral(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isGeneral(char)");
    method.setSimpleName("isGeneral");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isGeneral(char)
    // starting method java.util.Formatter$Conversion#isInteger(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isInteger(char)");
    method.setSimpleName("isInteger");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isInteger(char)
    // starting method java.util.Formatter$Conversion#isFloat(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isFloat(char)");
    method.setSimpleName("isFloat");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isFloat(char)
    // starting method java.util.Formatter$Conversion#isText(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isText(char)");
    method.setSimpleName("isText");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Conversion#isText(char)

// finishing type java.util.Formatter$Conversion
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$DateTime");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#HOUR_OF_DAY_0
	field = newType.addNode(JavaDataField.class,"HOUR_OF_DAY_0"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#HOUR_OF_DAY_0

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#HOUR_0
	field = newType.addNode(JavaDataField.class,"HOUR_0"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#HOUR_0

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#HOUR_OF_DAY
	field = newType.addNode(JavaDataField.class,"HOUR_OF_DAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#HOUR_OF_DAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#HOUR
	field = newType.addNode(JavaDataField.class,"HOUR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#HOUR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#MINUTE
	field = newType.addNode(JavaDataField.class,"MINUTE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#MINUTE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NANOSECOND
	field = newType.addNode(JavaDataField.class,"NANOSECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NANOSECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#MILLISECOND
	field = newType.addNode(JavaDataField.class,"MILLISECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#MILLISECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#MILLISECOND_SINCE_EPOCH
	field = newType.addNode(JavaDataField.class,"MILLISECOND_SINCE_EPOCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#MILLISECOND_SINCE_EPOCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#AM_PM
	field = newType.addNode(JavaDataField.class,"AM_PM"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#AM_PM

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#SECONDS_SINCE_EPOCH
	field = newType.addNode(JavaDataField.class,"SECONDS_SINCE_EPOCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#SECONDS_SINCE_EPOCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#SECOND
	field = newType.addNode(JavaDataField.class,"SECOND"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#SECOND

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#TIME
	field = newType.addNode(JavaDataField.class,"TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#ZONE_NUMERIC
	field = newType.addNode(JavaDataField.class,"ZONE_NUMERIC"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#ZONE_NUMERIC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#ZONE
	field = newType.addNode(JavaDataField.class,"ZONE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#ZONE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_DAY_ABBREV
	field = newType.addNode(JavaDataField.class,"NAME_OF_DAY_ABBREV"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_DAY_ABBREV

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_DAY
	field = newType.addNode(JavaDataField.class,"NAME_OF_DAY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_DAY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_MONTH_ABBREV
	field = newType.addNode(JavaDataField.class,"NAME_OF_MONTH_ABBREV"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_MONTH_ABBREV

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_MONTH
	field = newType.addNode(JavaDataField.class,"NAME_OF_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#CENTURY
	field = newType.addNode(JavaDataField.class,"CENTURY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#CENTURY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DAY_OF_MONTH_0
	field = newType.addNode(JavaDataField.class,"DAY_OF_MONTH_0"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DAY_OF_MONTH_0

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DAY_OF_MONTH
	field = newType.addNode(JavaDataField.class,"DAY_OF_MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DAY_OF_MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#NAME_OF_MONTH_ABBREV_X
	field = newType.addNode(JavaDataField.class,"NAME_OF_MONTH_ABBREV_X"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#NAME_OF_MONTH_ABBREV_X

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DAY_OF_YEAR
	field = newType.addNode(JavaDataField.class,"DAY_OF_YEAR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DAY_OF_YEAR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#MONTH
	field = newType.addNode(JavaDataField.class,"MONTH"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#MONTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#YEAR_2
	field = newType.addNode(JavaDataField.class,"YEAR_2"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#YEAR_2

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#YEAR_4
	field = newType.addNode(JavaDataField.class,"YEAR_4"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#YEAR_4

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#TIME_12_HOUR
	field = newType.addNode(JavaDataField.class,"TIME_12_HOUR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#TIME_12_HOUR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#TIME_24_HOUR
	field = newType.addNode(JavaDataField.class,"TIME_24_HOUR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#TIME_24_HOUR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DATE_TIME
	field = newType.addNode(JavaDataField.class,"DATE_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DATE_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#DATE
	field = newType.addNode(JavaDataField.class,"DATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#DATE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$DateTime#ISO_STANDARD_DATE
	field = newType.addNode(JavaDataField.class,"ISO_STANDARD_DATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","char");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$DateTime#ISO_STANDARD_DATE


    // ignoring method java.util.Formatter$DateTime#Formatter$DateTime()
    // starting method java.util.Formatter$DateTime#isValid(char)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isValid(char)");
    method.setSimpleName("isValid");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$DateTime#isValid(char)

// finishing type java.util.Formatter$DateTime
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FixedString");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Formatter$FormatString 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Formatter$FormatString");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Formatter$FormatString 

// ignoring field java.util.Formatter$FixedString#s 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$FixedString#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Formatter$FixedString#this$0


    // starting method java.util.Formatter$FixedString#Formatter$FixedString(java.util.Formatter, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter$FixedString(java.util.Formatter, java.lang.String)");
    method.setSimpleName("Formatter$FixedString");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FixedString#Formatter$FixedString(java.util.Formatter, java.lang.String)
    // starting method java.util.Formatter$FixedString#index()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"index()");
    method.setSimpleName("index");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FixedString#index()
    // starting method java.util.Formatter$FixedString#print(java.lang.Object, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"print(java.lang.Object, java.util.Locale)");
    method.setSimpleName("print");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Formatter$FixedString#print(java.lang.Object, java.util.Locale)
    // starting method java.util.Formatter$FixedString#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FixedString#toString()

// finishing type java.util.Formatter$FixedString
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$Flags");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Formatter$Flags#flags 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#NONE
	field = newType.addNode(JavaDataField.class,"NONE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#NONE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#LEFT_JUSTIFY
	field = newType.addNode(JavaDataField.class,"LEFT_JUSTIFY"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#LEFT_JUSTIFY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#UPPERCASE
	field = newType.addNode(JavaDataField.class,"UPPERCASE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#UPPERCASE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#ALTERNATE
	field = newType.addNode(JavaDataField.class,"ALTERNATE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#ALTERNATE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#PLUS
	field = newType.addNode(JavaDataField.class,"PLUS"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#PLUS

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#LEADING_SPACE
	field = newType.addNode(JavaDataField.class,"LEADING_SPACE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#LEADING_SPACE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#ZERO_PAD
	field = newType.addNode(JavaDataField.class,"ZERO_PAD"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#ZERO_PAD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#GROUP
	field = newType.addNode(JavaDataField.class,"GROUP"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#GROUP

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#PARENTHESES
	field = newType.addNode(JavaDataField.class,"PARENTHESES"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#PARENTHESES

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$Flags#PREVIOUS
	field = newType.addNode(JavaDataField.class,"PREVIOUS"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Formatter$Flags#PREVIOUS


    // ignoring method java.util.Formatter$Flags#Formatter$Flags(int)
    // starting method java.util.Formatter$Flags#valueOf()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"valueOf()");
    method.setSimpleName("valueOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#valueOf()
    // starting method java.util.Formatter$Flags#contains(java.util.Formatter$Flags)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.util.Formatter$Flags)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#contains(java.util.Formatter$Flags)
    // starting method java.util.Formatter$Flags#dup()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"dup()");
    method.setSimpleName("dup");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#dup()
    // ignoring method java.util.Formatter$Flags#add(java.util.Formatter$Flags)
    // starting method java.util.Formatter$Flags#remove(java.util.Formatter$Flags)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.util.Formatter$Flags)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#remove(java.util.Formatter$Flags)
    // starting method java.util.Formatter$Flags#parse(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"parse(java.lang.String)");
    method.setSimpleName("parse");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#parse(java.lang.String)
    // ignoring method java.util.Formatter$Flags#parse(char)
    // starting method java.util.Formatter$Flags#toString(java.util.Formatter$Flags)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString(java.util.Formatter$Flags)");
    method.setSimpleName("toString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#toString(java.util.Formatter$Flags)
    // starting method java.util.Formatter$Flags#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#toString()
    // starting method java.util.Formatter$Flags#access$100(java.util.Formatter$Flags, java.util.Formatter$Flags)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.Formatter$Flags, java.util.Formatter$Flags)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$Flags#access$100(java.util.Formatter$Flags, java.util.Formatter$Flags)

// finishing type java.util.Formatter$Flags
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FormatSpecifier$BigDecimalLayout");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Formatter$FormatSpecifier$BigDecimalLayout#mant 

// ignoring field java.util.Formatter$FormatSpecifier$BigDecimalLayout#exp 

// ignoring field java.util.Formatter$FormatSpecifier$BigDecimalLayout#dot 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$FormatSpecifier$BigDecimalLayout#this$1
	field = newType.addNode(JavaDataField.class,"this$1"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$FormatSpecifier");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Formatter$FormatSpecifier$BigDecimalLayout#this$1


    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#Formatter$FormatSpecifier$BigDecimalLayout(java.util.Formatter$FormatSpecifier, java.math.BigInteger, int, java.util.Formatter$BigDecimalLayoutForm)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter$FormatSpecifier$BigDecimalLayout(java.util.Formatter$FormatSpecifier, java.math.BigInteger, int, java.util.Formatter$BigDecimalLayoutForm)");
    method.setSimpleName("Formatter$FormatSpecifier$BigDecimalLayout");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#Formatter$FormatSpecifier$BigDecimalLayout(java.util.Formatter$FormatSpecifier, java.math.BigInteger, int, java.util.Formatter$BigDecimalLayoutForm)
    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#hasDot()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasDot()");
    method.setSimpleName("hasDot");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#hasDot()
    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#layoutChars()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"layoutChars()");
    method.setSimpleName("layoutChars");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#layoutChars()
    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#mantissa()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"mantissa()");
    method.setSimpleName("mantissa");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#mantissa()
    // starting method java.util.Formatter$FormatSpecifier$BigDecimalLayout#exponent()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"exponent()");
    method.setSimpleName("exponent");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier$BigDecimalLayout#exponent()
    // ignoring method java.util.Formatter$FormatSpecifier$BigDecimalLayout#toCharArray(java.lang.StringBuilder)
    // ignoring method java.util.Formatter$FormatSpecifier$BigDecimalLayout#layout(java.math.BigInteger, int, java.util.Formatter$BigDecimalLayoutForm)

// finishing type java.util.Formatter$FormatSpecifier$BigDecimalLayout
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter$FormatSpecifier");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Formatter$FormatString 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Formatter$FormatString");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Formatter$FormatString 

// ignoring field java.util.Formatter$FormatSpecifier#index 

// ignoring field java.util.Formatter$FormatSpecifier#f 

// ignoring field java.util.Formatter$FormatSpecifier#width 

// ignoring field java.util.Formatter$FormatSpecifier#precision 

// ignoring field java.util.Formatter$FormatSpecifier#dt 

// ignoring field java.util.Formatter$FormatSpecifier#c 

// ignoring field java.util.Formatter$FormatSpecifier#formatter 

// ignoring field java.util.Formatter$FormatSpecifier#ls 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$FormatSpecifier#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.Formatter$FormatSpecifier#$assertionsDisabled

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Formatter$FormatSpecifier#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Formatter$FormatSpecifier#this$0


    // ignoring method java.util.Formatter$FormatSpecifier#index(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#index()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"index()");
    method.setSimpleName("index");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#index()
    // ignoring method java.util.Formatter$FormatSpecifier#flags(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#flags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"flags()");
    method.setSimpleName("flags");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter$Flags");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#flags()
    // ignoring method java.util.Formatter$FormatSpecifier#width(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#width()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"width()");
    method.setSimpleName("width");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#width()
    // ignoring method java.util.Formatter$FormatSpecifier#precision(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#precision()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"precision()");
    method.setSimpleName("precision");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#precision()
    // ignoring method java.util.Formatter$FormatSpecifier#conversion(java.lang.String)
    // ignoring method java.util.Formatter$FormatSpecifier#conversion()
    // starting method java.util.Formatter$FormatSpecifier#Formatter$FormatSpecifier(java.util.Formatter, java.util.Formatter, java.lang.String[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter$FormatSpecifier(java.util.Formatter, java.util.Formatter, java.lang.String[])");
    method.setSimpleName("Formatter$FormatSpecifier");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#Formatter$FormatSpecifier(java.util.Formatter, java.util.Formatter, java.lang.String[])
    // starting method java.util.Formatter$FormatSpecifier#print(java.lang.Object, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"print(java.lang.Object, java.util.Locale)");
    method.setSimpleName("print");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Formatter$FormatSpecifier#print(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printInteger(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printFloat(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printDateTime(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printCharacter(java.lang.Object)
    // ignoring method java.util.Formatter$FormatSpecifier#printString(java.lang.Object, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#printBoolean(java.lang.Object)
    // ignoring method java.util.Formatter$FormatSpecifier#printHashCode(java.lang.Object)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.lang.String)
    // ignoring method java.util.Formatter$FormatSpecifier#justify(java.lang.String)
    // starting method java.util.Formatter$FormatSpecifier#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatSpecifier#toString()
    // ignoring method java.util.Formatter$FormatSpecifier#checkGeneral()
    // ignoring method java.util.Formatter$FormatSpecifier#checkDateTime()
    // ignoring method java.util.Formatter$FormatSpecifier#checkCharacter()
    // ignoring method java.util.Formatter$FormatSpecifier#checkInteger()
    // ignoring method java.util.Formatter$FormatSpecifier#checkBadFlags(java.util.Formatter$Flags[])
    // ignoring method java.util.Formatter$FormatSpecifier#checkFloat()
    // ignoring method java.util.Formatter$FormatSpecifier#checkNumeric()
    // ignoring method java.util.Formatter$FormatSpecifier#checkText()
    // ignoring method java.util.Formatter$FormatSpecifier#print(byte, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(short, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(int, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(long, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#leadingSign(java.lang.StringBuilder, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#trailingSign(java.lang.StringBuilder, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.math.BigInteger, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(float, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(double, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.lang.StringBuilder, double, java.util.Locale, java.util.Formatter$Flags, char, int, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#mantissa(char[], int)
    // ignoring method java.util.Formatter$FormatSpecifier#exponent(char[], int)
    // ignoring method java.util.Formatter$FormatSpecifier#addZeros(char[], int)
    // ignoring method java.util.Formatter$FormatSpecifier#hexDouble(double, int)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.math.BigDecimal, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.lang.StringBuilder, java.math.BigDecimal, java.util.Locale, java.util.Formatter$Flags, char, int, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#adjustWidth(int, java.util.Formatter$Flags, boolean)
    // ignoring method java.util.Formatter$FormatSpecifier#addDot(char[])
    // ignoring method java.util.Formatter$FormatSpecifier#trailingZeros(char[], int)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.util.Calendar, char, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#print(java.lang.StringBuilder, java.util.Calendar, char, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#failMismatch(java.util.Formatter$Flags, char)
    // ignoring method java.util.Formatter$FormatSpecifier#failConversion(char, java.lang.Object)
    // ignoring method java.util.Formatter$FormatSpecifier#getZero(java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#localizedMagnitude(java.lang.StringBuilder, long, java.util.Formatter$Flags, int, java.util.Locale)
    // ignoring method java.util.Formatter$FormatSpecifier#localizedMagnitude(java.lang.StringBuilder, char[], java.util.Formatter$Flags, int, java.util.Locale)

// finishing type java.util.Formatter$FormatSpecifier
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Formatter$FormatString");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Formatter$FormatString#index()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"index()");
    method.setSimpleName("index");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatString#index()
    // starting method java.util.Formatter$FormatString#print(java.lang.Object, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"print(java.lang.Object, java.util.Locale)");
    method.setSimpleName("print");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Formatter$FormatString#print(java.lang.Object, java.util.Locale)
    // starting method java.util.Formatter$FormatString#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter$FormatString#toString()

// finishing type java.util.Formatter$FormatString
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Formatter");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Closeable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Closeable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Closeable 
    // starting interface Flushable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Flushable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Flushable 

// ignoring field java.util.Formatter#a 

// ignoring field java.util.Formatter#l 

// ignoring field java.util.Formatter#lastException 

// ignoring field java.util.Formatter#zero 

// ignoring field java.util.Formatter#scaleUp 

// ignoring field java.util.Formatter#MAX_FD_CHARS 

// ignoring field java.util.Formatter#formatSpecifier 

// ignoring field java.util.Formatter#fsPattern 


    // ignoring method java.util.Formatter#init(java.lang.Appendable, java.util.Locale)
    // starting method java.util.Formatter#Formatter()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter()");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter()
    // starting method java.util.Formatter#Formatter(java.lang.Appendable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.Appendable)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.lang.Appendable)
    // starting method java.util.Formatter#Formatter(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.util.Locale)
    // starting method java.util.Formatter#Formatter(java.lang.Appendable, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.Appendable, java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.lang.Appendable, java.util.Locale)
    // starting method java.util.Formatter#Formatter(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.String)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
    
    // finishing method java.util.Formatter#Formatter(java.lang.String)
    // starting method java.util.Formatter#Formatter(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.String, java.lang.String)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.lang.String, java.lang.String)
    // starting method java.util.Formatter#Formatter(java.lang.String, java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.lang.String, java.lang.String, java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.lang.String, java.lang.String, java.util.Locale)
    // starting method java.util.Formatter#Formatter(java.io.File)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.File)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
    
    // finishing method java.util.Formatter#Formatter(java.io.File)
    // starting method java.util.Formatter#Formatter(java.io.File, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.File, java.lang.String)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.io.File, java.lang.String)
    // starting method java.util.Formatter#Formatter(java.io.File, java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.File, java.lang.String, java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.io.File, java.lang.String, java.util.Locale)
    // starting method java.util.Formatter#Formatter(java.io.PrintStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.PrintStream)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.io.PrintStream)
    // starting method java.util.Formatter#Formatter(java.io.OutputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.OutputStream)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#Formatter(java.io.OutputStream)
    // starting method java.util.Formatter#Formatter(java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.OutputStream, java.lang.String)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.io.OutputStream, java.lang.String)
    // starting method java.util.Formatter#Formatter(java.io.OutputStream, java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Formatter(java.io.OutputStream, java.lang.String, java.util.Locale)");
    method.setSimpleName("Formatter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","UnsupportedEncodingException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.UnsupportedEncodingException
    
    // finishing method java.util.Formatter#Formatter(java.io.OutputStream, java.lang.String, java.util.Locale)
    // ignoring method java.util.Formatter#setZero()
    // starting method java.util.Formatter#locale()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"locale()");
    method.setSimpleName("locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#locale()
    // starting method java.util.Formatter#out()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"out()");
    method.setSimpleName("out");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Appendable");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#out()
    // starting method java.util.Formatter#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#toString()
    // starting method java.util.Formatter#flush()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"flush()");
    method.setSimpleName("flush");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#flush()
    // starting method java.util.Formatter#close()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"close()");
    method.setSimpleName("close");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#close()
    // ignoring method java.util.Formatter#ensureOpen()
    // starting method java.util.Formatter#ioException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"ioException()");
    method.setSimpleName("ioException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#ioException()
    // starting method java.util.Formatter#format(java.lang.String, java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"format(java.lang.String, java.lang.Object[])");
    method.setSimpleName("format");
    helper.setMethodData(method,129);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#format(java.lang.String, java.lang.Object[])
    // starting method java.util.Formatter#format(java.util.Locale, java.lang.String, java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"format(java.util.Locale, java.lang.String, java.lang.Object[])");
    method.setSimpleName("format");
    helper.setMethodData(method,129);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Formatter");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#format(java.util.Locale, java.lang.String, java.lang.Object[])
    // ignoring method java.util.Formatter#parse(java.lang.String)
    // ignoring method java.util.Formatter#checkText(java.lang.String)
    // starting method java.util.Formatter#access$000(java.util.Formatter)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.Formatter)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Appendable");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#access$000(java.util.Formatter)
    // starting method java.util.Formatter#access$202(double)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$202(double)");
    method.setSimpleName("access$202");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#access$202(double)
    // starting method java.util.Formatter#access$200()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200()");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#access$200()
    // starting method java.util.Formatter#access$300(java.util.Formatter)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.util.Formatter)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "char");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Formatter#access$300(java.util.Formatter)

// finishing type java.util.Formatter
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "FormatterClosedException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","IllegalStateException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.FormatterClosedException#serialVersionUID 


    // starting method java.util.FormatterClosedException#FormatterClosedException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"FormatterClosedException()");
    method.setSimpleName("FormatterClosedException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.FormatterClosedException#FormatterClosedException()

// finishing type java.util.FormatterClosedException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "GregorianCalendar");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Calendar");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#BC
	field = newType.addNode(JavaDataField.class,"BC"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#BC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#BCE
	field = newType.addNode(JavaDataField.class,"BCE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#BCE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#AD
	field = newType.addNode(JavaDataField.class,"AD"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#AD

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#CE
	field = newType.addNode(JavaDataField.class,"CE"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#CE

// ignoring field java.util.GregorianCalendar#EPOCH_OFFSET 

// ignoring field java.util.GregorianCalendar#EPOCH_YEAR 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#MONTH_LENGTH
	field = newType.addNode(JavaDataField.class,"MONTH_LENGTH"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#MONTH_LENGTH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#LEAP_MONTH_LENGTH
	field = newType.addNode(JavaDataField.class,"LEAP_MONTH_LENGTH"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#LEAP_MONTH_LENGTH

// ignoring field java.util.GregorianCalendar#ONE_SECOND 

// ignoring field java.util.GregorianCalendar#ONE_MINUTE 

// ignoring field java.util.GregorianCalendar#ONE_HOUR 

// ignoring field java.util.GregorianCalendar#ONE_DAY 

// ignoring field java.util.GregorianCalendar#ONE_WEEK 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#MIN_VALUES
	field = newType.addNode(JavaDataField.class,"MIN_VALUES"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#MIN_VALUES

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#LEAST_MAX_VALUES
	field = newType.addNode(JavaDataField.class,"LEAST_MAX_VALUES"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#LEAST_MAX_VALUES

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#MAX_VALUES
	field = newType.addNode(JavaDataField.class,"MAX_VALUES"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#MAX_VALUES

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#serialVersionUID

// ignoring field java.util.GregorianCalendar#gcal 

// ignoring field java.util.GregorianCalendar#jcal 

// ignoring field java.util.GregorianCalendar#jeras 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#DEFAULT_GREGORIAN_CUTOVER
	field = newType.addNode(JavaDataField.class,"DEFAULT_GREGORIAN_CUTOVER"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#DEFAULT_GREGORIAN_CUTOVER

// ignoring field java.util.GregorianCalendar#gregorianCutover 

// ignoring field java.util.GregorianCalendar#gregorianCutoverDate 

// ignoring field java.util.GregorianCalendar#gregorianCutoverYear 

// ignoring field java.util.GregorianCalendar#gregorianCutoverYearJulian 

// ignoring field java.util.GregorianCalendar#gdate 

// ignoring field java.util.GregorianCalendar#cdate 

// ignoring field java.util.GregorianCalendar#calsys 

// ignoring field java.util.GregorianCalendar#zoneOffsets 

// ignoring field java.util.GregorianCalendar#originalFields 

// ignoring field java.util.GregorianCalendar#cachedFixedDate 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.GregorianCalendar#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.GregorianCalendar#$assertionsDisabled


    // starting method java.util.GregorianCalendar#GregorianCalendar()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar()");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar()
    // starting method java.util.GregorianCalendar#GregorianCalendar(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(java.util.TimeZone)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(java.util.TimeZone)
    // starting method java.util.GregorianCalendar#GregorianCalendar(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(java.util.Locale)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(java.util.Locale)
    // starting method java.util.GregorianCalendar#GregorianCalendar(java.util.TimeZone, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(java.util.TimeZone, java.util.Locale)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(java.util.TimeZone, java.util.Locale)
    // starting method java.util.GregorianCalendar#GregorianCalendar(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(int, int, int)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(int, int, int)
    // starting method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(int, int, int, int, int)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int)
    // starting method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(int, int, int, int, int, int)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int, int)
    // starting method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"GregorianCalendar(int, int, int, int, int, int, int)");
    method.setSimpleName("GregorianCalendar");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#GregorianCalendar(int, int, int, int, int, int, int)
    // starting method java.util.GregorianCalendar#setGregorianChange(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setGregorianChange(java.util.Date)");
    method.setSimpleName("setGregorianChange");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#setGregorianChange(java.util.Date)
    // ignoring method java.util.GregorianCalendar#setGregorianChange(long)
    // starting method java.util.GregorianCalendar#getGregorianChange()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getGregorianChange()");
    method.setSimpleName("getGregorianChange");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Date");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getGregorianChange()
    // starting method java.util.GregorianCalendar#isLeapYear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isLeapYear(int)");
    method.setSimpleName("isLeapYear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#isLeapYear(int)
    // starting method java.util.GregorianCalendar#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#equals(java.lang.Object)
    // starting method java.util.GregorianCalendar#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#hashCode()
    // starting method java.util.GregorianCalendar#add(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, int)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#add(int, int)
    // starting method java.util.GregorianCalendar#roll(int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"roll(int, boolean)");
    method.setSimpleName("roll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#roll(int, boolean)
    // starting method java.util.GregorianCalendar#roll(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"roll(int, int)");
    method.setSimpleName("roll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#roll(int, int)
    // starting method java.util.GregorianCalendar#getMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMinimum(int)");
    method.setSimpleName("getMinimum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getMinimum(int)
    // starting method java.util.GregorianCalendar#getMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMaximum(int)");
    method.setSimpleName("getMaximum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getMaximum(int)
    // starting method java.util.GregorianCalendar#getGreatestMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getGreatestMinimum(int)");
    method.setSimpleName("getGreatestMinimum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getGreatestMinimum(int)
    // starting method java.util.GregorianCalendar#getLeastMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLeastMaximum(int)");
    method.setSimpleName("getLeastMaximum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getLeastMaximum(int)
    // starting method java.util.GregorianCalendar#getActualMinimum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActualMinimum(int)");
    method.setSimpleName("getActualMinimum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getActualMinimum(int)
    // starting method java.util.GregorianCalendar#getActualMaximum(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActualMaximum(int)");
    method.setSimpleName("getActualMaximum");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getActualMaximum(int)
    // ignoring method java.util.GregorianCalendar#getYearOffsetInMillis()
    // starting method java.util.GregorianCalendar#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#clone()
    // starting method java.util.GregorianCalendar#getTimeZone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimeZone()");
    method.setSimpleName("getTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#getTimeZone()
    // starting method java.util.GregorianCalendar#setTimeZone(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setTimeZone(java.util.TimeZone)");
    method.setSimpleName("setTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#setTimeZone(java.util.TimeZone)
    // starting method java.util.GregorianCalendar#computeFields()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"computeFields()");
    method.setSimpleName("computeFields");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#computeFields()
    // ignoring method java.util.GregorianCalendar#computeFields(int, int)
    // ignoring method java.util.GregorianCalendar#getWeekNumber(long, long)
    // starting method java.util.GregorianCalendar#computeTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"computeTime()");
    method.setSimpleName("computeTime");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.GregorianCalendar#computeTime()
    // ignoring method java.util.GregorianCalendar#getFixedDate(sun.util.calendar.BaseCalendar, int, int)
    // ignoring method java.util.GregorianCalendar#getNormalizedCalendar()
    // ignoring method java.util.GregorianCalendar#getJulianCalendarSystem()
    // ignoring method java.util.GregorianCalendar#getCutoverCalendarSystem()
    // ignoring method java.util.GregorianCalendar#isCutoverYear(int)
    // ignoring method java.util.GregorianCalendar#getFixedDateJan1(sun.util.calendar.BaseCalendar$Date, long)
    // ignoring method java.util.GregorianCalendar#getFixedDateMonth1(sun.util.calendar.BaseCalendar$Date, long)
    // ignoring method java.util.GregorianCalendar#getCalendarDate(long)
    // ignoring method java.util.GregorianCalendar#getGregorianCutoverDate()
    // ignoring method java.util.GregorianCalendar#getLastJulianDate()
    // ignoring method java.util.GregorianCalendar#monthLength(int, int)
    // ignoring method java.util.GregorianCalendar#monthLength(int)
    // ignoring method java.util.GregorianCalendar#actualMonthLength()
    // ignoring method java.util.GregorianCalendar#yearLength(int)
    // ignoring method java.util.GregorianCalendar#yearLength()
    // ignoring method java.util.GregorianCalendar#pinDayOfMonth()
    // ignoring method java.util.GregorianCalendar#getCurrentFixedDate()
    // ignoring method java.util.GregorianCalendar#getRolledValue(int, int, int, int)
    // ignoring method java.util.GregorianCalendar#internalGetEra()
    // ignoring method java.util.GregorianCalendar#readObject(java.io.ObjectInputStream)

// finishing type java.util.GregorianCalendar
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.HashMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Entry#key
	field = newType.addNode(JavaDataField.class,"key"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Entry#key

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Entry#value
	field = newType.addNode(JavaDataField.class,"value"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Entry#value

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Entry#hash
	field = newType.addNode(JavaDataField.class,"hash"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Entry#hash

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Entry#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Entry#next


    // starting method java.util.HashMap$Entry#HashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)");
    method.setSimpleName("HashMap$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#HashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)
    // starting method java.util.HashMap$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#getKey()
    // starting method java.util.HashMap$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#getValue()
    // starting method java.util.HashMap$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#setValue(java.lang.Object)
    // starting method java.util.HashMap$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#equals(java.lang.Object)
    // starting method java.util.HashMap$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#hashCode()
    // starting method java.util.HashMap$Entry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#toString()
    // starting method java.util.HashMap$Entry#recordAccess(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"recordAccess(java.util.HashMap)");
    method.setSimpleName("recordAccess");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#recordAccess(java.util.HashMap)
    // starting method java.util.HashMap$Entry#recordRemoval(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"recordRemoval(java.util.HashMap)");
    method.setSimpleName("recordRemoval");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Entry#recordRemoval(java.util.HashMap)

// finishing type java.util.HashMap$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$EntryIterator#this$0


    // ignoring method java.util.HashMap$EntryIterator#HashMap$EntryIterator(java.util.HashMap)
    // starting method java.util.HashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntryIterator#next()
    // starting method java.util.HashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntryIterator#next()
    // starting method java.util.HashMap$EntryIterator#HashMap$EntryIterator(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$EntryIterator(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntryIterator#HashMap$EntryIterator(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$EntrySet#this$0


    // ignoring method java.util.HashMap$EntrySet#HashMap$EntrySet(java.util.HashMap)
    // starting method java.util.HashMap$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#iterator()
    // starting method java.util.HashMap$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#contains(java.lang.Object)
    // starting method java.util.HashMap$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#remove(java.lang.Object)
    // starting method java.util.HashMap$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#size()
    // starting method java.util.HashMap$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#clear()
    // starting method java.util.HashMap$EntrySet#HashMap$EntrySet(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$EntrySet(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$EntrySet#HashMap$EntrySet(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$HashIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#next

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#current
	field = newType.addNode(JavaDataField.class,"current"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#current

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$HashIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$HashIterator#this$0


    // starting method java.util.HashMap$HashIterator#HashMap$HashIterator(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$HashIterator(java.util.HashMap)");
    method.setSimpleName("HashMap$HashIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$HashIterator#HashMap$HashIterator(java.util.HashMap)
    // starting method java.util.HashMap$HashIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$HashIterator#hasNext()
    // starting method java.util.HashMap$HashIterator#nextEntry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextEntry()");
    method.setSimpleName("nextEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$HashIterator#nextEntry()
    // starting method java.util.HashMap$HashIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$HashIterator#remove()

// finishing type java.util.HashMap$HashIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$KeyIterator#this$0


    // ignoring method java.util.HashMap$KeyIterator#HashMap$KeyIterator(java.util.HashMap)
    // starting method java.util.HashMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeyIterator#next()
    // starting method java.util.HashMap$KeyIterator#HashMap$KeyIterator(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$KeyIterator(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeyIterator#HashMap$KeyIterator(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$KeySet#this$0


    // ignoring method java.util.HashMap$KeySet#HashMap$KeySet(java.util.HashMap)
    // starting method java.util.HashMap$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#iterator()
    // starting method java.util.HashMap$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#size()
    // starting method java.util.HashMap$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#contains(java.lang.Object)
    // starting method java.util.HashMap$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#remove(java.lang.Object)
    // starting method java.util.HashMap$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#clear()
    // starting method java.util.HashMap$KeySet#HashMap$KeySet(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$KeySet(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$KeySet#HashMap$KeySet(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$ValueIterator#this$0


    // ignoring method java.util.HashMap$ValueIterator#HashMap$ValueIterator(java.util.HashMap)
    // starting method java.util.HashMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$ValueIterator#next()
    // starting method java.util.HashMap$ValueIterator#HashMap$ValueIterator(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$ValueIterator(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$ValueIterator#HashMap$ValueIterator(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap$Values");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap$Values#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.HashMap$Values#this$0


    // ignoring method java.util.HashMap$Values#HashMap$Values(java.util.HashMap)
    // starting method java.util.HashMap$Values#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#iterator()
    // starting method java.util.HashMap$Values#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#size()
    // starting method java.util.HashMap$Values#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#contains(java.lang.Object)
    // starting method java.util.HashMap$Values#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#clear()
    // starting method java.util.HashMap$Values#HashMap$Values(java.util.HashMap, java.util.HashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap$Values(java.util.HashMap, java.util.HashMap$1)");
    method.setSimpleName("HashMap$Values");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap$Values#HashMap$Values(java.util.HashMap, java.util.HashMap$1)

// finishing type java.util.HashMap$Values
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#DEFAULT_INITIAL_CAPACITY
	field = newType.addNode(JavaDataField.class,"DEFAULT_INITIAL_CAPACITY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashMap#DEFAULT_INITIAL_CAPACITY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#MAXIMUM_CAPACITY
	field = newType.addNode(JavaDataField.class,"MAXIMUM_CAPACITY"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashMap#MAXIMUM_CAPACITY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#DEFAULT_LOAD_FACTOR
	field = newType.addNode(JavaDataField.class,"DEFAULT_LOAD_FACTOR"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","float");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashMap#DEFAULT_LOAD_FACTOR

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#table
	field = newType.addNode(JavaDataField.class,"table"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 128, isArray, arrayDimensions);
    // finishing field java.util.HashMap#table

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#size
	field = newType.addNode(JavaDataField.class,"size"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 128, isArray, arrayDimensions);
    // finishing field java.util.HashMap#size

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#threshold
	field = newType.addNode(JavaDataField.class,"threshold"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.HashMap#threshold

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#loadFactor
	field = newType.addNode(JavaDataField.class,"loadFactor"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","float");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.HashMap#loadFactor

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#modCount
	field = newType.addNode(JavaDataField.class,"modCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 192, isArray, arrayDimensions);
    // finishing field java.util.HashMap#modCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashMap#NULL_KEY
	field = newType.addNode(JavaDataField.class,"NULL_KEY"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashMap#NULL_KEY

// ignoring field java.util.HashMap#useNewHash 

// ignoring field java.util.HashMap#entrySet 

// ignoring field java.util.HashMap#serialVersionUID 


    // starting method java.util.HashMap#HashMap(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap(int, float)");
    method.setSimpleName("HashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#HashMap(int, float)
    // starting method java.util.HashMap#HashMap(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap(int)");
    method.setSimpleName("HashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#HashMap(int)
    // starting method java.util.HashMap#HashMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap()");
    method.setSimpleName("HashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#HashMap()
    // starting method java.util.HashMap#HashMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashMap(java.util.Map)");
    method.setSimpleName("HashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#HashMap(java.util.Map)
    // starting method java.util.HashMap#init()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"init()");
    method.setSimpleName("init");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#init()
    // starting method java.util.HashMap#maskNull(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"maskNull(java.lang.Object)");
    method.setSimpleName("maskNull");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#maskNull(java.lang.Object)
    // starting method java.util.HashMap#unmaskNull(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"unmaskNull(java.lang.Object)");
    method.setSimpleName("unmaskNull");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#unmaskNull(java.lang.Object)
    // ignoring method java.util.HashMap#oldHash(int)
    // ignoring method java.util.HashMap#newHash(int)
    // starting method java.util.HashMap#hash(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hash(int)");
    method.setSimpleName("hash");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#hash(int)
    // starting method java.util.HashMap#hash(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hash(java.lang.Object)");
    method.setSimpleName("hash");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#hash(java.lang.Object)
    // starting method java.util.HashMap#eq(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"eq(java.lang.Object, java.lang.Object)");
    method.setSimpleName("eq");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#eq(java.lang.Object, java.lang.Object)
    // starting method java.util.HashMap#indexFor(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexFor(int, int)");
    method.setSimpleName("indexFor");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#indexFor(int, int)
    // starting method java.util.HashMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#size()
    // starting method java.util.HashMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#isEmpty()
    // starting method java.util.HashMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#get(java.lang.Object)
    // ignoring method java.util.HashMap#getForNullKey()
    // starting method java.util.HashMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#containsKey(java.lang.Object)
    // starting method java.util.HashMap#getEntry(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getEntry(java.lang.Object)");
    method.setSimpleName("getEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#getEntry(java.lang.Object)
    // starting method java.util.HashMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#put(java.lang.Object, java.lang.Object)
    // ignoring method java.util.HashMap#putForNullKey(java.lang.Object)
    // ignoring method java.util.HashMap#putForCreate(java.lang.Object, java.lang.Object)
    // starting method java.util.HashMap#putAllForCreate(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAllForCreate(java.util.Map)");
    method.setSimpleName("putAllForCreate");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#putAllForCreate(java.util.Map)
    // starting method java.util.HashMap#resize(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"resize(int)");
    method.setSimpleName("resize");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#resize(int)
    // starting method java.util.HashMap#transfer(java.util.HashMap$Entry[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"transfer(java.util.HashMap$Entry[])");
    method.setSimpleName("transfer");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#transfer(java.util.HashMap$Entry[])
    // starting method java.util.HashMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#putAll(java.util.Map)
    // starting method java.util.HashMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#remove(java.lang.Object)
    // starting method java.util.HashMap#removeEntryForKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeEntryForKey(java.lang.Object)");
    method.setSimpleName("removeEntryForKey");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#removeEntryForKey(java.lang.Object)
    // starting method java.util.HashMap#removeMapping(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeMapping(java.lang.Object)");
    method.setSimpleName("removeMapping");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","HashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#removeMapping(java.lang.Object)
    // starting method java.util.HashMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#clear()
    // starting method java.util.HashMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#containsValue(java.lang.Object)
    // ignoring method java.util.HashMap#containsNullValue()
    // starting method java.util.HashMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#clone()
    // starting method java.util.HashMap#addEntry(int, java.lang.Object, java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addEntry(int, java.lang.Object, java.lang.Object, int)");
    method.setSimpleName("addEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#addEntry(int, java.lang.Object, java.lang.Object, int)
    // starting method java.util.HashMap#createEntry(int, java.lang.Object, java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"createEntry(int, java.lang.Object, java.lang.Object, int)");
    method.setSimpleName("createEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#createEntry(int, java.lang.Object, java.lang.Object, int)
    // starting method java.util.HashMap#newKeyIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newKeyIterator()");
    method.setSimpleName("newKeyIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#newKeyIterator()
    // starting method java.util.HashMap#newValueIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newValueIterator()");
    method.setSimpleName("newValueIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#newValueIterator()
    // starting method java.util.HashMap#newEntryIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newEntryIterator()");
    method.setSimpleName("newEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#newEntryIterator()
    // starting method java.util.HashMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#keySet()
    // starting method java.util.HashMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#values()
    // starting method java.util.HashMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#entrySet()
    // ignoring method java.util.HashMap#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.HashMap#readObject(java.io.ObjectInputStream)
    // starting method java.util.HashMap#capacity()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"capacity()");
    method.setSimpleName("capacity");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#capacity()
    // starting method java.util.HashMap#loadFactor()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"loadFactor()");
    method.setSimpleName("loadFactor");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "float");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashMap#loadFactor()

// finishing type java.util.HashMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "HashSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.HashSet#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.HashSet#serialVersionUID

// ignoring field java.util.HashSet#map 

// ignoring field java.util.HashSet#PRESENT 


    // starting method java.util.HashSet#HashSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet()");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet()
    // starting method java.util.HashSet#HashSet(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet(java.util.Collection)");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet(java.util.Collection)
    // starting method java.util.HashSet#HashSet(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet(int, float)");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet(int, float)
    // starting method java.util.HashSet#HashSet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet(int)");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet(int)
    // starting method java.util.HashSet#HashSet(int, float, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"HashSet(int, float, boolean)");
    method.setSimpleName("HashSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#HashSet(int, float, boolean)
    // starting method java.util.HashSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#iterator()
    // starting method java.util.HashSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#size()
    // starting method java.util.HashSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#isEmpty()
    // starting method java.util.HashSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#contains(java.lang.Object)
    // starting method java.util.HashSet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#add(java.lang.Object)
    // starting method java.util.HashSet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#remove(java.lang.Object)
    // starting method java.util.HashSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#clear()
    // starting method java.util.HashSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.HashSet#clone()
    // ignoring method java.util.HashSet#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.HashSet#readObject(java.io.ObjectInputStream)

// finishing type java.util.HashSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.Hashtable$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EmptyEnumerator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 


    // starting method java.util.Hashtable$EmptyEnumerator#Hashtable$EmptyEnumerator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$EmptyEnumerator()");
    method.setSimpleName("Hashtable$EmptyEnumerator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyEnumerator#Hashtable$EmptyEnumerator()
    // starting method java.util.Hashtable$EmptyEnumerator#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyEnumerator#hasMoreElements()
    // starting method java.util.Hashtable$EmptyEnumerator#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyEnumerator#nextElement()

// finishing type java.util.Hashtable$EmptyEnumerator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EmptyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 


    // starting method java.util.Hashtable$EmptyIterator#Hashtable$EmptyIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$EmptyIterator()");
    method.setSimpleName("Hashtable$EmptyIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyIterator#Hashtable$EmptyIterator()
    // starting method java.util.Hashtable$EmptyIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyIterator#hasNext()
    // starting method java.util.Hashtable$EmptyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyIterator#next()
    // starting method java.util.Hashtable$EmptyIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EmptyIterator#remove()

// finishing type java.util.Hashtable$EmptyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Entry#hash
	field = newType.addNode(JavaDataField.class,"hash"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Entry#hash

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Entry#key
	field = newType.addNode(JavaDataField.class,"key"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Entry#key

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Entry#value
	field = newType.addNode(JavaDataField.class,"value"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Entry#value

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Entry#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Entry#next


    // starting method java.util.Hashtable$Entry#Hashtable$Entry(int, java.lang.Object, java.lang.Object, java.util.Hashtable$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$Entry(int, java.lang.Object, java.lang.Object, java.util.Hashtable$Entry)");
    method.setSimpleName("Hashtable$Entry");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#Hashtable$Entry(int, java.lang.Object, java.lang.Object, java.util.Hashtable$Entry)
    // starting method java.util.Hashtable$Entry#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#clone()
    // starting method java.util.Hashtable$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#getKey()
    // starting method java.util.Hashtable$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#getValue()
    // starting method java.util.Hashtable$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#setValue(java.lang.Object)
    // starting method java.util.Hashtable$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#equals(java.lang.Object)
    // starting method java.util.Hashtable$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#hashCode()
    // starting method java.util.Hashtable$Entry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Entry#toString()

// finishing type java.util.Hashtable$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$EntrySet#this$0


    // ignoring method java.util.Hashtable$EntrySet#Hashtable$EntrySet(java.util.Hashtable)
    // starting method java.util.Hashtable$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#iterator()
    // starting method java.util.Hashtable$EntrySet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#add(java.lang.Object)
    // starting method java.util.Hashtable$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#contains(java.lang.Object)
    // starting method java.util.Hashtable$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#remove(java.lang.Object)
    // starting method java.util.Hashtable$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#size()
    // starting method java.util.Hashtable$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#clear()
    // starting method java.util.Hashtable$EntrySet#Hashtable$EntrySet(java.util.Hashtable, java.util.Hashtable$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$EntrySet(java.util.Hashtable, java.util.Hashtable$1)");
    method.setSimpleName("Hashtable$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$EntrySet#Hashtable$EntrySet(java.util.Hashtable, java.util.Hashtable$1)

// finishing type java.util.Hashtable$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$Enumerator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#table
	field = newType.addNode(JavaDataField.class,"table"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#table

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#entry
	field = newType.addNode(JavaDataField.class,"entry"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#entry

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#type
	field = newType.addNode(JavaDataField.class,"type"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#type

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#iterator
	field = newType.addNode(JavaDataField.class,"iterator"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#iterator

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$Enumerator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$Enumerator#this$0


    // starting method java.util.Hashtable$Enumerator#Hashtable$Enumerator(java.util.Hashtable, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$Enumerator(java.util.Hashtable, int, boolean)");
    method.setSimpleName("Hashtable$Enumerator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#Hashtable$Enumerator(java.util.Hashtable, int, boolean)
    // starting method java.util.Hashtable$Enumerator#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#hasMoreElements()
    // starting method java.util.Hashtable$Enumerator#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#nextElement()
    // starting method java.util.Hashtable$Enumerator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#hasNext()
    // starting method java.util.Hashtable$Enumerator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#next()
    // starting method java.util.Hashtable$Enumerator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$Enumerator#remove()

// finishing type java.util.Hashtable$Enumerator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$KeySet#this$0


    // ignoring method java.util.Hashtable$KeySet#Hashtable$KeySet(java.util.Hashtable)
    // starting method java.util.Hashtable$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#iterator()
    // starting method java.util.Hashtable$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#size()
    // starting method java.util.Hashtable$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#contains(java.lang.Object)
    // starting method java.util.Hashtable$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#remove(java.lang.Object)
    // starting method java.util.Hashtable$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#clear()
    // starting method java.util.Hashtable$KeySet#Hashtable$KeySet(java.util.Hashtable, java.util.Hashtable$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$KeySet(java.util.Hashtable, java.util.Hashtable$1)");
    method.setSimpleName("Hashtable$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$KeySet#Hashtable$KeySet(java.util.Hashtable, java.util.Hashtable$1)

// finishing type java.util.Hashtable$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable$ValueCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Hashtable$ValueCollection#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Hashtable");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Hashtable$ValueCollection#this$0


    // ignoring method java.util.Hashtable$ValueCollection#Hashtable$ValueCollection(java.util.Hashtable)
    // starting method java.util.Hashtable$ValueCollection#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#iterator()
    // starting method java.util.Hashtable$ValueCollection#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#size()
    // starting method java.util.Hashtable$ValueCollection#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#contains(java.lang.Object)
    // starting method java.util.Hashtable$ValueCollection#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#clear()
    // starting method java.util.Hashtable$ValueCollection#Hashtable$ValueCollection(java.util.Hashtable, java.util.Hashtable$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable$ValueCollection(java.util.Hashtable, java.util.Hashtable$1)");
    method.setSimpleName("Hashtable$ValueCollection");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable$ValueCollection#Hashtable$ValueCollection(java.util.Hashtable, java.util.Hashtable$1)

// finishing type java.util.Hashtable$ValueCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Hashtable");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Dictionary");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.Hashtable#table 

// ignoring field java.util.Hashtable#count 

// ignoring field java.util.Hashtable#threshold 

// ignoring field java.util.Hashtable#loadFactor 

// ignoring field java.util.Hashtable#modCount 

// ignoring field java.util.Hashtable#serialVersionUID 

// ignoring field java.util.Hashtable#keySet 

// ignoring field java.util.Hashtable#entrySet 

// ignoring field java.util.Hashtable#values 

// ignoring field java.util.Hashtable#KEYS 

// ignoring field java.util.Hashtable#VALUES 

// ignoring field java.util.Hashtable#ENTRIES 

// ignoring field java.util.Hashtable#emptyEnumerator 

// ignoring field java.util.Hashtable#emptyIterator 


    // starting method java.util.Hashtable#Hashtable(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable(int, float)");
    method.setSimpleName("Hashtable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#Hashtable(int, float)
    // starting method java.util.Hashtable#Hashtable(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable(int)");
    method.setSimpleName("Hashtable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#Hashtable(int)
    // starting method java.util.Hashtable#Hashtable()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable()");
    method.setSimpleName("Hashtable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#Hashtable()
    // starting method java.util.Hashtable#Hashtable(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Hashtable(java.util.Map)");
    method.setSimpleName("Hashtable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#Hashtable(java.util.Map)
    // starting method java.util.Hashtable#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#size()
    // starting method java.util.Hashtable#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#isEmpty()
    // starting method java.util.Hashtable#keys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keys()");
    method.setSimpleName("keys");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#keys()
    // starting method java.util.Hashtable#elements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elements()");
    method.setSimpleName("elements");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#elements()
    // starting method java.util.Hashtable#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#contains(java.lang.Object)
    // starting method java.util.Hashtable#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#containsValue(java.lang.Object)
    // starting method java.util.Hashtable#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#containsKey(java.lang.Object)
    // starting method java.util.Hashtable#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#get(java.lang.Object)
    // starting method java.util.Hashtable#rehash()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"rehash()");
    method.setSimpleName("rehash");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#rehash()
    // starting method java.util.Hashtable#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Hashtable#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#remove(java.lang.Object)
    // starting method java.util.Hashtable#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#putAll(java.util.Map)
    // starting method java.util.Hashtable#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#clear()
    // starting method java.util.Hashtable#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#clone()
    // starting method java.util.Hashtable#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#toString()
    // ignoring method java.util.Hashtable#getEnumeration(int)
    // ignoring method java.util.Hashtable#getIterator(int)
    // starting method java.util.Hashtable#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#keySet()
    // starting method java.util.Hashtable#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#entrySet()
    // starting method java.util.Hashtable#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#values()
    // starting method java.util.Hashtable#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#equals(java.lang.Object)
    // starting method java.util.Hashtable#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#hashCode()
    // ignoring method java.util.Hashtable#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.Hashtable#readObject(java.io.ObjectInputStream)
    // ignoring method java.util.Hashtable#reconstitutionPut(java.util.Hashtable$Entry[], java.lang.Object, java.lang.Object)
    // starting method java.util.Hashtable#access$100(java.util.Hashtable, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.Hashtable, int)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$100(java.util.Hashtable, int)
    // starting method java.util.Hashtable#access$200(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.Hashtable)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$200(java.util.Hashtable)
    // starting method java.util.Hashtable#access$400(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.Hashtable)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$400(java.util.Hashtable)
    // starting method java.util.Hashtable#access$508(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$508(java.util.Hashtable)");
    method.setSimpleName("access$508");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$508(java.util.Hashtable)
    // starting method java.util.Hashtable#access$210(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$210(java.util.Hashtable)");
    method.setSimpleName("access$210");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$210(java.util.Hashtable)
    // starting method java.util.Hashtable#access$500(java.util.Hashtable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$500(java.util.Hashtable)");
    method.setSimpleName("access$500");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Hashtable#access$500(java.util.Hashtable)

// finishing type java.util.Hashtable
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.IdentityHashMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IdentityHashMap$IdentityHashMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$EntryIterator#this$0


    // ignoring method java.util.IdentityHashMap$EntryIterator#IdentityHashMap$EntryIterator(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#next()
    // starting method java.util.IdentityHashMap$EntryIterator#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#getKey()
    // starting method java.util.IdentityHashMap$EntryIterator#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#getValue()
    // starting method java.util.IdentityHashMap$EntryIterator#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#setValue(java.lang.Object)
    // starting method java.util.IdentityHashMap$EntryIterator#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#equals(java.lang.Object)
    // starting method java.util.IdentityHashMap$EntryIterator#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#hashCode()
    // starting method java.util.IdentityHashMap$EntryIterator#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#toString()
    // starting method java.util.IdentityHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#next()
    // starting method java.util.IdentityHashMap$EntryIterator#IdentityHashMap$EntryIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$EntryIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntryIterator#IdentityHashMap$EntryIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$EntrySet#this$0


    // ignoring method java.util.IdentityHashMap$EntrySet#IdentityHashMap$EntrySet(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#iterator()
    // starting method java.util.IdentityHashMap$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#contains(java.lang.Object)
    // starting method java.util.IdentityHashMap$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#remove(java.lang.Object)
    // starting method java.util.IdentityHashMap$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#size()
    // starting method java.util.IdentityHashMap$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#clear()
    // starting method java.util.IdentityHashMap$EntrySet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#removeAll(java.util.Collection)
    // starting method java.util.IdentityHashMap$EntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#toArray()
    // starting method java.util.IdentityHashMap$EntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#toArray(java.lang.Object[])
    // starting method java.util.IdentityHashMap$EntrySet#IdentityHashMap$EntrySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$EntrySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$EntrySet#IdentityHashMap$EntrySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$IdentityHashMapIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#lastReturnedIndex
	field = newType.addNode(JavaDataField.class,"lastReturnedIndex"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#lastReturnedIndex

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#indexValid
	field = newType.addNode(JavaDataField.class,"indexValid"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#indexValid

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#traversalTable
	field = newType.addNode(JavaDataField.class,"traversalTable"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#traversalTable

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$IdentityHashMapIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$IdentityHashMapIterator#this$0


    // ignoring method java.util.IdentityHashMap$IdentityHashMapIterator#IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$IdentityHashMapIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$IdentityHashMapIterator#hasNext()
    // starting method java.util.IdentityHashMap$IdentityHashMapIterator#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$IdentityHashMapIterator#nextIndex()
    // starting method java.util.IdentityHashMap$IdentityHashMapIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$IdentityHashMapIterator#remove()
    // starting method java.util.IdentityHashMap$IdentityHashMapIterator#IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$IdentityHashMapIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$IdentityHashMapIterator#IdentityHashMap$IdentityHashMapIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$IdentityHashMapIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IdentityHashMap$IdentityHashMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$KeyIterator#this$0


    // ignoring method java.util.IdentityHashMap$KeyIterator#IdentityHashMap$KeyIterator(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeyIterator#next()
    // starting method java.util.IdentityHashMap$KeyIterator#IdentityHashMap$KeyIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$KeyIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeyIterator#IdentityHashMap$KeyIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$KeySet#this$0


    // ignoring method java.util.IdentityHashMap$KeySet#IdentityHashMap$KeySet(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#iterator()
    // starting method java.util.IdentityHashMap$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#size()
    // starting method java.util.IdentityHashMap$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#contains(java.lang.Object)
    // starting method java.util.IdentityHashMap$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#remove(java.lang.Object)
    // starting method java.util.IdentityHashMap$KeySet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#removeAll(java.util.Collection)
    // starting method java.util.IdentityHashMap$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#clear()
    // starting method java.util.IdentityHashMap$KeySet#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#hashCode()
    // starting method java.util.IdentityHashMap$KeySet#IdentityHashMap$KeySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$KeySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$KeySet#IdentityHashMap$KeySet(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IdentityHashMap$IdentityHashMapIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$ValueIterator#this$0


    // ignoring method java.util.IdentityHashMap$ValueIterator#IdentityHashMap$ValueIterator(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$ValueIterator#next()
    // starting method java.util.IdentityHashMap$ValueIterator#IdentityHashMap$ValueIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$ValueIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$ValueIterator#IdentityHashMap$ValueIterator(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap$Values");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.IdentityHashMap$Values#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","IdentityHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.IdentityHashMap$Values#this$0


    // ignoring method java.util.IdentityHashMap$Values#IdentityHashMap$Values(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap$Values#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#iterator()
    // starting method java.util.IdentityHashMap$Values#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#size()
    // starting method java.util.IdentityHashMap$Values#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#contains(java.lang.Object)
    // starting method java.util.IdentityHashMap$Values#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#remove(java.lang.Object)
    // starting method java.util.IdentityHashMap$Values#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#clear()
    // starting method java.util.IdentityHashMap$Values#IdentityHashMap$Values(java.util.IdentityHashMap, java.util.IdentityHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap$Values(java.util.IdentityHashMap, java.util.IdentityHashMap$1)");
    method.setSimpleName("IdentityHashMap$Values");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap$Values#IdentityHashMap$Values(java.util.IdentityHashMap, java.util.IdentityHashMap$1)

// finishing type java.util.IdentityHashMap$Values
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IdentityHashMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 

// ignoring field java.util.IdentityHashMap#DEFAULT_CAPACITY 

// ignoring field java.util.IdentityHashMap#MINIMUM_CAPACITY 

// ignoring field java.util.IdentityHashMap#MAXIMUM_CAPACITY 

// ignoring field java.util.IdentityHashMap#table 

// ignoring field java.util.IdentityHashMap#size 

// ignoring field java.util.IdentityHashMap#modCount 

// ignoring field java.util.IdentityHashMap#threshold 

// ignoring field java.util.IdentityHashMap#NULL_KEY 

// ignoring field java.util.IdentityHashMap#entrySet 

// ignoring field java.util.IdentityHashMap#serialVersionUID 


    // ignoring method java.util.IdentityHashMap#maskNull(java.lang.Object)
    // ignoring method java.util.IdentityHashMap#unmaskNull(java.lang.Object)
    // starting method java.util.IdentityHashMap#IdentityHashMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap()");
    method.setSimpleName("IdentityHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#IdentityHashMap()
    // starting method java.util.IdentityHashMap#IdentityHashMap(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap(int)");
    method.setSimpleName("IdentityHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#IdentityHashMap(int)
    // ignoring method java.util.IdentityHashMap#capacity(int)
    // ignoring method java.util.IdentityHashMap#init(int)
    // starting method java.util.IdentityHashMap#IdentityHashMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IdentityHashMap(java.util.Map)");
    method.setSimpleName("IdentityHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#IdentityHashMap(java.util.Map)
    // starting method java.util.IdentityHashMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#size()
    // starting method java.util.IdentityHashMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#isEmpty()
    // ignoring method java.util.IdentityHashMap#hash(java.lang.Object, int)
    // ignoring method java.util.IdentityHashMap#nextKeyIndex(int, int)
    // starting method java.util.IdentityHashMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#get(java.lang.Object)
    // starting method java.util.IdentityHashMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#containsKey(java.lang.Object)
    // starting method java.util.IdentityHashMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#containsValue(java.lang.Object)
    // ignoring method java.util.IdentityHashMap#containsMapping(java.lang.Object, java.lang.Object)
    // starting method java.util.IdentityHashMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#put(java.lang.Object, java.lang.Object)
    // ignoring method java.util.IdentityHashMap#resize(int)
    // starting method java.util.IdentityHashMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#putAll(java.util.Map)
    // starting method java.util.IdentityHashMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#remove(java.lang.Object)
    // ignoring method java.util.IdentityHashMap#removeMapping(java.lang.Object, java.lang.Object)
    // ignoring method java.util.IdentityHashMap#closeDeletion(int)
    // starting method java.util.IdentityHashMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#clear()
    // starting method java.util.IdentityHashMap#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#equals(java.lang.Object)
    // starting method java.util.IdentityHashMap#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#hashCode()
    // starting method java.util.IdentityHashMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#clone()
    // starting method java.util.IdentityHashMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#keySet()
    // starting method java.util.IdentityHashMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#values()
    // starting method java.util.IdentityHashMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#entrySet()
    // ignoring method java.util.IdentityHashMap#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.IdentityHashMap#readObject(java.io.ObjectInputStream)
    // ignoring method java.util.IdentityHashMap#putForCreate(java.lang.Object, java.lang.Object)
    // starting method java.util.IdentityHashMap#access$000(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.IdentityHashMap)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$000(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$100(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.IdentityHashMap)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$100(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$200(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.IdentityHashMap)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$200(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$204(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$204(java.util.IdentityHashMap)");
    method.setSimpleName("access$204");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$204(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$010(java.util.IdentityHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$010(java.util.IdentityHashMap)");
    method.setSimpleName("access$010");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$010(java.util.IdentityHashMap)
    // starting method java.util.IdentityHashMap#access$300(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(int, int)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$300(int, int)
    // starting method java.util.IdentityHashMap#access$400(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.lang.Object, int)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$400(java.lang.Object, int)
    // starting method java.util.IdentityHashMap#access$600(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$600(java.lang.Object)");
    method.setSimpleName("access$600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$600(java.lang.Object)
    // starting method java.util.IdentityHashMap#access$1300(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1300(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$1300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$1300(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)
    // starting method java.util.IdentityHashMap#access$1400(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1400(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$1400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IdentityHashMap#access$1400(java.util.IdentityHashMap, java.lang.Object, java.lang.Object)

// finishing type java.util.IdentityHashMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatCodePointException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatCodePointException#serialVersionUID 

// ignoring field java.util.IllegalFormatCodePointException#c 


    // starting method java.util.IllegalFormatCodePointException#IllegalFormatCodePointException(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatCodePointException(int)");
    method.setSimpleName("IllegalFormatCodePointException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatCodePointException#IllegalFormatCodePointException(int)
    // starting method java.util.IllegalFormatCodePointException#getCodePoint()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getCodePoint()");
    method.setSimpleName("getCodePoint");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatCodePointException#getCodePoint()
    // starting method java.util.IllegalFormatCodePointException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatCodePointException#getMessage()

// finishing type java.util.IllegalFormatCodePointException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatConversionException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatConversionException#serialVersionUID 

// ignoring field java.util.IllegalFormatConversionException#c 

// ignoring field java.util.IllegalFormatConversionException#arg 


    // starting method java.util.IllegalFormatConversionException#IllegalFormatConversionException(char, java.lang.Class)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatConversionException(char, java.lang.Class)");
    method.setSimpleName("IllegalFormatConversionException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatConversionException#IllegalFormatConversionException(char, java.lang.Class)
    // starting method java.util.IllegalFormatConversionException#getConversion()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getConversion()");
    method.setSimpleName("getConversion");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "char");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatConversionException#getConversion()
    // starting method java.util.IllegalFormatConversionException#getArgumentClass()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getArgumentClass()");
    method.setSimpleName("getArgumentClass");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Class");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatConversionException#getArgumentClass()
    // starting method java.util.IllegalFormatConversionException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatConversionException#getMessage()

// finishing type java.util.IllegalFormatConversionException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","IllegalArgumentException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatException#serialVersionUID 


    // starting method java.util.IllegalFormatException#IllegalFormatException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatException()");
    method.setSimpleName("IllegalFormatException");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatException#IllegalFormatException()

// finishing type java.util.IllegalFormatException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatFlagsException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatFlagsException#serialVersionUID 

// ignoring field java.util.IllegalFormatFlagsException#flags 


    // starting method java.util.IllegalFormatFlagsException#IllegalFormatFlagsException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatFlagsException(java.lang.String)");
    method.setSimpleName("IllegalFormatFlagsException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatFlagsException#IllegalFormatFlagsException(java.lang.String)
    // starting method java.util.IllegalFormatFlagsException#getFlags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFlags()");
    method.setSimpleName("getFlags");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatFlagsException#getFlags()
    // starting method java.util.IllegalFormatFlagsException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatFlagsException#getMessage()

// finishing type java.util.IllegalFormatFlagsException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatPrecisionException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatPrecisionException#serialVersionUID 

// ignoring field java.util.IllegalFormatPrecisionException#p 


    // starting method java.util.IllegalFormatPrecisionException#IllegalFormatPrecisionException(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatPrecisionException(int)");
    method.setSimpleName("IllegalFormatPrecisionException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatPrecisionException#IllegalFormatPrecisionException(int)
    // starting method java.util.IllegalFormatPrecisionException#getPrecision()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getPrecision()");
    method.setSimpleName("getPrecision");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatPrecisionException#getPrecision()
    // starting method java.util.IllegalFormatPrecisionException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatPrecisionException#getMessage()

// finishing type java.util.IllegalFormatPrecisionException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "IllegalFormatWidthException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.IllegalFormatWidthException#serialVersionUID 

// ignoring field java.util.IllegalFormatWidthException#w 


    // starting method java.util.IllegalFormatWidthException#IllegalFormatWidthException(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"IllegalFormatWidthException(int)");
    method.setSimpleName("IllegalFormatWidthException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatWidthException#IllegalFormatWidthException(int)
    // starting method java.util.IllegalFormatWidthException#getWidth()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getWidth()");
    method.setSimpleName("getWidth");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatWidthException#getWidth()
    // starting method java.util.IllegalFormatWidthException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.IllegalFormatWidthException#getMessage()

// finishing type java.util.IllegalFormatWidthException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "InputMismatchException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","NoSuchElementException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.InputMismatchException#InputMismatchException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"InputMismatchException()");
    method.setSimpleName("InputMismatchException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.InputMismatchException#InputMismatchException()
    // starting method java.util.InputMismatchException#InputMismatchException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"InputMismatchException(java.lang.String)");
    method.setSimpleName("InputMismatchException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.InputMismatchException#InputMismatchException(java.lang.String)

// finishing type java.util.InputMismatchException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "InvalidPropertiesFormatException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","IOException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.InvalidPropertiesFormatException#InvalidPropertiesFormatException(java.lang.Throwable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"InvalidPropertiesFormatException(java.lang.Throwable)");
    method.setSimpleName("InvalidPropertiesFormatException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.InvalidPropertiesFormatException#InvalidPropertiesFormatException(java.lang.Throwable)
    // starting method java.util.InvalidPropertiesFormatException#InvalidPropertiesFormatException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"InvalidPropertiesFormatException(java.lang.String)");
    method.setSimpleName("InvalidPropertiesFormatException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.InvalidPropertiesFormatException#InvalidPropertiesFormatException(java.lang.String)
    // ignoring method java.util.InvalidPropertiesFormatException#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.InvalidPropertiesFormatException#readObject(java.io.ObjectInputStream)

// finishing type java.util.InvalidPropertiesFormatException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Iterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Iterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Iterator#hasNext()
    // starting method java.util.Iterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Iterator#next()
    // starting method java.util.Iterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Iterator#remove()

// finishing type java.util.Iterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "JumboEnumSet$EnumSetIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#unseen
	field = newType.addNode(JavaDataField.class,"unseen"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#unseen

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#unseenIndex
	field = newType.addNode(JavaDataField.class,"unseenIndex"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#unseenIndex

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#lastReturnedIndex
	field = newType.addNode(JavaDataField.class,"lastReturnedIndex"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#lastReturnedIndex

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.JumboEnumSet$EnumSetIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","JumboEnumSet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.JumboEnumSet$EnumSetIterator#this$0


    // starting method java.util.JumboEnumSet$EnumSetIterator#JumboEnumSet$EnumSetIterator(java.util.JumboEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"JumboEnumSet$EnumSetIterator(java.util.JumboEnumSet)");
    method.setSimpleName("JumboEnumSet$EnumSetIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#JumboEnumSet$EnumSetIterator(java.util.JumboEnumSet)
    // starting method java.util.JumboEnumSet$EnumSetIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#hasNext()
    // starting method java.util.JumboEnumSet$EnumSetIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Enum");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#next()
    // starting method java.util.JumboEnumSet$EnumSetIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#remove()
    // starting method java.util.JumboEnumSet$EnumSetIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet$EnumSetIterator#next()

// finishing type java.util.JumboEnumSet$EnumSetIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "JumboEnumSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.JumboEnumSet#elements 

// ignoring field java.util.JumboEnumSet#size 


    // starting method java.util.JumboEnumSet#JumboEnumSet(java.lang.Class, java.lang.Enum[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"JumboEnumSet(java.lang.Class, java.lang.Enum[])");
    method.setSimpleName("JumboEnumSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#JumboEnumSet(java.lang.Class, java.lang.Enum[])
    // starting method java.util.JumboEnumSet#addRange(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addRange(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("addRange");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#addRange(java.lang.Enum, java.lang.Enum)
    // starting method java.util.JumboEnumSet#addAll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll()");
    method.setSimpleName("addAll");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#addAll()
    // starting method java.util.JumboEnumSet#complement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complement()");
    method.setSimpleName("complement");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#complement()
    // starting method java.util.JumboEnumSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#iterator()
    // starting method java.util.JumboEnumSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#size()
    // starting method java.util.JumboEnumSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#isEmpty()
    // starting method java.util.JumboEnumSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#contains(java.lang.Object)
    // starting method java.util.JumboEnumSet#add(java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Enum)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#add(java.lang.Enum)
    // starting method java.util.JumboEnumSet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#remove(java.lang.Object)
    // starting method java.util.JumboEnumSet#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#containsAll(java.util.Collection)
    // starting method java.util.JumboEnumSet#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#addAll(java.util.Collection)
    // starting method java.util.JumboEnumSet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#removeAll(java.util.Collection)
    // starting method java.util.JumboEnumSet#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#retainAll(java.util.Collection)
    // starting method java.util.JumboEnumSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#clear()
    // starting method java.util.JumboEnumSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#equals(java.lang.Object)
    // ignoring method java.util.JumboEnumSet#recalculateSize()
    // starting method java.util.JumboEnumSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","EnumSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#clone()
    // starting method java.util.JumboEnumSet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#add(java.lang.Object)
    // starting method java.util.JumboEnumSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","CloneNotSupportedException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.CloneNotSupportedException
    
    // finishing method java.util.JumboEnumSet#clone()
    // starting method java.util.JumboEnumSet#access$000(java.util.JumboEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.JumboEnumSet)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#access$000(java.util.JumboEnumSet)
    // starting method java.util.JumboEnumSet#access$110(java.util.JumboEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$110(java.util.JumboEnumSet)");
    method.setSimpleName("access$110");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.JumboEnumSet#access$110(java.util.JumboEnumSet)

// finishing type java.util.JumboEnumSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.LinkedHashMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap$Entry");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$Entry#before
	field = newType.addNode(JavaDataField.class,"before"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$Entry#before

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$Entry#after
	field = newType.addNode(JavaDataField.class,"after"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$Entry#after


    // starting method java.util.LinkedHashMap$Entry#LinkedHashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)");
    method.setSimpleName("LinkedHashMap$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$Entry#LinkedHashMap$Entry(int, java.lang.Object, java.lang.Object, java.util.HashMap$Entry)
    // ignoring method java.util.LinkedHashMap$Entry#remove()
    // ignoring method java.util.LinkedHashMap$Entry#addBefore(java.util.LinkedHashMap$Entry)
    // starting method java.util.LinkedHashMap$Entry#recordAccess(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"recordAccess(java.util.HashMap)");
    method.setSimpleName("recordAccess");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$Entry#recordAccess(java.util.HashMap)
    // starting method java.util.LinkedHashMap$Entry#recordRemoval(java.util.HashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"recordRemoval(java.util.HashMap)");
    method.setSimpleName("recordRemoval");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$Entry#recordRemoval(java.util.HashMap)
    // starting method java.util.LinkedHashMap$Entry#access$600(java.util.LinkedHashMap$Entry, java.util.LinkedHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$600(java.util.LinkedHashMap$Entry, java.util.LinkedHashMap$Entry)");
    method.setSimpleName("access$600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$Entry#access$600(java.util.LinkedHashMap$Entry, java.util.LinkedHashMap$Entry)

// finishing type java.util.LinkedHashMap$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","LinkedHashMap$LinkedHashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$EntryIterator#this$0


    // ignoring method java.util.LinkedHashMap$EntryIterator#LinkedHashMap$EntryIterator(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$EntryIterator#next()
    // starting method java.util.LinkedHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$EntryIterator#next()
    // starting method java.util.LinkedHashMap$EntryIterator#LinkedHashMap$EntryIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$EntryIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)");
    method.setSimpleName("LinkedHashMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$EntryIterator#LinkedHashMap$EntryIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)

// finishing type java.util.LinkedHashMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","LinkedHashMap$LinkedHashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$KeyIterator#this$0


    // ignoring method java.util.LinkedHashMap$KeyIterator#LinkedHashMap$KeyIterator(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$KeyIterator#next()
    // starting method java.util.LinkedHashMap$KeyIterator#LinkedHashMap$KeyIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$KeyIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)");
    method.setSimpleName("LinkedHashMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$KeyIterator#LinkedHashMap$KeyIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)

// finishing type java.util.LinkedHashMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$LinkedHashIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$LinkedHashIterator#nextEntry
	field = newType.addNode(JavaDataField.class,"nextEntry"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$LinkedHashIterator#nextEntry

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$LinkedHashIterator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$LinkedHashIterator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$LinkedHashIterator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$LinkedHashIterator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$LinkedHashIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$LinkedHashIterator#this$0


    // ignoring method java.util.LinkedHashMap$LinkedHashIterator#LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap$LinkedHashIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$LinkedHashIterator#hasNext()
    // starting method java.util.LinkedHashMap$LinkedHashIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$LinkedHashIterator#remove()
    // starting method java.util.LinkedHashMap$LinkedHashIterator#nextEntry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextEntry()");
    method.setSimpleName("nextEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$LinkedHashIterator#nextEntry()
    // starting method java.util.LinkedHashMap$LinkedHashIterator#LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)");
    method.setSimpleName("LinkedHashMap$LinkedHashIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$LinkedHashIterator#LinkedHashMap$LinkedHashIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)

// finishing type java.util.LinkedHashMap$LinkedHashIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","LinkedHashMap$LinkedHashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedHashMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedHashMap$ValueIterator#this$0


    // ignoring method java.util.LinkedHashMap$ValueIterator#LinkedHashMap$ValueIterator(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$ValueIterator#next()
    // starting method java.util.LinkedHashMap$ValueIterator#LinkedHashMap$ValueIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap$ValueIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)");
    method.setSimpleName("LinkedHashMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap$ValueIterator#LinkedHashMap$ValueIterator(java.util.LinkedHashMap, java.util.LinkedHashMap$1)

// finishing type java.util.LinkedHashMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 

// ignoring field java.util.LinkedHashMap#serialVersionUID 

// ignoring field java.util.LinkedHashMap#header 

// ignoring field java.util.LinkedHashMap#accessOrder 


    // starting method java.util.LinkedHashMap#LinkedHashMap(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap(int, float)");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap(int, float)
    // starting method java.util.LinkedHashMap#LinkedHashMap(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap(int)");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap(int)
    // starting method java.util.LinkedHashMap#LinkedHashMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap()");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap()
    // starting method java.util.LinkedHashMap#LinkedHashMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap(java.util.Map)");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap(java.util.Map)
    // starting method java.util.LinkedHashMap#LinkedHashMap(int, float, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashMap(int, float, boolean)");
    method.setSimpleName("LinkedHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#LinkedHashMap(int, float, boolean)
    // starting method java.util.LinkedHashMap#init()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"init()");
    method.setSimpleName("init");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#init()
    // starting method java.util.LinkedHashMap#transfer(java.util.HashMap$Entry[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"transfer(java.util.HashMap$Entry[])");
    method.setSimpleName("transfer");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#transfer(java.util.HashMap$Entry[])
    // starting method java.util.LinkedHashMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#containsValue(java.lang.Object)
    // starting method java.util.LinkedHashMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#get(java.lang.Object)
    // starting method java.util.LinkedHashMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#clear()
    // starting method java.util.LinkedHashMap#newKeyIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newKeyIterator()");
    method.setSimpleName("newKeyIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#newKeyIterator()
    // starting method java.util.LinkedHashMap#newValueIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newValueIterator()");
    method.setSimpleName("newValueIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#newValueIterator()
    // starting method java.util.LinkedHashMap#newEntryIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newEntryIterator()");
    method.setSimpleName("newEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#newEntryIterator()
    // starting method java.util.LinkedHashMap#addEntry(int, java.lang.Object, java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addEntry(int, java.lang.Object, java.lang.Object, int)");
    method.setSimpleName("addEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#addEntry(int, java.lang.Object, java.lang.Object, int)
    // starting method java.util.LinkedHashMap#createEntry(int, java.lang.Object, java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"createEntry(int, java.lang.Object, java.lang.Object, int)");
    method.setSimpleName("createEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#createEntry(int, java.lang.Object, java.lang.Object, int)
    // starting method java.util.LinkedHashMap#removeEldestEntry(java.util.Map$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeEldestEntry(java.util.Map$Entry)");
    method.setSimpleName("removeEldestEntry");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#removeEldestEntry(java.util.Map$Entry)
    // starting method java.util.LinkedHashMap#access$000(java.util.LinkedHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.LinkedHashMap)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#access$000(java.util.LinkedHashMap)
    // starting method java.util.LinkedHashMap#access$100(java.util.LinkedHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.LinkedHashMap)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashMap#access$100(java.util.LinkedHashMap)

// finishing type java.util.LinkedHashMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedHashSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","HashSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.LinkedHashSet#serialVersionUID 


    // starting method java.util.LinkedHashSet#LinkedHashSet(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashSet(int, float)");
    method.setSimpleName("LinkedHashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashSet#LinkedHashSet(int, float)
    // starting method java.util.LinkedHashSet#LinkedHashSet(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashSet(int)");
    method.setSimpleName("LinkedHashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashSet#LinkedHashSet(int)
    // starting method java.util.LinkedHashSet#LinkedHashSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashSet()");
    method.setSimpleName("LinkedHashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashSet#LinkedHashSet()
    // starting method java.util.LinkedHashSet#LinkedHashSet(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedHashSet(java.util.Collection)");
    method.setSimpleName("LinkedHashSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedHashSet#LinkedHashSet(java.util.Collection)

// finishing type java.util.LinkedHashSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedList$Entry#element
	field = newType.addNode(JavaDataField.class,"element"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedList$Entry#element

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedList$Entry#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedList$Entry#next

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedList$Entry#previous
	field = newType.addNode(JavaDataField.class,"previous"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.LinkedList$Entry#previous


    // starting method java.util.LinkedList$Entry#LinkedList$Entry(java.lang.Object, java.util.LinkedList$Entry, java.util.LinkedList$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedList$Entry(java.lang.Object, java.util.LinkedList$Entry, java.util.LinkedList$Entry)");
    method.setSimpleName("LinkedList$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$Entry#LinkedList$Entry(java.lang.Object, java.util.LinkedList$Entry, java.util.LinkedList$Entry)

// finishing type java.util.LinkedList$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList$ListItr");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

// ignoring field java.util.LinkedList$ListItr#lastReturned 

// ignoring field java.util.LinkedList$ListItr#next 

// ignoring field java.util.LinkedList$ListItr#nextIndex 

// ignoring field java.util.LinkedList$ListItr#expectedModCount 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.LinkedList$ListItr#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.LinkedList$ListItr#this$0


    // starting method java.util.LinkedList$ListItr#LinkedList$ListItr(java.util.LinkedList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedList$ListItr(java.util.LinkedList, int)");
    method.setSimpleName("LinkedList$ListItr");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#LinkedList$ListItr(java.util.LinkedList, int)
    // starting method java.util.LinkedList$ListItr#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#hasNext()
    // starting method java.util.LinkedList$ListItr#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#next()
    // starting method java.util.LinkedList$ListItr#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#hasPrevious()
    // starting method java.util.LinkedList$ListItr#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#previous()
    // starting method java.util.LinkedList$ListItr#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#nextIndex()
    // starting method java.util.LinkedList$ListItr#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#previousIndex()
    // starting method java.util.LinkedList$ListItr#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#remove()
    // starting method java.util.LinkedList$ListItr#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#set(java.lang.Object)
    // starting method java.util.LinkedList$ListItr#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#add(java.lang.Object)
    // starting method java.util.LinkedList$ListItr#checkForComodification()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkForComodification()");
    method.setSimpleName("checkForComodification");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList$ListItr#checkForComodification()

// finishing type java.util.LinkedList$ListItr
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "LinkedList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSequentialList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 
    // starting interface Queue 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Queue");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Queue 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.LinkedList#header 

// ignoring field java.util.LinkedList#size 

// ignoring field java.util.LinkedList#serialVersionUID 


    // starting method java.util.LinkedList#LinkedList()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedList()");
    method.setSimpleName("LinkedList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#LinkedList()
    // starting method java.util.LinkedList#LinkedList(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"LinkedList(java.util.Collection)");
    method.setSimpleName("LinkedList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#LinkedList(java.util.Collection)
    // starting method java.util.LinkedList#getFirst()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFirst()");
    method.setSimpleName("getFirst");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#getFirst()
    // starting method java.util.LinkedList#getLast()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLast()");
    method.setSimpleName("getLast");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#getLast()
    // starting method java.util.LinkedList#removeFirst()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeFirst()");
    method.setSimpleName("removeFirst");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#removeFirst()
    // starting method java.util.LinkedList#removeLast()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeLast()");
    method.setSimpleName("removeLast");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#removeLast()
    // starting method java.util.LinkedList#addFirst(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addFirst(java.lang.Object)");
    method.setSimpleName("addFirst");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#addFirst(java.lang.Object)
    // starting method java.util.LinkedList#addLast(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addLast(java.lang.Object)");
    method.setSimpleName("addLast");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#addLast(java.lang.Object)
    // starting method java.util.LinkedList#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#contains(java.lang.Object)
    // starting method java.util.LinkedList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#size()
    // starting method java.util.LinkedList#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#add(java.lang.Object)
    // starting method java.util.LinkedList#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#remove(java.lang.Object)
    // starting method java.util.LinkedList#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#addAll(java.util.Collection)
    // starting method java.util.LinkedList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#addAll(int, java.util.Collection)
    // starting method java.util.LinkedList#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#clear()
    // starting method java.util.LinkedList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#get(int)
    // starting method java.util.LinkedList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#set(int, java.lang.Object)
    // starting method java.util.LinkedList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#add(int, java.lang.Object)
    // starting method java.util.LinkedList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#remove(int)
    // ignoring method java.util.LinkedList#entry(int)
    // starting method java.util.LinkedList#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#indexOf(java.lang.Object)
    // starting method java.util.LinkedList#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#lastIndexOf(java.lang.Object)
    // starting method java.util.LinkedList#peek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"peek()");
    method.setSimpleName("peek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#peek()
    // starting method java.util.LinkedList#element()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"element()");
    method.setSimpleName("element");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#element()
    // starting method java.util.LinkedList#poll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"poll()");
    method.setSimpleName("poll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#poll()
    // starting method java.util.LinkedList#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#remove()
    // starting method java.util.LinkedList#offer(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"offer(java.lang.Object)");
    method.setSimpleName("offer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#offer(java.lang.Object)
    // starting method java.util.LinkedList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#listIterator(int)
    // ignoring method java.util.LinkedList#addBefore(java.lang.Object, java.util.LinkedList$Entry)
    // ignoring method java.util.LinkedList#remove(java.util.LinkedList$Entry)
    // starting method java.util.LinkedList#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#clone()
    // starting method java.util.LinkedList#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#toArray()
    // starting method java.util.LinkedList#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#toArray(java.lang.Object[])
    // ignoring method java.util.LinkedList#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.LinkedList#readObject(java.io.ObjectInputStream)
    // starting method java.util.LinkedList#access$000(java.util.LinkedList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.LinkedList)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#access$000(java.util.LinkedList)
    // starting method java.util.LinkedList#access$100(java.util.LinkedList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.LinkedList)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#access$100(java.util.LinkedList)
    // starting method java.util.LinkedList#access$200(java.util.LinkedList, java.util.LinkedList$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.LinkedList, java.util.LinkedList$Entry)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#access$200(java.util.LinkedList, java.util.LinkedList$Entry)
    // starting method java.util.LinkedList#access$300(java.util.LinkedList, java.lang.Object, java.util.LinkedList$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.util.LinkedList, java.lang.Object, java.util.LinkedList$Entry)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","LinkedList$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.LinkedList#access$300(java.util.LinkedList, java.lang.Object, java.util.LinkedList$Entry)

// finishing type java.util.LinkedList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "List");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 


    // starting method java.util.List#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#size()
    // starting method java.util.List#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#isEmpty()
    // starting method java.util.List#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#contains(java.lang.Object)
    // starting method java.util.List#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#iterator()
    // starting method java.util.List#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#toArray()
    // starting method java.util.List#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#toArray(java.lang.Object[])
    // starting method java.util.List#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#add(java.lang.Object)
    // starting method java.util.List#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#remove(java.lang.Object)
    // starting method java.util.List#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#containsAll(java.util.Collection)
    // starting method java.util.List#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#addAll(java.util.Collection)
    // starting method java.util.List#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#addAll(int, java.util.Collection)
    // starting method java.util.List#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#removeAll(java.util.Collection)
    // starting method java.util.List#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#retainAll(java.util.Collection)
    // starting method java.util.List#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#clear()
    // starting method java.util.List#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#equals(java.lang.Object)
    // starting method java.util.List#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#hashCode()
    // starting method java.util.List#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#get(int)
    // starting method java.util.List#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#set(int, java.lang.Object)
    // starting method java.util.List#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#add(int, java.lang.Object)
    // starting method java.util.List#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#remove(int)
    // starting method java.util.List#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#indexOf(java.lang.Object)
    // starting method java.util.List#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#lastIndexOf(java.lang.Object)
    // starting method java.util.List#listIterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator()");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#listIterator()
    // starting method java.util.List#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#listIterator(int)
    // starting method java.util.List#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.List#subList(int, int)

// finishing type java.util.List
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "ListIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 


    // starting method java.util.ListIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#hasNext()
    // starting method java.util.ListIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#next()
    // starting method java.util.ListIterator#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#hasPrevious()
    // starting method java.util.ListIterator#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#previous()
    // starting method java.util.ListIterator#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#nextIndex()
    // starting method java.util.ListIterator#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#previousIndex()
    // starting method java.util.ListIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#remove()
    // starting method java.util.ListIterator#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#set(java.lang.Object)
    // starting method java.util.ListIterator#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListIterator#add(java.lang.Object)

// finishing type java.util.ListIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ListResourceBundle");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ResourceBundle");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.ListResourceBundle#lookup 


    // starting method java.util.ListResourceBundle#ListResourceBundle()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ListResourceBundle()");
    method.setSimpleName("ListResourceBundle");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListResourceBundle#ListResourceBundle()
    // starting method java.util.ListResourceBundle#handleGetObject(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"handleGetObject(java.lang.String)");
    method.setSimpleName("handleGetObject");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListResourceBundle#handleGetObject(java.lang.String)
    // starting method java.util.ListResourceBundle#getKeys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKeys()");
    method.setSimpleName("getKeys");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListResourceBundle#getKeys()
    // starting method java.util.ListResourceBundle#getContents()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getContents()");
    method.setSimpleName("getContents");
    helper.setMethodData(method,1028);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ListResourceBundle#getContents()
    // ignoring method java.util.ListResourceBundle#loadLookup()

// finishing type java.util.ListResourceBundle
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Locale");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#ENGLISH
	field = newType.addNode(JavaDataField.class,"ENGLISH"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#ENGLISH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#FRENCH
	field = newType.addNode(JavaDataField.class,"FRENCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#FRENCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#GERMAN
	field = newType.addNode(JavaDataField.class,"GERMAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#GERMAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#ITALIAN
	field = newType.addNode(JavaDataField.class,"ITALIAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#ITALIAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#JAPANESE
	field = newType.addNode(JavaDataField.class,"JAPANESE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#JAPANESE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#KOREAN
	field = newType.addNode(JavaDataField.class,"KOREAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#KOREAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#CHINESE
	field = newType.addNode(JavaDataField.class,"CHINESE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#CHINESE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#SIMPLIFIED_CHINESE
	field = newType.addNode(JavaDataField.class,"SIMPLIFIED_CHINESE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#SIMPLIFIED_CHINESE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#TRADITIONAL_CHINESE
	field = newType.addNode(JavaDataField.class,"TRADITIONAL_CHINESE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#TRADITIONAL_CHINESE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#FRANCE
	field = newType.addNode(JavaDataField.class,"FRANCE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#FRANCE

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#GERMANY
	field = newType.addNode(JavaDataField.class,"GERMANY"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#GERMANY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#ITALY
	field = newType.addNode(JavaDataField.class,"ITALY"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#ITALY

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#JAPAN
	field = newType.addNode(JavaDataField.class,"JAPAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#JAPAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#KOREA
	field = newType.addNode(JavaDataField.class,"KOREA"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#KOREA

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#CHINA
	field = newType.addNode(JavaDataField.class,"CHINA"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#CHINA

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#PRC
	field = newType.addNode(JavaDataField.class,"PRC"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#PRC

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#TAIWAN
	field = newType.addNode(JavaDataField.class,"TAIWAN"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#TAIWAN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#UK
	field = newType.addNode(JavaDataField.class,"UK"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#UK

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#US
	field = newType.addNode(JavaDataField.class,"US"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#US

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#CANADA
	field = newType.addNode(JavaDataField.class,"CANADA"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#CANADA

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#CANADA_FRENCH
	field = newType.addNode(JavaDataField.class,"CANADA_FRENCH"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.Locale#CANADA_FRENCH

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Locale#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Locale#serialVersionUID

// ignoring field java.util.Locale#language 

// ignoring field java.util.Locale#country 

// ignoring field java.util.Locale#variant 

// ignoring field java.util.Locale#hashcode 

// ignoring field java.util.Locale#hashCodeValue 

// ignoring field java.util.Locale#defaultLocale 

// ignoring field java.util.Locale#isoLanguages 

// ignoring field java.util.Locale#compressedIsoLanguages 

// ignoring field java.util.Locale#isoCountries 

// ignoring field java.util.Locale#compressedIsoCountries 


    // starting method java.util.Locale#Locale(java.lang.String, java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Locale(java.lang.String, java.lang.String, java.lang.String)");
    method.setSimpleName("Locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#Locale(java.lang.String, java.lang.String, java.lang.String)
    // starting method java.util.Locale#Locale(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Locale(java.lang.String, java.lang.String)");
    method.setSimpleName("Locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#Locale(java.lang.String, java.lang.String)
    // starting method java.util.Locale#Locale(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Locale(java.lang.String)");
    method.setSimpleName("Locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#Locale(java.lang.String)
    // starting method java.util.Locale#getDefault()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDefault()");
    method.setSimpleName("getDefault");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDefault()
    // starting method java.util.Locale#setDefault(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setDefault(java.util.Locale)");
    method.setSimpleName("setDefault");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#setDefault(java.util.Locale)
    // starting method java.util.Locale#getAvailableLocales()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getAvailableLocales()");
    method.setSimpleName("getAvailableLocales");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getAvailableLocales()
    // starting method java.util.Locale#getISOCountries()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getISOCountries()");
    method.setSimpleName("getISOCountries");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getISOCountries()
    // starting method java.util.Locale#getISOLanguages()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getISOLanguages()");
    method.setSimpleName("getISOLanguages");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getISOLanguages()
    // starting method java.util.Locale#getLanguage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLanguage()");
    method.setSimpleName("getLanguage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getLanguage()
    // starting method java.util.Locale#getCountry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getCountry()");
    method.setSimpleName("getCountry");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getCountry()
    // starting method java.util.Locale#getVariant()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getVariant()");
    method.setSimpleName("getVariant");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getVariant()
    // starting method java.util.Locale#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#toString()
    // starting method java.util.Locale#getISO3Language()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getISO3Language()");
    method.setSimpleName("getISO3Language");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.util","MissingResourceException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.util.MissingResourceException
    
    // finishing method java.util.Locale#getISO3Language()
    // starting method java.util.Locale#getISO3Country()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getISO3Country()");
    method.setSimpleName("getISO3Country");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.util","MissingResourceException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.util.MissingResourceException
    
    // finishing method java.util.Locale#getISO3Country()
    // starting method java.util.Locale#getDisplayLanguage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayLanguage()");
    method.setSimpleName("getDisplayLanguage");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayLanguage()
    // starting method java.util.Locale#getDisplayLanguage(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayLanguage(java.util.Locale)");
    method.setSimpleName("getDisplayLanguage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayLanguage(java.util.Locale)
    // starting method java.util.Locale#getDisplayCountry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayCountry()");
    method.setSimpleName("getDisplayCountry");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayCountry()
    // starting method java.util.Locale#getDisplayCountry(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayCountry(java.util.Locale)");
    method.setSimpleName("getDisplayCountry");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayCountry(java.util.Locale)
    // starting method java.util.Locale#getDisplayVariant()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayVariant()");
    method.setSimpleName("getDisplayVariant");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayVariant()
    // starting method java.util.Locale#getDisplayVariant(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayVariant(java.util.Locale)");
    method.setSimpleName("getDisplayVariant");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayVariant(java.util.Locale)
    // starting method java.util.Locale#getDisplayName()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName()");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayName()
    // starting method java.util.Locale#getDisplayName(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName(java.util.Locale)");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#getDisplayName(java.util.Locale)
    // starting method java.util.Locale#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#clone()
    // starting method java.util.Locale#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#hashCode()
    // starting method java.util.Locale#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Locale#equals(java.lang.Object)
    // ignoring method java.util.Locale#getDisplayVariantArray(java.util.ResourceBundle)
    // ignoring method java.util.Locale#formatList(java.lang.String[], java.lang.String[])
    // ignoring method java.util.Locale#composeList(java.text.MessageFormat, java.lang.String[])
    // ignoring method java.util.Locale#readResolve()
    // ignoring method java.util.Locale#toLowerCase(java.lang.String)
    // ignoring method java.util.Locale#toUpperCase(java.lang.String)
    // ignoring method java.util.Locale#findStringMatch(java.lang.String[][], java.lang.String, java.lang.String)
    // ignoring method java.util.Locale#convertOldISOCodes(java.lang.String)

// finishing type java.util.Locale
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Map$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Map$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#getKey()
    // starting method java.util.Map$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#getValue()
    // starting method java.util.Map$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#setValue(java.lang.Object)
    // starting method java.util.Map$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#equals(java.lang.Object)
    // starting method java.util.Map$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map$Entry#hashCode()

// finishing type java.util.Map$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Map");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Map#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#size()
    // starting method java.util.Map#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#isEmpty()
    // starting method java.util.Map#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#containsKey(java.lang.Object)
    // starting method java.util.Map#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#containsValue(java.lang.Object)
    // starting method java.util.Map#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#get(java.lang.Object)
    // starting method java.util.Map#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#put(java.lang.Object, java.lang.Object)
    // starting method java.util.Map#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#remove(java.lang.Object)
    // starting method java.util.Map#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#putAll(java.util.Map)
    // starting method java.util.Map#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#clear()
    // starting method java.util.Map#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#keySet()
    // starting method java.util.Map#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#values()
    // starting method java.util.Map#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#entrySet()
    // starting method java.util.Map#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#equals(java.lang.Object)
    // starting method java.util.Map#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Map#hashCode()

// finishing type java.util.Map
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "MissingFormatArgumentException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.MissingFormatArgumentException#serialVersionUID 

// ignoring field java.util.MissingFormatArgumentException#s 


    // starting method java.util.MissingFormatArgumentException#MissingFormatArgumentException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"MissingFormatArgumentException(java.lang.String)");
    method.setSimpleName("MissingFormatArgumentException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatArgumentException#MissingFormatArgumentException(java.lang.String)
    // starting method java.util.MissingFormatArgumentException#getFormatSpecifier()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFormatSpecifier()");
    method.setSimpleName("getFormatSpecifier");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatArgumentException#getFormatSpecifier()
    // starting method java.util.MissingFormatArgumentException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatArgumentException#getMessage()

// finishing type java.util.MissingFormatArgumentException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "MissingFormatWidthException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.MissingFormatWidthException#serialVersionUID 

// ignoring field java.util.MissingFormatWidthException#s 


    // starting method java.util.MissingFormatWidthException#MissingFormatWidthException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"MissingFormatWidthException(java.lang.String)");
    method.setSimpleName("MissingFormatWidthException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatWidthException#MissingFormatWidthException(java.lang.String)
    // starting method java.util.MissingFormatWidthException#getFormatSpecifier()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFormatSpecifier()");
    method.setSimpleName("getFormatSpecifier");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatWidthException#getFormatSpecifier()
    // starting method java.util.MissingFormatWidthException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingFormatWidthException#getMessage()

// finishing type java.util.MissingFormatWidthException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "MissingResourceException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","RuntimeException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.MissingResourceException#className 

// ignoring field java.util.MissingResourceException#key 


    // starting method java.util.MissingResourceException#MissingResourceException(java.lang.String, java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"MissingResourceException(java.lang.String, java.lang.String, java.lang.String)");
    method.setSimpleName("MissingResourceException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingResourceException#MissingResourceException(java.lang.String, java.lang.String, java.lang.String)
    // starting method java.util.MissingResourceException#getClassName()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getClassName()");
    method.setSimpleName("getClassName");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingResourceException#getClassName()
    // starting method java.util.MissingResourceException#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.MissingResourceException#getKey()

// finishing type java.util.MissingResourceException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "NoSuchElementException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","RuntimeException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.NoSuchElementException#NoSuchElementException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"NoSuchElementException()");
    method.setSimpleName("NoSuchElementException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.NoSuchElementException#NoSuchElementException()
    // starting method java.util.NoSuchElementException#NoSuchElementException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"NoSuchElementException(java.lang.String)");
    method.setSimpleName("NoSuchElementException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.NoSuchElementException#NoSuchElementException(java.lang.String)

// finishing type java.util.NoSuchElementException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Observable");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Observable#changed 

// ignoring field java.util.Observable#obs 


    // starting method java.util.Observable#Observable()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Observable()");
    method.setSimpleName("Observable");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#Observable()
    // starting method java.util.Observable#addObserver(java.util.Observer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addObserver(java.util.Observer)");
    method.setSimpleName("addObserver");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#addObserver(java.util.Observer)
    // starting method java.util.Observable#deleteObserver(java.util.Observer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deleteObserver(java.util.Observer)");
    method.setSimpleName("deleteObserver");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#deleteObserver(java.util.Observer)
    // starting method java.util.Observable#notifyObservers()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"notifyObservers()");
    method.setSimpleName("notifyObservers");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#notifyObservers()
    // starting method java.util.Observable#notifyObservers(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"notifyObservers(java.lang.Object)");
    method.setSimpleName("notifyObservers");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#notifyObservers(java.lang.Object)
    // starting method java.util.Observable#deleteObservers()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"deleteObservers()");
    method.setSimpleName("deleteObservers");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#deleteObservers()
    // starting method java.util.Observable#setChanged()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setChanged()");
    method.setSimpleName("setChanged");
    helper.setMethodData(method,36);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#setChanged()
    // starting method java.util.Observable#clearChanged()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clearChanged()");
    method.setSimpleName("clearChanged");
    helper.setMethodData(method,36);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#clearChanged()
    // starting method java.util.Observable#hasChanged()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasChanged()");
    method.setSimpleName("hasChanged");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#hasChanged()
    // starting method java.util.Observable#countObservers()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"countObservers()");
    method.setSimpleName("countObservers");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observable#countObservers()

// finishing type java.util.Observable
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Observer");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.Observer#update(java.util.Observable, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"update(java.util.Observable, java.lang.Object)");
    method.setSimpleName("update");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Observer#update(java.util.Observable, java.lang.Object)

// finishing type java.util.Observer
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.PriorityQueue$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue$Itr");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.PriorityQueue$Itr#cursor 

// ignoring field java.util.PriorityQueue$Itr#lastRet 

// ignoring field java.util.PriorityQueue$Itr#expectedModCount 

// ignoring field java.util.PriorityQueue$Itr#forgetMeNot 

// ignoring field java.util.PriorityQueue$Itr#lastRetElt 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.PriorityQueue$Itr#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","PriorityQueue");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.PriorityQueue$Itr#this$0


    // ignoring method java.util.PriorityQueue$Itr#PriorityQueue$Itr(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue$Itr#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#hasNext()
    // starting method java.util.PriorityQueue$Itr#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#next()
    // starting method java.util.PriorityQueue$Itr#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#remove()
    // starting method java.util.PriorityQueue$Itr#checkForComodification()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"checkForComodification()");
    method.setSimpleName("checkForComodification");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#checkForComodification()
    // starting method java.util.PriorityQueue$Itr#PriorityQueue$Itr(java.util.PriorityQueue, java.util.PriorityQueue$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue$Itr(java.util.PriorityQueue, java.util.PriorityQueue$1)");
    method.setSimpleName("PriorityQueue$Itr");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue$Itr#PriorityQueue$Itr(java.util.PriorityQueue, java.util.PriorityQueue$1)

// finishing type java.util.PriorityQueue$Itr
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PriorityQueue");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractQueue");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.PriorityQueue#serialVersionUID 

// ignoring field java.util.PriorityQueue#DEFAULT_INITIAL_CAPACITY 

// ignoring field java.util.PriorityQueue#queue 

// ignoring field java.util.PriorityQueue#size 

// ignoring field java.util.PriorityQueue#comparator 

// ignoring field java.util.PriorityQueue#modCount 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.PriorityQueue#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.PriorityQueue#$assertionsDisabled


    // starting method java.util.PriorityQueue#PriorityQueue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue()");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue()
    // starting method java.util.PriorityQueue#PriorityQueue(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(int)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(int)
    // starting method java.util.PriorityQueue#PriorityQueue(int, java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(int, java.util.Comparator)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(int, java.util.Comparator)
    // ignoring method java.util.PriorityQueue#initializeArray(java.util.Collection)
    // ignoring method java.util.PriorityQueue#fillFromSorted(java.util.Collection)
    // ignoring method java.util.PriorityQueue#fillFromUnsorted(java.util.Collection)
    // starting method java.util.PriorityQueue#PriorityQueue(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(java.util.Collection)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(java.util.Collection)
    // starting method java.util.PriorityQueue#PriorityQueue(java.util.PriorityQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(java.util.PriorityQueue)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue#PriorityQueue(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PriorityQueue(java.util.SortedSet)");
    method.setSimpleName("PriorityQueue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#PriorityQueue(java.util.SortedSet)
    // ignoring method java.util.PriorityQueue#grow(int)
    // starting method java.util.PriorityQueue#offer(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"offer(java.lang.Object)");
    method.setSimpleName("offer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#offer(java.lang.Object)
    // starting method java.util.PriorityQueue#peek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"peek()");
    method.setSimpleName("peek");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#peek()
    // starting method java.util.PriorityQueue#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#add(java.lang.Object)
    // starting method java.util.PriorityQueue#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#remove(java.lang.Object)
    // starting method java.util.PriorityQueue#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#iterator()
    // starting method java.util.PriorityQueue#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#size()
    // starting method java.util.PriorityQueue#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#clear()
    // starting method java.util.PriorityQueue#poll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"poll()");
    method.setSimpleName("poll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#poll()
    // ignoring method java.util.PriorityQueue#removeAt(int)
    // ignoring method java.util.PriorityQueue#fixUp(int)
    // ignoring method java.util.PriorityQueue#fixDown(int)
    // ignoring method java.util.PriorityQueue#heapify()
    // starting method java.util.PriorityQueue#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#comparator()
    // ignoring method java.util.PriorityQueue#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.PriorityQueue#readObject(java.io.ObjectInputStream)
    // starting method java.util.PriorityQueue#access$100(java.util.PriorityQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.PriorityQueue)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#access$100(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue#access$200(java.util.PriorityQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.PriorityQueue)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#access$200(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue#access$300(java.util.PriorityQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.util.PriorityQueue)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#access$300(java.util.PriorityQueue)
    // starting method java.util.PriorityQueue#access$400(java.util.PriorityQueue, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.PriorityQueue, int)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PriorityQueue#access$400(java.util.PriorityQueue, int)

// finishing type java.util.PriorityQueue
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Properties$LineReader");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#inBuf
	field = newType.addNode(JavaDataField.class,"inBuf"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#inBuf

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#lineBuf
	field = newType.addNode(JavaDataField.class,"lineBuf"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#lineBuf

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#inLimit
	field = newType.addNode(JavaDataField.class,"inLimit"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#inLimit

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#inOff
	field = newType.addNode(JavaDataField.class,"inOff"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#inOff

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#inStream
	field = newType.addNode(JavaDataField.class,"inStream"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.io","InputStream");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#inStream

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties$LineReader#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Properties");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Properties$LineReader#this$0


    // starting method java.util.Properties$LineReader#Properties$LineReader(java.util.Properties, java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Properties$LineReader(java.util.Properties, java.io.InputStream)");
    method.setSimpleName("Properties$LineReader");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties$LineReader#Properties$LineReader(java.util.Properties, java.io.InputStream)
    // starting method java.util.Properties$LineReader#readLine()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"readLine()");
    method.setSimpleName("readLine");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties$LineReader#readLine()

// finishing type java.util.Properties$LineReader
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Properties");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Hashtable");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Properties#serialVersionUID 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Properties#defaults
	field = newType.addNode(JavaDataField.class,"defaults"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Properties");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Properties#defaults

// ignoring field java.util.Properties#hexDigit 


    // starting method java.util.Properties#Properties()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Properties()");
    method.setSimpleName("Properties");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#Properties()
    // starting method java.util.Properties#Properties(java.util.Properties)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Properties(java.util.Properties)");
    method.setSimpleName("Properties");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#Properties(java.util.Properties)
    // starting method java.util.Properties#setProperty(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setProperty(java.lang.String, java.lang.String)");
    method.setSimpleName("setProperty");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#setProperty(java.lang.String, java.lang.String)
    // starting method java.util.Properties#load(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"load(java.io.InputStream)");
    method.setSimpleName("load");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties#load(java.io.InputStream)
    // ignoring method java.util.Properties#loadConvert(char[], int, int, char[])
    // ignoring method java.util.Properties#saveConvert(java.lang.String, boolean)
    // starting method java.util.Properties#save(java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"save(java.io.OutputStream, java.lang.String)");
    method.setSimpleName("save");
    helper.setMethodData(method,131105);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#save(java.io.OutputStream, java.lang.String)
    // starting method java.util.Properties#store(java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"store(java.io.OutputStream, java.lang.String)");
    method.setSimpleName("store");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties#store(java.io.OutputStream, java.lang.String)
    // ignoring method java.util.Properties#writeln(java.io.BufferedWriter, java.lang.String)
    // starting method java.util.Properties#loadFromXML(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"loadFromXML(java.io.InputStream)");
    method.setSimpleName("loadFromXML");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.util","InvalidPropertiesFormatException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.util.InvalidPropertiesFormatException
    
    // finishing method java.util.Properties#loadFromXML(java.io.InputStream)
    // starting method java.util.Properties#storeToXML(java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"storeToXML(java.io.OutputStream, java.lang.String)");
    method.setSimpleName("storeToXML");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties#storeToXML(java.io.OutputStream, java.lang.String)
    // starting method java.util.Properties#storeToXML(java.io.OutputStream, java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"storeToXML(java.io.OutputStream, java.lang.String, java.lang.String)");
    method.setSimpleName("storeToXML");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.Properties#storeToXML(java.io.OutputStream, java.lang.String, java.lang.String)
    // starting method java.util.Properties#getProperty(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getProperty(java.lang.String)");
    method.setSimpleName("getProperty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#getProperty(java.lang.String)
    // starting method java.util.Properties#getProperty(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getProperty(java.lang.String, java.lang.String)");
    method.setSimpleName("getProperty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#getProperty(java.lang.String, java.lang.String)
    // starting method java.util.Properties#propertyNames()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"propertyNames()");
    method.setSimpleName("propertyNames");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#propertyNames()
    // starting method java.util.Properties#list(java.io.PrintStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"list(java.io.PrintStream)");
    method.setSimpleName("list");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#list(java.io.PrintStream)
    // starting method java.util.Properties#list(java.io.PrintWriter)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"list(java.io.PrintWriter)");
    method.setSimpleName("list");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Properties#list(java.io.PrintWriter)
    // ignoring method java.util.Properties#enumerate(java.util.Hashtable)
    // ignoring method java.util.Properties#toHex(int)

// finishing type java.util.Properties
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PropertyPermission");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","BasicPermission");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.PropertyPermission#READ 

// ignoring field java.util.PropertyPermission#WRITE 

// ignoring field java.util.PropertyPermission#ALL 

// ignoring field java.util.PropertyPermission#NONE 

// ignoring field java.util.PropertyPermission#mask 

// ignoring field java.util.PropertyPermission#actions 

// ignoring field java.util.PropertyPermission#serialVersionUID 


    // ignoring method java.util.PropertyPermission#init(int)
    // starting method java.util.PropertyPermission#PropertyPermission(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PropertyPermission(java.lang.String, java.lang.String)");
    method.setSimpleName("PropertyPermission");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#PropertyPermission(java.lang.String, java.lang.String)
    // starting method java.util.PropertyPermission#implies(java.security.Permission)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"implies(java.security.Permission)");
    method.setSimpleName("implies");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#implies(java.security.Permission)
    // starting method java.util.PropertyPermission#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#equals(java.lang.Object)
    // starting method java.util.PropertyPermission#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#hashCode()
    // ignoring method java.util.PropertyPermission#getMask(java.lang.String)
    // starting method java.util.PropertyPermission#getActions(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActions(int)");
    method.setSimpleName("getActions");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#getActions(int)
    // starting method java.util.PropertyPermission#getActions()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getActions()");
    method.setSimpleName("getActions");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#getActions()
    // starting method java.util.PropertyPermission#getMask()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMask()");
    method.setSimpleName("getMask");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#getMask()
    // starting method java.util.PropertyPermission#newPermissionCollection()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"newPermissionCollection()");
    method.setSimpleName("newPermissionCollection");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.security","PermissionCollection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermission#newPermissionCollection()
    // ignoring method java.util.PropertyPermission#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.PropertyPermission#readObject(java.io.ObjectInputStream)

// finishing type java.util.PropertyPermission
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PropertyPermissionCollection");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PermissionCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.PropertyPermissionCollection#perms 

// ignoring field java.util.PropertyPermissionCollection#all_allowed 

// ignoring field java.util.PropertyPermissionCollection#serialVersionUID 

// ignoring field java.util.PropertyPermissionCollection#serialPersistentFields 


    // starting method java.util.PropertyPermissionCollection#PropertyPermissionCollection()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PropertyPermissionCollection()");
    method.setSimpleName("PropertyPermissionCollection");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermissionCollection#PropertyPermissionCollection()
    // starting method java.util.PropertyPermissionCollection#add(java.security.Permission)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.security.Permission)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermissionCollection#add(java.security.Permission)
    // starting method java.util.PropertyPermissionCollection#implies(java.security.Permission)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"implies(java.security.Permission)");
    method.setSimpleName("implies");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermissionCollection#implies(java.security.Permission)
    // starting method java.util.PropertyPermissionCollection#elements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elements()");
    method.setSimpleName("elements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyPermissionCollection#elements()
    // ignoring method java.util.PropertyPermissionCollection#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.PropertyPermissionCollection#readObject(java.io.ObjectInputStream)

// finishing type java.util.PropertyPermissionCollection
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "PropertyResourceBundle");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ResourceBundle");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.PropertyResourceBundle#lookup 


    // starting method java.util.PropertyResourceBundle#PropertyResourceBundle(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"PropertyResourceBundle(java.io.InputStream)");
    method.setSimpleName("PropertyResourceBundle");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.PropertyResourceBundle#PropertyResourceBundle(java.io.InputStream)
    // starting method java.util.PropertyResourceBundle#handleGetObject(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"handleGetObject(java.lang.String)");
    method.setSimpleName("handleGetObject");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyResourceBundle#handleGetObject(java.lang.String)
    // starting method java.util.PropertyResourceBundle#getKeys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKeys()");
    method.setSimpleName("getKeys");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.PropertyResourceBundle#getKeys()

// finishing type java.util.PropertyResourceBundle
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Queue");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 


    // starting method java.util.Queue#offer(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"offer(java.lang.Object)");
    method.setSimpleName("offer");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#offer(java.lang.Object)
    // starting method java.util.Queue#poll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"poll()");
    method.setSimpleName("poll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#poll()
    // starting method java.util.Queue#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#remove()
    // starting method java.util.Queue#peek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"peek()");
    method.setSimpleName("peek");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#peek()
    // starting method java.util.Queue#element()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"element()");
    method.setSimpleName("element");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Queue#element()

// finishing type java.util.Queue
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Random");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Random#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.Random#serialVersionUID

// ignoring field java.util.Random#seed 

// ignoring field java.util.Random#multiplier 

// ignoring field java.util.Random#addend 

// ignoring field java.util.Random#mask 

// ignoring field java.util.Random#seedUniquifier 

// ignoring field java.util.Random#BITS_PER_BYTE 

// ignoring field java.util.Random#BYTES_PER_INT 

// ignoring field java.util.Random#nextNextGaussian 

// ignoring field java.util.Random#haveNextNextGaussian 

// ignoring field java.util.Random#serialPersistentFields 


    // starting method java.util.Random#Random()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Random()");
    method.setSimpleName("Random");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#Random()
    // starting method java.util.Random#Random(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Random(long)");
    method.setSimpleName("Random");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#Random(long)
    // starting method java.util.Random#setSeed(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setSeed(long)");
    method.setSimpleName("setSeed");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#setSeed(long)
    // starting method java.util.Random#next(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next(int)");
    method.setSimpleName("next");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#next(int)
    // starting method java.util.Random#nextBytes(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBytes(byte[])");
    method.setSimpleName("nextBytes");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextBytes(byte[])
    // starting method java.util.Random#nextInt()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextInt()");
    method.setSimpleName("nextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextInt()
    // starting method java.util.Random#nextInt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextInt(int)");
    method.setSimpleName("nextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextInt(int)
    // starting method java.util.Random#nextLong()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextLong()");
    method.setSimpleName("nextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextLong()
    // starting method java.util.Random#nextBoolean()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBoolean()");
    method.setSimpleName("nextBoolean");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextBoolean()
    // starting method java.util.Random#nextFloat()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextFloat()");
    method.setSimpleName("nextFloat");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "float");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextFloat()
    // starting method java.util.Random#nextDouble()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextDouble()");
    method.setSimpleName("nextDouble");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextDouble()
    // starting method java.util.Random#nextGaussian()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextGaussian()");
    method.setSimpleName("nextGaussian");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Random#nextGaussian()
    // ignoring method java.util.Random#readObject(java.io.ObjectInputStream)
    // ignoring method java.util.Random#writeObject(java.io.ObjectOutputStream)

// finishing type java.util.Random
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "RandomAccess");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.RandomAccess
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "RandomAccessSubList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SubList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 


    // starting method java.util.RandomAccessSubList#RandomAccessSubList(java.util.AbstractList, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"RandomAccessSubList(java.util.AbstractList, int, int)");
    method.setSimpleName("RandomAccessSubList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RandomAccessSubList#RandomAccessSubList(java.util.AbstractList, int, int)
    // starting method java.util.RandomAccessSubList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RandomAccessSubList#subList(int, int)

// finishing type java.util.RandomAccessSubList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "RegularEnumSet$EnumSetIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.RegularEnumSet$EnumSetIterator#unseen
	field = newType.addNode(JavaDataField.class,"unseen"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.RegularEnumSet$EnumSetIterator#unseen

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.RegularEnumSet$EnumSetIterator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.RegularEnumSet$EnumSetIterator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.RegularEnumSet$EnumSetIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","RegularEnumSet");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.RegularEnumSet$EnumSetIterator#this$0


    // starting method java.util.RegularEnumSet$EnumSetIterator#RegularEnumSet$EnumSetIterator(java.util.RegularEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"RegularEnumSet$EnumSetIterator(java.util.RegularEnumSet)");
    method.setSimpleName("RegularEnumSet$EnumSetIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#RegularEnumSet$EnumSetIterator(java.util.RegularEnumSet)
    // starting method java.util.RegularEnumSet$EnumSetIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#hasNext()
    // starting method java.util.RegularEnumSet$EnumSetIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Enum");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#next()
    // starting method java.util.RegularEnumSet$EnumSetIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#remove()
    // starting method java.util.RegularEnumSet$EnumSetIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet$EnumSetIterator#next()

// finishing type java.util.RegularEnumSet$EnumSetIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "RegularEnumSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","EnumSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.RegularEnumSet#elements 


    // starting method java.util.RegularEnumSet#RegularEnumSet(java.lang.Class, java.lang.Enum[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"RegularEnumSet(java.lang.Class, java.lang.Enum[])");
    method.setSimpleName("RegularEnumSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#RegularEnumSet(java.lang.Class, java.lang.Enum[])
    // starting method java.util.RegularEnumSet#addRange(java.lang.Enum, java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addRange(java.lang.Enum, java.lang.Enum)");
    method.setSimpleName("addRange");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#addRange(java.lang.Enum, java.lang.Enum)
    // starting method java.util.RegularEnumSet#addAll()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll()");
    method.setSimpleName("addAll");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#addAll()
    // starting method java.util.RegularEnumSet#complement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"complement()");
    method.setSimpleName("complement");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#complement()
    // starting method java.util.RegularEnumSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#iterator()
    // starting method java.util.RegularEnumSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#size()
    // starting method java.util.RegularEnumSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#isEmpty()
    // starting method java.util.RegularEnumSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#contains(java.lang.Object)
    // starting method java.util.RegularEnumSet#add(java.lang.Enum)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Enum)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#add(java.lang.Enum)
    // starting method java.util.RegularEnumSet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#remove(java.lang.Object)
    // starting method java.util.RegularEnumSet#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#containsAll(java.util.Collection)
    // starting method java.util.RegularEnumSet#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#addAll(java.util.Collection)
    // starting method java.util.RegularEnumSet#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#removeAll(java.util.Collection)
    // starting method java.util.RegularEnumSet#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#retainAll(java.util.Collection)
    // starting method java.util.RegularEnumSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#clear()
    // starting method java.util.RegularEnumSet#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#equals(java.lang.Object)
    // starting method java.util.RegularEnumSet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#add(java.lang.Object)
    // starting method java.util.RegularEnumSet#access$000(java.util.RegularEnumSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.RegularEnumSet)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#access$000(java.util.RegularEnumSet)
    // starting method java.util.RegularEnumSet#access$022(java.util.RegularEnumSet, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$022(java.util.RegularEnumSet, long)");
    method.setSimpleName("access$022");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.RegularEnumSet#access$022(java.util.RegularEnumSet, long)

// finishing type java.util.RegularEnumSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface PrivilegedAction 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PrivilegedAction");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface PrivilegedAction 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundle$1#val$loader
	field = newType.addNode(JavaDataField.class,"val$loader"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","ClassLoader");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundle$1#val$loader

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundle$1#val$resName
	field = newType.addNode(JavaDataField.class,"val$resName"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundle$1#val$resName


    // starting method java.util.ResourceBundle$1#ResourceBundle$1(java.lang.ClassLoader, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundle$1(java.lang.ClassLoader, java.lang.String)");
    method.setSimpleName("ResourceBundle$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$1#ResourceBundle$1(java.lang.ClassLoader, java.lang.String)
    // starting method java.util.ResourceBundle$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$1#run()

// finishing type java.util.ResourceBundle$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$LoaderReference");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang.ref","WeakReference");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.ResourceBundle$LoaderReference#cacheKey 


    // starting method java.util.ResourceBundle$LoaderReference#ResourceBundle$LoaderReference(java.lang.Object, java.lang.ref.ReferenceQueue, java.util.ResourceBundle$ResourceCacheKey)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundle$LoaderReference(java.lang.Object, java.lang.ref.ReferenceQueue, java.util.ResourceBundle$ResourceCacheKey)");
    method.setSimpleName("ResourceBundle$LoaderReference");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$LoaderReference#ResourceBundle$LoaderReference(java.lang.Object, java.lang.ref.ReferenceQueue, java.util.ResourceBundle$ResourceCacheKey)
    // starting method java.util.ResourceBundle$LoaderReference#getCacheKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getCacheKey()");
    method.setSimpleName("getCacheKey");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle$ResourceCacheKey");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$LoaderReference#getCacheKey()

// finishing type java.util.ResourceBundle$LoaderReference
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle$ResourceCacheKey");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 

// ignoring field java.util.ResourceBundle$ResourceCacheKey#loaderRef 

// ignoring field java.util.ResourceBundle$ResourceCacheKey#searchName 

// ignoring field java.util.ResourceBundle$ResourceCacheKey#defaultLocale 

// ignoring field java.util.ResourceBundle$ResourceCacheKey#hashCodeCache 


    // ignoring method java.util.ResourceBundle$ResourceCacheKey#ResourceBundle$ResourceCacheKey()
    // starting method java.util.ResourceBundle$ResourceCacheKey#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#equals(java.lang.Object)
    // starting method java.util.ResourceBundle$ResourceCacheKey#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#hashCode()
    // starting method java.util.ResourceBundle$ResourceCacheKey#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#clone()
    // starting method java.util.ResourceBundle$ResourceCacheKey#setKeyValues(java.lang.ClassLoader, java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setKeyValues(java.lang.ClassLoader, java.lang.String, java.util.Locale)");
    method.setSimpleName("setKeyValues");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#setKeyValues(java.lang.ClassLoader, java.lang.String, java.util.Locale)
    // starting method java.util.ResourceBundle$ResourceCacheKey#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#clear()
    // starting method java.util.ResourceBundle$ResourceCacheKey#ResourceBundle$ResourceCacheKey(java.util.ResourceBundle$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundle$ResourceCacheKey(java.util.ResourceBundle$1)");
    method.setSimpleName("ResourceBundle$ResourceCacheKey");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle$ResourceCacheKey#ResourceBundle$ResourceCacheKey(java.util.ResourceBundle$1)

// finishing type java.util.ResourceBundle$ResourceCacheKey
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundle");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.ResourceBundle#cacheKey 

// ignoring field java.util.ResourceBundle#INITIAL_CACHE_SIZE 

// ignoring field java.util.ResourceBundle#CACHE_LOAD_FACTOR 

// ignoring field java.util.ResourceBundle#MAX_BUNDLES_SEARCHED 

// ignoring field java.util.ResourceBundle#underConstruction 

// ignoring field java.util.ResourceBundle#NOT_FOUND 

// ignoring field java.util.ResourceBundle#cacheList 

// ignoring field java.util.ResourceBundle#referenceQueue 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundle#parent
	field = newType.addNode(JavaDataField.class,"parent"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundle#parent

// ignoring field java.util.ResourceBundle#locale 


    // starting method java.util.ResourceBundle#ResourceBundle()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundle()");
    method.setSimpleName("ResourceBundle");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#ResourceBundle()
    // starting method java.util.ResourceBundle#getString(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getString(java.lang.String)");
    method.setSimpleName("getString");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getString(java.lang.String)
    // starting method java.util.ResourceBundle#getStringArray(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getStringArray(java.lang.String)");
    method.setSimpleName("getStringArray");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getStringArray(java.lang.String)
    // starting method java.util.ResourceBundle#getObject(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getObject(java.lang.String)");
    method.setSimpleName("getObject");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getObject(java.lang.String)
    // starting method java.util.ResourceBundle#getLocale()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLocale()");
    method.setSimpleName("getLocale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getLocale()
    // ignoring method java.util.ResourceBundle#setLocale(java.lang.String, java.lang.String)
    // ignoring method java.util.ResourceBundle#getLoader()
    // ignoring method java.util.ResourceBundle#getClassContext()
    // starting method java.util.ResourceBundle#setParent(java.util.ResourceBundle)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setParent(java.util.ResourceBundle)");
    method.setSimpleName("setParent");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#setParent(java.util.ResourceBundle)
    // starting method java.util.ResourceBundle#getBundle(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getBundle(java.lang.String)");
    method.setSimpleName("getBundle");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getBundle(java.lang.String)
    // starting method java.util.ResourceBundle#getBundle(java.lang.String, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getBundle(java.lang.String, java.util.Locale)");
    method.setSimpleName("getBundle");
    helper.setMethodData(method,25);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getBundle(java.lang.String, java.util.Locale)
    // starting method java.util.ResourceBundle#getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)");
    method.setSimpleName("getBundle");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ResourceBundle");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
    // ignoring method java.util.ResourceBundle#getBundleImpl(java.lang.String, java.util.Locale, java.lang.ClassLoader)
    // ignoring method java.util.ResourceBundle#propagate(java.lang.ClassLoader, java.util.Vector, java.util.Vector, java.util.Locale, java.lang.Object)
    // ignoring method java.util.ResourceBundle#throwMissingResourceException(java.lang.String, java.util.Locale)
    // ignoring method java.util.ResourceBundle#cleanUpConstructionList()
    // ignoring method java.util.ResourceBundle#findBundle(java.lang.ClassLoader, java.lang.String, java.util.Locale, java.lang.String, java.lang.Object)
    // ignoring method java.util.ResourceBundle#calculateBundleNames(java.lang.String, java.util.Locale)
    // ignoring method java.util.ResourceBundle#findBundleInCache(java.lang.ClassLoader, java.lang.String, java.util.Locale)
    // ignoring method java.util.ResourceBundle#putBundleInCache(java.lang.ClassLoader, java.lang.String, java.util.Locale, java.lang.Object)
    // ignoring method java.util.ResourceBundle#loadBundle(java.lang.ClassLoader, java.lang.String, java.util.Locale)
    // starting method java.util.ResourceBundle#handleGetObject(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"handleGetObject(java.lang.String)");
    method.setSimpleName("handleGetObject");
    helper.setMethodData(method,1028);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#handleGetObject(java.lang.String)
    // starting method java.util.ResourceBundle#getKeys()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKeys()");
    method.setSimpleName("getKeys");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#getKeys()
    // starting method java.util.ResourceBundle#access$100()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100()");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang.ref","ReferenceQueue");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundle#access$100()

// finishing type java.util.ResourceBundle
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "ResourceBundleEnumeration");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundleEnumeration#set
	field = newType.addNode(JavaDataField.class,"set"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundleEnumeration#set

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundleEnumeration#iterator
	field = newType.addNode(JavaDataField.class,"iterator"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundleEnumeration#iterator

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundleEnumeration#enumeration
	field = newType.addNode(JavaDataField.class,"enumeration"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundleEnumeration#enumeration

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.ResourceBundleEnumeration#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.ResourceBundleEnumeration#next


    // starting method java.util.ResourceBundleEnumeration#ResourceBundleEnumeration(java.util.Set, java.util.Enumeration)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"ResourceBundleEnumeration(java.util.Set, java.util.Enumeration)");
    method.setSimpleName("ResourceBundleEnumeration");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundleEnumeration#ResourceBundleEnumeration(java.util.Set, java.util.Enumeration)
    // starting method java.util.ResourceBundleEnumeration#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundleEnumeration#hasMoreElements()
    // starting method java.util.ResourceBundleEnumeration#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundleEnumeration#nextElement()
    // starting method java.util.ResourceBundleEnumeration#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.ResourceBundleEnumeration#nextElement()

// finishing type java.util.ResourceBundleEnumeration
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Scanner$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"sun.misc","LRUCache");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Scanner$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Scanner$1#this$0


    // starting method java.util.Scanner$1#Scanner$1(java.util.Scanner, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner$1(java.util.Scanner, int)");
    method.setSimpleName("Scanner$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#Scanner$1(java.util.Scanner, int)
    // starting method java.util.Scanner$1#create(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"create(java.lang.String)");
    method.setSimpleName("create");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util.regex","Pattern");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#create(java.lang.String)
    // starting method java.util.Scanner$1#hasName(java.util.regex.Pattern, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasName(java.util.regex.Pattern, java.lang.String)");
    method.setSimpleName("hasName");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#hasName(java.util.regex.Pattern, java.lang.String)
    // starting method java.util.Scanner$1#hasName(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasName(java.lang.Object, java.lang.Object)");
    method.setSimpleName("hasName");
    helper.setMethodData(method,4164);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#hasName(java.lang.Object, java.lang.Object)
    // starting method java.util.Scanner$1#create(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"create(java.lang.Object)");
    method.setSimpleName("create");
    helper.setMethodData(method,4164);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner$1#create(java.lang.Object)

// finishing type java.util.Scanner$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Scanner");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.Scanner#buf 

// ignoring field java.util.Scanner#BUFFER_SIZE 

// ignoring field java.util.Scanner#position 

// ignoring field java.util.Scanner#matcher 

// ignoring field java.util.Scanner#delimPattern 

// ignoring field java.util.Scanner#hasNextPattern 

// ignoring field java.util.Scanner#hasNextPosition 

// ignoring field java.util.Scanner#hasNextResult 

// ignoring field java.util.Scanner#source 

// ignoring field java.util.Scanner#sourceClosed 

// ignoring field java.util.Scanner#needInput 

// ignoring field java.util.Scanner#skipped 

// ignoring field java.util.Scanner#savedScannerPosition 

// ignoring field java.util.Scanner#typeCache 

// ignoring field java.util.Scanner#matchValid 

// ignoring field java.util.Scanner#closed 

// ignoring field java.util.Scanner#radix 

// ignoring field java.util.Scanner#defaultRadix 

// ignoring field java.util.Scanner#locale 

// ignoring field java.util.Scanner#patternCache 

// ignoring field java.util.Scanner#lastException 

// ignoring field java.util.Scanner#WHITESPACE_PATTERN 

// ignoring field java.util.Scanner#FIND_ANY_PATTERN 

// ignoring field java.util.Scanner#NON_ASCII_DIGIT 

// ignoring field java.util.Scanner#groupSeparator 

// ignoring field java.util.Scanner#decimalSeparator 

// ignoring field java.util.Scanner#nanString 

// ignoring field java.util.Scanner#infinityString 

// ignoring field java.util.Scanner#positivePrefix 

// ignoring field java.util.Scanner#negativePrefix 

// ignoring field java.util.Scanner#positiveSuffix 

// ignoring field java.util.Scanner#negativeSuffix 

// ignoring field java.util.Scanner#boolPattern 

// ignoring field java.util.Scanner#BOOLEAN_PATTERN 

// ignoring field java.util.Scanner#integerPattern 

// ignoring field java.util.Scanner#digits 

// ignoring field java.util.Scanner#non0Digit 

// ignoring field java.util.Scanner#SIMPLE_GROUP_INDEX 

// ignoring field java.util.Scanner#separatorPattern 

// ignoring field java.util.Scanner#LINE_SEPARATOR_PATTERN 

// ignoring field java.util.Scanner#floatPattern 

// ignoring field java.util.Scanner#decimalPattern 


    // ignoring method java.util.Scanner#boolPattern()
    // ignoring method java.util.Scanner#buildIntegerPatternString()
    // ignoring method java.util.Scanner#integerPattern()
    // ignoring method java.util.Scanner#separatorPattern()
    // ignoring method java.util.Scanner#buildFloatAndDecimalPattern()
    // ignoring method java.util.Scanner#floatPattern()
    // ignoring method java.util.Scanner#decimalPattern()
    // ignoring method java.util.Scanner#Scanner(java.lang.Readable, java.util.regex.Pattern)
    // starting method java.util.Scanner#Scanner(java.lang.Readable)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.lang.Readable)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.lang.Readable)
    // starting method java.util.Scanner#Scanner(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.io.InputStream)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.io.InputStream)
    // starting method java.util.Scanner#Scanner(java.io.InputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.io.InputStream, java.lang.String)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.io.InputStream, java.lang.String)
    // ignoring method java.util.Scanner#makeReadable(java.io.InputStream, java.lang.String)
    // starting method java.util.Scanner#Scanner(java.io.File)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.io.File)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
    
    // finishing method java.util.Scanner#Scanner(java.io.File)
    // starting method java.util.Scanner#Scanner(java.io.File, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.io.File, java.lang.String)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","FileNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.FileNotFoundException
    
    // finishing method java.util.Scanner#Scanner(java.io.File, java.lang.String)
    // starting method java.util.Scanner#Scanner(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.lang.String)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.lang.String)
    // starting method java.util.Scanner#Scanner(java.nio.channels.ReadableByteChannel)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.nio.channels.ReadableByteChannel)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.nio.channels.ReadableByteChannel)
    // ignoring method java.util.Scanner#makeReadable(java.nio.channels.ReadableByteChannel)
    // starting method java.util.Scanner#Scanner(java.nio.channels.ReadableByteChannel, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Scanner(java.nio.channels.ReadableByteChannel, java.lang.String)");
    method.setSimpleName("Scanner");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#Scanner(java.nio.channels.ReadableByteChannel, java.lang.String)
    // ignoring method java.util.Scanner#makeReadable(java.nio.channels.ReadableByteChannel, java.lang.String)
    // ignoring method java.util.Scanner#saveState()
    // ignoring method java.util.Scanner#revertState()
    // ignoring method java.util.Scanner#revertState(boolean)
    // ignoring method java.util.Scanner#cacheResult(java.util.regex.Pattern)
    // ignoring method java.util.Scanner#clearCaches()
    // ignoring method java.util.Scanner#getCachedResult()
    // ignoring method java.util.Scanner#useTypeCache()
    // ignoring method java.util.Scanner#readInput()
    // ignoring method java.util.Scanner#makeSpace()
    // ignoring method java.util.Scanner#translateSavedIndexes(int)
    // ignoring method java.util.Scanner#throwFor()
    // ignoring method java.util.Scanner#hasTokenInBuffer()
    // ignoring method java.util.Scanner#getCompleteTokenInBuffer(java.util.regex.Pattern)
    // ignoring method java.util.Scanner#findPatternInBuffer(java.util.regex.Pattern, int)
    // ignoring method java.util.Scanner#matchPatternInBuffer(java.util.regex.Pattern)
    // ignoring method java.util.Scanner#ensureOpen()
    // starting method java.util.Scanner#close()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"close()");
    method.setSimpleName("close");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#close()
    // starting method java.util.Scanner#ioException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"ioException()");
    method.setSimpleName("ioException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#ioException()
    // starting method java.util.Scanner#delimiter()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"delimiter()");
    method.setSimpleName("delimiter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util.regex","Pattern");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#delimiter()
    // starting method java.util.Scanner#useDelimiter(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useDelimiter(java.util.regex.Pattern)");
    method.setSimpleName("useDelimiter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#useDelimiter(java.util.regex.Pattern)
    // starting method java.util.Scanner#useDelimiter(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useDelimiter(java.lang.String)");
    method.setSimpleName("useDelimiter");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#useDelimiter(java.lang.String)
    // starting method java.util.Scanner#locale()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"locale()");
    method.setSimpleName("locale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Locale");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#locale()
    // starting method java.util.Scanner#useLocale(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useLocale(java.util.Locale)");
    method.setSimpleName("useLocale");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#useLocale(java.util.Locale)
    // starting method java.util.Scanner#radix()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"radix()");
    method.setSimpleName("radix");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#radix()
    // starting method java.util.Scanner#useRadix(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useRadix(int)");
    method.setSimpleName("useRadix");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#useRadix(int)
    // ignoring method java.util.Scanner#setRadix(int)
    // starting method java.util.Scanner#match()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"match()");
    method.setSimpleName("match");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util.regex","MatchResult");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#match()
    // starting method java.util.Scanner#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#toString()
    // starting method java.util.Scanner#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNext()
    // starting method java.util.Scanner#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#next()
    // starting method java.util.Scanner#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#remove()
    // starting method java.util.Scanner#hasNext(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext(java.lang.String)");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNext(java.lang.String)
    // starting method java.util.Scanner#next(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next(java.lang.String)");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#next(java.lang.String)
    // starting method java.util.Scanner#hasNext(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext(java.util.regex.Pattern)");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNext(java.util.regex.Pattern)
    // starting method java.util.Scanner#next(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next(java.util.regex.Pattern)");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#next(java.util.regex.Pattern)
    // starting method java.util.Scanner#hasNextLine()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextLine()");
    method.setSimpleName("hasNextLine");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextLine()
    // starting method java.util.Scanner#nextLine()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextLine()");
    method.setSimpleName("nextLine");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextLine()
    // starting method java.util.Scanner#findInLine(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"findInLine(java.lang.String)");
    method.setSimpleName("findInLine");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#findInLine(java.lang.String)
    // starting method java.util.Scanner#findInLine(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"findInLine(java.util.regex.Pattern)");
    method.setSimpleName("findInLine");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#findInLine(java.util.regex.Pattern)
    // starting method java.util.Scanner#findWithinHorizon(java.lang.String, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"findWithinHorizon(java.lang.String, int)");
    method.setSimpleName("findWithinHorizon");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#findWithinHorizon(java.lang.String, int)
    // starting method java.util.Scanner#findWithinHorizon(java.util.regex.Pattern, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"findWithinHorizon(java.util.regex.Pattern, int)");
    method.setSimpleName("findWithinHorizon");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#findWithinHorizon(java.util.regex.Pattern, int)
    // starting method java.util.Scanner#skip(java.util.regex.Pattern)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"skip(java.util.regex.Pattern)");
    method.setSimpleName("skip");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#skip(java.util.regex.Pattern)
    // starting method java.util.Scanner#skip(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"skip(java.lang.String)");
    method.setSimpleName("skip");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Scanner");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#skip(java.lang.String)
    // starting method java.util.Scanner#hasNextBoolean()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextBoolean()");
    method.setSimpleName("hasNextBoolean");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextBoolean()
    // starting method java.util.Scanner#nextBoolean()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBoolean()");
    method.setSimpleName("nextBoolean");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextBoolean()
    // starting method java.util.Scanner#hasNextByte()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextByte()");
    method.setSimpleName("hasNextByte");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextByte()
    // starting method java.util.Scanner#hasNextByte(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextByte(int)");
    method.setSimpleName("hasNextByte");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextByte(int)
    // starting method java.util.Scanner#nextByte()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextByte()");
    method.setSimpleName("nextByte");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "byte");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextByte()
    // starting method java.util.Scanner#nextByte(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextByte(int)");
    method.setSimpleName("nextByte");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "byte");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextByte(int)
    // starting method java.util.Scanner#hasNextShort()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextShort()");
    method.setSimpleName("hasNextShort");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextShort()
    // starting method java.util.Scanner#hasNextShort(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextShort(int)");
    method.setSimpleName("hasNextShort");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextShort(int)
    // starting method java.util.Scanner#nextShort()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextShort()");
    method.setSimpleName("nextShort");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "short");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextShort()
    // starting method java.util.Scanner#nextShort(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextShort(int)");
    method.setSimpleName("nextShort");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "short");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextShort(int)
    // starting method java.util.Scanner#hasNextInt()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextInt()");
    method.setSimpleName("hasNextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextInt()
    // starting method java.util.Scanner#hasNextInt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextInt(int)");
    method.setSimpleName("hasNextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextInt(int)
    // ignoring method java.util.Scanner#processIntegerToken(java.lang.String)
    // starting method java.util.Scanner#nextInt()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextInt()");
    method.setSimpleName("nextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextInt()
    // starting method java.util.Scanner#nextInt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextInt(int)");
    method.setSimpleName("nextInt");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextInt(int)
    // starting method java.util.Scanner#hasNextLong()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextLong()");
    method.setSimpleName("hasNextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextLong()
    // starting method java.util.Scanner#hasNextLong(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextLong(int)");
    method.setSimpleName("hasNextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextLong(int)
    // starting method java.util.Scanner#nextLong()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextLong()");
    method.setSimpleName("nextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextLong()
    // starting method java.util.Scanner#nextLong(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextLong(int)");
    method.setSimpleName("nextLong");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextLong(int)
    // ignoring method java.util.Scanner#processFloatToken(java.lang.String)
    // starting method java.util.Scanner#hasNextFloat()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextFloat()");
    method.setSimpleName("hasNextFloat");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextFloat()
    // starting method java.util.Scanner#nextFloat()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextFloat()");
    method.setSimpleName("nextFloat");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "float");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextFloat()
    // starting method java.util.Scanner#hasNextDouble()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextDouble()");
    method.setSimpleName("hasNextDouble");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextDouble()
    // starting method java.util.Scanner#nextDouble()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextDouble()");
    method.setSimpleName("nextDouble");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "double");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextDouble()
    // starting method java.util.Scanner#hasNextBigInteger()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextBigInteger()");
    method.setSimpleName("hasNextBigInteger");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextBigInteger()
    // starting method java.util.Scanner#hasNextBigInteger(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextBigInteger(int)");
    method.setSimpleName("hasNextBigInteger");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextBigInteger(int)
    // starting method java.util.Scanner#nextBigInteger()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBigInteger()");
    method.setSimpleName("nextBigInteger");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.math","BigInteger");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextBigInteger()
    // starting method java.util.Scanner#nextBigInteger(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBigInteger(int)");
    method.setSimpleName("nextBigInteger");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.math","BigInteger");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextBigInteger(int)
    // starting method java.util.Scanner#hasNextBigDecimal()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNextBigDecimal()");
    method.setSimpleName("hasNextBigDecimal");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#hasNextBigDecimal()
    // starting method java.util.Scanner#nextBigDecimal()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextBigDecimal()");
    method.setSimpleName("nextBigDecimal");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.math","BigDecimal");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#nextBigDecimal()
    // starting method java.util.Scanner#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Scanner#next()

// finishing type java.util.Scanner
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "Set");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Collection 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Collection");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Collection 


    // starting method java.util.Set#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#size()
    // starting method java.util.Set#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#isEmpty()
    // starting method java.util.Set#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#contains(java.lang.Object)
    // starting method java.util.Set#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#iterator()
    // starting method java.util.Set#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#toArray()
    // starting method java.util.Set#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#toArray(java.lang.Object[])
    // starting method java.util.Set#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#add(java.lang.Object)
    // starting method java.util.Set#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#remove(java.lang.Object)
    // starting method java.util.Set#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#containsAll(java.util.Collection)
    // starting method java.util.Set#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#addAll(java.util.Collection)
    // starting method java.util.Set#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#retainAll(java.util.Collection)
    // starting method java.util.Set#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#removeAll(java.util.Collection)
    // starting method java.util.Set#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#clear()
    // starting method java.util.Set#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#equals(java.lang.Object)
    // starting method java.util.Set#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Set#hashCode()

// finishing type java.util.Set
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "SimpleTimeZone");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TimeZone");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.SimpleTimeZone#startMonth 

// ignoring field java.util.SimpleTimeZone#startDay 

// ignoring field java.util.SimpleTimeZone#startDayOfWeek 

// ignoring field java.util.SimpleTimeZone#startTime 

// ignoring field java.util.SimpleTimeZone#startTimeMode 

// ignoring field java.util.SimpleTimeZone#endMonth 

// ignoring field java.util.SimpleTimeZone#endDay 

// ignoring field java.util.SimpleTimeZone#endDayOfWeek 

// ignoring field java.util.SimpleTimeZone#endTime 

// ignoring field java.util.SimpleTimeZone#endTimeMode 

// ignoring field java.util.SimpleTimeZone#startYear 

// ignoring field java.util.SimpleTimeZone#rawOffset 

// ignoring field java.util.SimpleTimeZone#useDaylight 

// ignoring field java.util.SimpleTimeZone#millisPerHour 

// ignoring field java.util.SimpleTimeZone#millisPerDay 

// ignoring field java.util.SimpleTimeZone#monthLength 

// ignoring field java.util.SimpleTimeZone#staticMonthLength 

// ignoring field java.util.SimpleTimeZone#staticLeapMonthLength 

// ignoring field java.util.SimpleTimeZone#startMode 

// ignoring field java.util.SimpleTimeZone#endMode 

// ignoring field java.util.SimpleTimeZone#dstSavings 

// ignoring field java.util.SimpleTimeZone#gcal 

// ignoring field java.util.SimpleTimeZone#cacheYear 

// ignoring field java.util.SimpleTimeZone#cacheStart 

// ignoring field java.util.SimpleTimeZone#cacheEnd 

// ignoring field java.util.SimpleTimeZone#DOM_MODE 

// ignoring field java.util.SimpleTimeZone#DOW_IN_MONTH_MODE 

// ignoring field java.util.SimpleTimeZone#DOW_GE_DOM_MODE 

// ignoring field java.util.SimpleTimeZone#DOW_LE_DOM_MODE 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#WALL_TIME
	field = newType.addNode(JavaDataField.class,"WALL_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#WALL_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#STANDARD_TIME
	field = newType.addNode(JavaDataField.class,"STANDARD_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#STANDARD_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#UTC_TIME
	field = newType.addNode(JavaDataField.class,"UTC_TIME"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#UTC_TIME

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SimpleTimeZone#currentSerialVersion
	field = newType.addNode(JavaDataField.class,"currentSerialVersion"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.SimpleTimeZone#currentSerialVersion

// ignoring field java.util.SimpleTimeZone#serialVersionOnStream 


    // starting method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SimpleTimeZone(int, java.lang.String)");
    method.setSimpleName("SimpleTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String)
    // starting method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int)");
    method.setSimpleName("SimpleTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int)
    // starting method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int)");
    method.setSimpleName("SimpleTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int)
    // starting method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int, int, int)");
    method.setSimpleName("SimpleTimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#SimpleTimeZone(int, java.lang.String, int, int, int, int, int, int, int, int, int, int, int)
    // starting method java.util.SimpleTimeZone#setStartYear(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setStartYear(int)");
    method.setSimpleName("setStartYear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setStartYear(int)
    // starting method java.util.SimpleTimeZone#setStartRule(int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setStartRule(int, int, int, int)");
    method.setSimpleName("setStartRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setStartRule(int, int, int, int)
    // starting method java.util.SimpleTimeZone#setStartRule(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setStartRule(int, int, int)");
    method.setSimpleName("setStartRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setStartRule(int, int, int)
    // starting method java.util.SimpleTimeZone#setStartRule(int, int, int, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setStartRule(int, int, int, int, boolean)");
    method.setSimpleName("setStartRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setStartRule(int, int, int, int, boolean)
    // starting method java.util.SimpleTimeZone#setEndRule(int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setEndRule(int, int, int, int)");
    method.setSimpleName("setEndRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setEndRule(int, int, int, int)
    // starting method java.util.SimpleTimeZone#setEndRule(int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setEndRule(int, int, int)");
    method.setSimpleName("setEndRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setEndRule(int, int, int)
    // starting method java.util.SimpleTimeZone#setEndRule(int, int, int, int, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setEndRule(int, int, int, int, boolean)");
    method.setSimpleName("setEndRule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setEndRule(int, int, int, int, boolean)
    // starting method java.util.SimpleTimeZone#getOffset(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffset(long)");
    method.setSimpleName("getOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getOffset(long)
    // starting method java.util.SimpleTimeZone#getOffsets(long, int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffsets(long, int[])");
    method.setSimpleName("getOffsets");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getOffsets(long, int[])
    // starting method java.util.SimpleTimeZone#getOffset(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffset(int, int, int, int, int, int)");
    method.setSimpleName("getOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getOffset(int, int, int, int, int, int)
    // ignoring method java.util.SimpleTimeZone#getOffset(sun.util.calendar.BaseCalendar, sun.util.calendar.BaseCalendar$Date, int, long)
    // ignoring method java.util.SimpleTimeZone#getStart(sun.util.calendar.BaseCalendar, sun.util.calendar.BaseCalendar$Date, int)
    // ignoring method java.util.SimpleTimeZone#getEnd(sun.util.calendar.BaseCalendar, sun.util.calendar.BaseCalendar$Date, int)
    // ignoring method java.util.SimpleTimeZone#getTransition(sun.util.calendar.BaseCalendar, sun.util.calendar.BaseCalendar$Date, int, int, int, int, int, int)
    // starting method java.util.SimpleTimeZone#getRawOffset()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getRawOffset()");
    method.setSimpleName("getRawOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getRawOffset()
    // starting method java.util.SimpleTimeZone#setRawOffset(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setRawOffset(int)");
    method.setSimpleName("setRawOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setRawOffset(int)
    // starting method java.util.SimpleTimeZone#setDSTSavings(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setDSTSavings(int)");
    method.setSimpleName("setDSTSavings");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#setDSTSavings(int)
    // starting method java.util.SimpleTimeZone#getDSTSavings()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDSTSavings()");
    method.setSimpleName("getDSTSavings");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#getDSTSavings()
    // starting method java.util.SimpleTimeZone#useDaylightTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useDaylightTime()");
    method.setSimpleName("useDaylightTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#useDaylightTime()
    // starting method java.util.SimpleTimeZone#inDaylightTime(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"inDaylightTime(java.util.Date)");
    method.setSimpleName("inDaylightTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#inDaylightTime(java.util.Date)
    // starting method java.util.SimpleTimeZone#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#clone()
    // starting method java.util.SimpleTimeZone#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#hashCode()
    // starting method java.util.SimpleTimeZone#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#equals(java.lang.Object)
    // starting method java.util.SimpleTimeZone#hasSameRules(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasSameRules(java.util.TimeZone)");
    method.setSimpleName("hasSameRules");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#hasSameRules(java.util.TimeZone)
    // starting method java.util.SimpleTimeZone#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SimpleTimeZone#toString()
    // ignoring method java.util.SimpleTimeZone#invalidateCache()
    // ignoring method java.util.SimpleTimeZone#decodeRules()
    // ignoring method java.util.SimpleTimeZone#decodeStartRule()
    // ignoring method java.util.SimpleTimeZone#decodeEndRule()
    // ignoring method java.util.SimpleTimeZone#makeRulesCompatible()
    // ignoring method java.util.SimpleTimeZone#packRules()
    // ignoring method java.util.SimpleTimeZone#unpackRules(byte[])
    // ignoring method java.util.SimpleTimeZone#packTimes()
    // ignoring method java.util.SimpleTimeZone#unpackTimes(int[])
    // ignoring method java.util.SimpleTimeZone#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.SimpleTimeZone#readObject(java.io.ObjectInputStream)

// finishing type java.util.SimpleTimeZone
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "SortedMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 


    // starting method java.util.SortedMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#comparator()
    // starting method java.util.SortedMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.SortedMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#headMap(java.lang.Object)
    // starting method java.util.SortedMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#tailMap(java.lang.Object)
    // starting method java.util.SortedMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#firstKey()
    // starting method java.util.SortedMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedMap#lastKey()

// finishing type java.util.SortedMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeInterface.class,"java.util", "SortedSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Set 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Set");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Set 


    // starting method java.util.SortedSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#comparator()
    // starting method java.util.SortedSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.SortedSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#headSet(java.lang.Object)
    // starting method java.util.SortedSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#tailSet(java.lang.Object)
    // starting method java.util.SortedSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#first()
    // starting method java.util.SortedSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SortedSet#last()

// finishing type java.util.SortedSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Stack");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Vector");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Stack#serialVersionUID 


    // starting method java.util.Stack#Stack()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Stack()");
    method.setSimpleName("Stack");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#Stack()
    // starting method java.util.Stack#push(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"push(java.lang.Object)");
    method.setSimpleName("push");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#push(java.lang.Object)
    // starting method java.util.Stack#pop()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"pop()");
    method.setSimpleName("pop");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#pop()
    // starting method java.util.Stack#peek()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"peek()");
    method.setSimpleName("peek");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#peek()
    // starting method java.util.Stack#empty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"empty()");
    method.setSimpleName("empty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#empty()
    // starting method java.util.Stack#search(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"search(java.lang.Object)");
    method.setSimpleName("search");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Stack#search(java.lang.Object)

// finishing type java.util.Stack
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "StringTokenizer");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 

// ignoring field java.util.StringTokenizer#currentPosition 

// ignoring field java.util.StringTokenizer#newPosition 

// ignoring field java.util.StringTokenizer#maxPosition 

// ignoring field java.util.StringTokenizer#str 

// ignoring field java.util.StringTokenizer#delimiters 

// ignoring field java.util.StringTokenizer#retDelims 

// ignoring field java.util.StringTokenizer#delimsChanged 

// ignoring field java.util.StringTokenizer#maxDelimCodePoint 

// ignoring field java.util.StringTokenizer#hasSurrogates 

// ignoring field java.util.StringTokenizer#delimiterCodePoints 


    // ignoring method java.util.StringTokenizer#setMaxDelimCodePoint()
    // starting method java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"StringTokenizer(java.lang.String, java.lang.String, boolean)");
    method.setSimpleName("StringTokenizer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String, boolean)
    // starting method java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"StringTokenizer(java.lang.String, java.lang.String)");
    method.setSimpleName("StringTokenizer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String)
    // starting method java.util.StringTokenizer#StringTokenizer(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"StringTokenizer(java.lang.String)");
    method.setSimpleName("StringTokenizer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#StringTokenizer(java.lang.String)
    // ignoring method java.util.StringTokenizer#skipDelimiters(int)
    // ignoring method java.util.StringTokenizer#scanToken(int)
    // ignoring method java.util.StringTokenizer#isDelimiter(int)
    // starting method java.util.StringTokenizer#hasMoreTokens()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreTokens()");
    method.setSimpleName("hasMoreTokens");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#hasMoreTokens()
    // starting method java.util.StringTokenizer#nextToken()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextToken()");
    method.setSimpleName("nextToken");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#nextToken()
    // starting method java.util.StringTokenizer#nextToken(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextToken(java.lang.String)");
    method.setSimpleName("nextToken");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#nextToken(java.lang.String)
    // starting method java.util.StringTokenizer#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#hasMoreElements()
    // starting method java.util.StringTokenizer#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#nextElement()
    // starting method java.util.StringTokenizer#countTokens()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"countTokens()");
    method.setSimpleName("countTokens");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.StringTokenizer#countTokens()

// finishing type java.util.StringTokenizer
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "SubList$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ListIterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","ListIterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ListIterator 

// ignoring field java.util.SubList$1#i 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SubList$1#val$index
	field = newType.addNode(JavaDataField.class,"val$index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.SubList$1#val$index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.SubList$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SubList");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.SubList$1#this$0


    // starting method java.util.SubList$1#SubList$1(java.util.SubList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SubList$1(java.util.SubList, int)");
    method.setSimpleName("SubList$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#SubList$1(java.util.SubList, int)
    // starting method java.util.SubList$1#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#hasNext()
    // starting method java.util.SubList$1#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#next()
    // starting method java.util.SubList$1#hasPrevious()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasPrevious()");
    method.setSimpleName("hasPrevious");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#hasPrevious()
    // starting method java.util.SubList$1#previous()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previous()");
    method.setSimpleName("previous");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#previous()
    // starting method java.util.SubList$1#nextIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextIndex()");
    method.setSimpleName("nextIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#nextIndex()
    // starting method java.util.SubList$1#previousIndex()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"previousIndex()");
    method.setSimpleName("previousIndex");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#previousIndex()
    // starting method java.util.SubList$1#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#remove()
    // starting method java.util.SubList$1#set(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#set(java.lang.Object)
    // starting method java.util.SubList$1#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList$1#add(java.lang.Object)

// finishing type java.util.SubList$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "SubList");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.SubList#l 

// ignoring field java.util.SubList#offset 

// ignoring field java.util.SubList#size 

// ignoring field java.util.SubList#expectedModCount 


    // starting method java.util.SubList#SubList(java.util.AbstractList, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"SubList(java.util.AbstractList, int, int)");
    method.setSimpleName("SubList");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#SubList(java.util.AbstractList, int, int)
    // starting method java.util.SubList#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#set(int, java.lang.Object)
    // starting method java.util.SubList#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#get(int)
    // starting method java.util.SubList#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#size()
    // starting method java.util.SubList#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#add(int, java.lang.Object)
    // starting method java.util.SubList#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#remove(int)
    // starting method java.util.SubList#removeRange(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeRange(int, int)");
    method.setSimpleName("removeRange");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#removeRange(int, int)
    // starting method java.util.SubList#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#addAll(java.util.Collection)
    // starting method java.util.SubList#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#addAll(int, java.util.Collection)
    // starting method java.util.SubList#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#iterator()
    // starting method java.util.SubList#listIterator(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"listIterator(int)");
    method.setSimpleName("listIterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","ListIterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#listIterator(int)
    // starting method java.util.SubList#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#subList(int, int)
    // ignoring method java.util.SubList#rangeCheck(int)
    // ignoring method java.util.SubList#checkForComodification()
    // starting method java.util.SubList#access$000(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.SubList)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$000(java.util.SubList)
    // starting method java.util.SubList#access$100(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.SubList)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","AbstractList");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$100(java.util.SubList)
    // starting method java.util.SubList#access$200(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.SubList)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$200(java.util.SubList)
    // starting method java.util.SubList#access$302(java.util.SubList, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$302(java.util.SubList, int)");
    method.setSimpleName("access$302");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$302(java.util.SubList, int)
    // starting method java.util.SubList#access$210(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$210(java.util.SubList)");
    method.setSimpleName("access$210");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$210(java.util.SubList)
    // starting method java.util.SubList#access$208(java.util.SubList)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$208(java.util.SubList)");
    method.setSimpleName("access$208");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.SubList#access$208(java.util.SubList)

// finishing type java.util.SubList
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TaskQueue");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.TaskQueue#queue 

// ignoring field java.util.TaskQueue#size 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TaskQueue#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.TaskQueue#$assertionsDisabled


    // starting method java.util.TaskQueue#TaskQueue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TaskQueue()");
    method.setSimpleName("TaskQueue");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#TaskQueue()
    // starting method java.util.TaskQueue#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#size()
    // starting method java.util.TaskQueue#add(java.util.TimerTask)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.util.TimerTask)");
    method.setSimpleName("add");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#add(java.util.TimerTask)
    // starting method java.util.TaskQueue#getMin()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMin()");
    method.setSimpleName("getMin");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimerTask");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#getMin()
    // starting method java.util.TaskQueue#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimerTask");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#get(int)
    // starting method java.util.TaskQueue#removeMin()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeMin()");
    method.setSimpleName("removeMin");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#removeMin()
    // starting method java.util.TaskQueue#quickRemove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"quickRemove(int)");
    method.setSimpleName("quickRemove");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#quickRemove(int)
    // starting method java.util.TaskQueue#rescheduleMin(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"rescheduleMin(long)");
    method.setSimpleName("rescheduleMin");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#rescheduleMin(long)
    // starting method java.util.TaskQueue#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#isEmpty()
    // starting method java.util.TaskQueue#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#clear()
    // ignoring method java.util.TaskQueue#fixUp(int)
    // ignoring method java.util.TaskQueue#fixDown(int)
    // starting method java.util.TaskQueue#heapify()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"heapify()");
    method.setSimpleName("heapify");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TaskQueue#heapify()

// finishing type java.util.TaskQueue
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Timer$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Timer$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Timer");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Timer$1#this$0


    // starting method java.util.Timer$1#Timer$1(java.util.Timer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer$1(java.util.Timer)");
    method.setSimpleName("Timer$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer$1#Timer$1(java.util.Timer)
    // starting method java.util.Timer$1#finalize()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"finalize()");
    method.setSimpleName("finalize");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Throwable");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.Throwable
    
    // finishing method java.util.Timer$1#finalize()

// finishing type java.util.Timer$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Timer");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.Timer#queue 

// ignoring field java.util.Timer#thread 

// ignoring field java.util.Timer#threadReaper 

// ignoring field java.util.Timer#nextSerialNumber 


    // ignoring method java.util.Timer#serialNumber()
    // starting method java.util.Timer#Timer()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer()");
    method.setSimpleName("Timer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#Timer()
    // starting method java.util.Timer#Timer(boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer(boolean)");
    method.setSimpleName("Timer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#Timer(boolean)
    // starting method java.util.Timer#Timer(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer(java.lang.String)");
    method.setSimpleName("Timer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#Timer(java.lang.String)
    // starting method java.util.Timer#Timer(java.lang.String, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Timer(java.lang.String, boolean)");
    method.setSimpleName("Timer");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#Timer(java.lang.String, boolean)
    // starting method java.util.Timer#schedule(java.util.TimerTask, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"schedule(java.util.TimerTask, long)");
    method.setSimpleName("schedule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#schedule(java.util.TimerTask, long)
    // starting method java.util.Timer#schedule(java.util.TimerTask, java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"schedule(java.util.TimerTask, java.util.Date)");
    method.setSimpleName("schedule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#schedule(java.util.TimerTask, java.util.Date)
    // starting method java.util.Timer#schedule(java.util.TimerTask, long, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"schedule(java.util.TimerTask, long, long)");
    method.setSimpleName("schedule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#schedule(java.util.TimerTask, long, long)
    // starting method java.util.Timer#schedule(java.util.TimerTask, java.util.Date, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"schedule(java.util.TimerTask, java.util.Date, long)");
    method.setSimpleName("schedule");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#schedule(java.util.TimerTask, java.util.Date, long)
    // starting method java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, long, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"scheduleAtFixedRate(java.util.TimerTask, long, long)");
    method.setSimpleName("scheduleAtFixedRate");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, long, long)
    // starting method java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)");
    method.setSimpleName("scheduleAtFixedRate");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)
    // ignoring method java.util.Timer#sched(java.util.TimerTask, long, long)
    // starting method java.util.Timer#cancel()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"cancel()");
    method.setSimpleName("cancel");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#cancel()
    // starting method java.util.Timer#purge()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"purge()");
    method.setSimpleName("purge");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#purge()
    // starting method java.util.Timer#access$000(java.util.Timer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.Timer)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TaskQueue");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#access$000(java.util.Timer)
    // starting method java.util.Timer#access$100(java.util.Timer)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.Timer)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimerThread");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Timer#access$100(java.util.Timer)

// finishing type java.util.Timer
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimerTask");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Runnable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Runnable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Runnable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#lock
	field = newType.addNode(JavaDataField.class,"lock"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 16, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#lock

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#state
	field = newType.addNode(JavaDataField.class,"state"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#state

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#VIRGIN
	field = newType.addNode(JavaDataField.class,"VIRGIN"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#VIRGIN

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#SCHEDULED
	field = newType.addNode(JavaDataField.class,"SCHEDULED"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#SCHEDULED

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#EXECUTED
	field = newType.addNode(JavaDataField.class,"EXECUTED"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#EXECUTED

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#CANCELLED
	field = newType.addNode(JavaDataField.class,"CANCELLED"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#CANCELLED

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#nextExecutionTime
	field = newType.addNode(JavaDataField.class,"nextExecutionTime"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#nextExecutionTime

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerTask#period
	field = newType.addNode(JavaDataField.class,"period"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TimerTask#period


    // starting method java.util.TimerTask#TimerTask()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TimerTask()");
    method.setSimpleName("TimerTask");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerTask#TimerTask()
    // starting method java.util.TimerTask#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerTask#run()
    // starting method java.util.TimerTask#cancel()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"cancel()");
    method.setSimpleName("cancel");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerTask#cancel()
    // starting method java.util.TimerTask#scheduledExecutionTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"scheduledExecutionTime()");
    method.setSimpleName("scheduledExecutionTime");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerTask#scheduledExecutionTime()

// finishing type java.util.TimerTask
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimerThread");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Thread");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimerThread#newTasksMayBeScheduled
	field = newType.addNode(JavaDataField.class,"newTasksMayBeScheduled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TimerThread#newTasksMayBeScheduled

// ignoring field java.util.TimerThread#queue 


    // starting method java.util.TimerThread#TimerThread(java.util.TaskQueue)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TimerThread(java.util.TaskQueue)");
    method.setSimpleName("TimerThread");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerThread#TimerThread(java.util.TaskQueue)
    // starting method java.util.TimerThread#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimerThread#run()
    // ignoring method java.util.TimerThread#mainLoop()

// finishing type java.util.TimerThread
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface PrivilegedAction 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.security","PrivilegedAction");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface PrivilegedAction 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone$1#val$id
	field = newType.addNode(JavaDataField.class,"val$id"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TimeZone$1#val$id


    // starting method java.util.TimeZone$1#TimeZone$1(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TimeZone$1(java.lang.String)");
    method.setSimpleName("TimeZone$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone$1#TimeZone$1(java.lang.String)
    // starting method java.util.TimeZone$1#run()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"run()");
    method.setSimpleName("run");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone$1#run()

// finishing type java.util.TimeZone$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone$DisplayNames");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.TimeZone$DisplayNames#CACHE 


    // ignoring method java.util.TimeZone$DisplayNames#TimeZone$DisplayNames()
    // starting method java.util.TimeZone$DisplayNames#access$000()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000()");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone$DisplayNames#access$000()

// finishing type java.util.TimeZone$DisplayNames
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TimeZone");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#SHORT
	field = newType.addNode(JavaDataField.class,"SHORT"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#SHORT

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#LONG
	field = newType.addNode(JavaDataField.class,"LONG"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 25, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#LONG

// ignoring field java.util.TimeZone#ONE_MINUTE 

// ignoring field java.util.TimeZone#ONE_HOUR 

// ignoring field java.util.TimeZone#ONE_DAY 

// ignoring field java.util.TimeZone#cachedLocaleData 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#serialVersionUID
	field = newType.addNode(JavaDataField.class,"serialVersionUID"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","long");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#serialVersionUID

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#NO_TIMEZONE
	field = newType.addNode(JavaDataField.class,"NO_TIMEZONE"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#NO_TIMEZONE

// ignoring field java.util.TimeZone#ID 

// ignoring field java.util.TimeZone#defaultTimeZone 

// ignoring field java.util.TimeZone#defaultZoneTL 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#GMT_ID
	field = newType.addNode(JavaDataField.class,"GMT_ID"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    helper.insertFieldData(field, fieldType, 24, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#GMT_ID

// ignoring field java.util.TimeZone#GMT_ID_LENGTH 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TimeZone#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.TimeZone#$assertionsDisabled


    // starting method java.util.TimeZone#TimeZone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TimeZone()");
    method.setSimpleName("TimeZone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#TimeZone()
    // starting method java.util.TimeZone#getOffset(int, int, int, int, int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffset(int, int, int, int, int, int)");
    method.setSimpleName("getOffset");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getOffset(int, int, int, int, int, int)
    // starting method java.util.TimeZone#getOffset(long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffset(long)");
    method.setSimpleName("getOffset");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getOffset(long)
    // starting method java.util.TimeZone#getOffsets(long, int[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getOffsets(long, int[])");
    method.setSimpleName("getOffsets");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getOffsets(long, int[])
    // starting method java.util.TimeZone#setRawOffset(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setRawOffset(int)");
    method.setSimpleName("setRawOffset");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#setRawOffset(int)
    // starting method java.util.TimeZone#getRawOffset()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getRawOffset()");
    method.setSimpleName("getRawOffset");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getRawOffset()
    // starting method java.util.TimeZone#getID()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getID()");
    method.setSimpleName("getID");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getID()
    // starting method java.util.TimeZone#setID(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setID(java.lang.String)");
    method.setSimpleName("setID");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#setID(java.lang.String)
    // starting method java.util.TimeZone#getDisplayName()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName()");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDisplayName()
    // starting method java.util.TimeZone#getDisplayName(java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName(java.util.Locale)");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDisplayName(java.util.Locale)
    // starting method java.util.TimeZone#getDisplayName(boolean, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName(boolean, int)");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,17);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDisplayName(boolean, int)
    // starting method java.util.TimeZone#getDisplayName(boolean, int, java.util.Locale)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDisplayName(boolean, int, java.util.Locale)");
    method.setSimpleName("getDisplayName");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDisplayName(boolean, int, java.util.Locale)
    // ignoring method java.util.TimeZone#getDisplayNames(java.lang.String, java.util.Locale)
    // ignoring method java.util.TimeZone#retrieveDisplayNames(java.lang.String, java.util.Locale)
    // starting method java.util.TimeZone#getDSTSavings()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDSTSavings()");
    method.setSimpleName("getDSTSavings");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDSTSavings()
    // starting method java.util.TimeZone#useDaylightTime()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"useDaylightTime()");
    method.setSimpleName("useDaylightTime");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#useDaylightTime()
    // starting method java.util.TimeZone#inDaylightTime(java.util.Date)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"inDaylightTime(java.util.Date)");
    method.setSimpleName("inDaylightTime");
    helper.setMethodData(method,1025);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#inDaylightTime(java.util.Date)
    // starting method java.util.TimeZone#getTimeZone(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getTimeZone(java.lang.String)");
    method.setSimpleName("getTimeZone");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getTimeZone(java.lang.String)
    // ignoring method java.util.TimeZone#getTimeZone(java.lang.String, boolean)
    // starting method java.util.TimeZone#getAvailableIDs(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getAvailableIDs(int)");
    method.setSimpleName("getAvailableIDs");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getAvailableIDs(int)
    // starting method java.util.TimeZone#getAvailableIDs()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getAvailableIDs()");
    method.setSimpleName("getAvailableIDs");
    helper.setMethodData(method,41);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getAvailableIDs()
    // ignoring method java.util.TimeZone#getSystemTimeZoneID(java.lang.String, java.lang.String)
    // ignoring method java.util.TimeZone#getSystemGMTOffsetID()
    // starting method java.util.TimeZone#getDefault()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDefault()");
    method.setSimpleName("getDefault");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDefault()
    // starting method java.util.TimeZone#getDefaultRef()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getDefaultRef()");
    method.setSimpleName("getDefaultRef");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TimeZone");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#getDefaultRef()
    // ignoring method java.util.TimeZone#setDefaultZone()
    // ignoring method java.util.TimeZone#hasPermission()
    // starting method java.util.TimeZone#setDefault(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setDefault(java.util.TimeZone)");
    method.setSimpleName("setDefault");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#setDefault(java.util.TimeZone)
    // starting method java.util.TimeZone#hasSameRules(java.util.TimeZone)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasSameRules(java.util.TimeZone)");
    method.setSimpleName("hasSameRules");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#hasSameRules(java.util.TimeZone)
    // starting method java.util.TimeZone#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TimeZone#clone()
    // ignoring method java.util.TimeZone#parseCustomTimeZone(java.lang.String)

// finishing type java.util.TimeZone
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TooManyListenersException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Exception");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);


    // starting method java.util.TooManyListenersException#TooManyListenersException()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TooManyListenersException()");
    method.setSimpleName("TooManyListenersException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TooManyListenersException#TooManyListenersException()
    // starting method java.util.TooManyListenersException#TooManyListenersException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TooManyListenersException(java.lang.String)");
    method.setSimpleName("TooManyListenersException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TooManyListenersException#TooManyListenersException(java.lang.String)

// finishing type java.util.TooManyListenersException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$1#this$0


    // starting method java.util.TreeMap$1#TreeMap$1(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$1(java.util.TreeMap)");
    method.setSimpleName("TreeMap$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#TreeMap$1(java.util.TreeMap)
    // starting method java.util.TreeMap$1#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#iterator()
    // starting method java.util.TreeMap$1#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#size()
    // starting method java.util.TreeMap$1#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#contains(java.lang.Object)
    // starting method java.util.TreeMap$1#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#remove(java.lang.Object)
    // starting method java.util.TreeMap$1#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$1#clear()

// finishing type java.util.TreeMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$2");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$2#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$2#this$0


    // starting method java.util.TreeMap$2#TreeMap$2(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$2(java.util.TreeMap)");
    method.setSimpleName("TreeMap$2");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#TreeMap$2(java.util.TreeMap)
    // starting method java.util.TreeMap$2#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#iterator()
    // starting method java.util.TreeMap$2#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#size()
    // starting method java.util.TreeMap$2#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#contains(java.lang.Object)
    // starting method java.util.TreeMap$2#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#remove(java.lang.Object)
    // starting method java.util.TreeMap$2#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$2#clear()

// finishing type java.util.TreeMap$2
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$3");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$3#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$3#this$0


    // starting method java.util.TreeMap$3#TreeMap$3(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$3(java.util.TreeMap)");
    method.setSimpleName("TreeMap$3");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#TreeMap$3(java.util.TreeMap)
    // starting method java.util.TreeMap$3#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#iterator()
    // starting method java.util.TreeMap$3#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#contains(java.lang.Object)
    // starting method java.util.TreeMap$3#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#remove(java.lang.Object)
    // starting method java.util.TreeMap$3#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#size()
    // starting method java.util.TreeMap$3#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$3#clear()

// finishing type java.util.TreeMap$3
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#key
	field = newType.addNode(JavaDataField.class,"key"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#key

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#value
	field = newType.addNode(JavaDataField.class,"value"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#value

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#left
	field = newType.addNode(JavaDataField.class,"left"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#left

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#right
	field = newType.addNode(JavaDataField.class,"right"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#right

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#parent
	field = newType.addNode(JavaDataField.class,"parent"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#parent

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$Entry#color
	field = newType.addNode(JavaDataField.class,"color"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$Entry#color


    // starting method java.util.TreeMap$Entry#TreeMap$Entry(java.lang.Object, java.lang.Object, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$Entry(java.lang.Object, java.lang.Object, java.util.TreeMap$Entry)");
    method.setSimpleName("TreeMap$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#TreeMap$Entry(java.lang.Object, java.lang.Object, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#getKey()
    // starting method java.util.TreeMap$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#getValue()
    // starting method java.util.TreeMap$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#setValue(java.lang.Object)
    // starting method java.util.TreeMap$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#equals(java.lang.Object)
    // starting method java.util.TreeMap$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#hashCode()
    // starting method java.util.TreeMap$Entry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$Entry#toString()

// finishing type java.util.TreeMap$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TreeMap$PrivateEntryIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$EntryIterator#this$0


    // ignoring method java.util.TreeMap$EntryIterator#TreeMap$EntryIterator(java.util.TreeMap)
    // starting method java.util.TreeMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$EntryIterator#next()
    // starting method java.util.TreeMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$EntryIterator#next()
    // starting method java.util.TreeMap$EntryIterator#TreeMap$EntryIterator(java.util.TreeMap, java.util.TreeMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$EntryIterator(java.util.TreeMap, java.util.TreeMap$1)");
    method.setSimpleName("TreeMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$EntryIterator#TreeMap$EntryIterator(java.util.TreeMap, java.util.TreeMap$1)

// finishing type java.util.TreeMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TreeMap$PrivateEntryIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$KeyIterator#this$0


    // ignoring method java.util.TreeMap$KeyIterator#TreeMap$KeyIterator(java.util.TreeMap)
    // starting method java.util.TreeMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$KeyIterator#next()
    // starting method java.util.TreeMap$KeyIterator#TreeMap$KeyIterator(java.util.TreeMap, java.util.TreeMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$KeyIterator(java.util.TreeMap, java.util.TreeMap$1)");
    method.setSimpleName("TreeMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$KeyIterator#TreeMap$KeyIterator(java.util.TreeMap, java.util.TreeMap$1)

// finishing type java.util.TreeMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$PrivateEntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

// ignoring field java.util.TreeMap$PrivateEntryIterator#expectedModCount 

// ignoring field java.util.TreeMap$PrivateEntryIterator#lastReturned 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$PrivateEntryIterator#next
	field = newType.addNode(JavaDataField.class,"next"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$PrivateEntryIterator#next

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$PrivateEntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$PrivateEntryIterator#this$0


    // starting method java.util.TreeMap$PrivateEntryIterator#TreeMap$PrivateEntryIterator(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$PrivateEntryIterator(java.util.TreeMap)");
    method.setSimpleName("TreeMap$PrivateEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#TreeMap$PrivateEntryIterator(java.util.TreeMap)
    // starting method java.util.TreeMap$PrivateEntryIterator#TreeMap$PrivateEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$PrivateEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry)");
    method.setSimpleName("TreeMap$PrivateEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#TreeMap$PrivateEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap$PrivateEntryIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#hasNext()
    // starting method java.util.TreeMap$PrivateEntryIterator#nextEntry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextEntry()");
    method.setSimpleName("nextEntry");
    helper.setMethodData(method,16);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#nextEntry()
    // starting method java.util.TreeMap$PrivateEntryIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$PrivateEntryIterator#remove()

// finishing type java.util.TreeMap$PrivateEntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMap$EntrySetView");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.TreeMap$SubMap$EntrySetView#size 

// ignoring field java.util.TreeMap$SubMap$EntrySetView#sizeModCount 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$SubMap$EntrySetView#this$1
	field = newType.addNode(JavaDataField.class,"this$1"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$SubMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$SubMap$EntrySetView#this$1


    // ignoring method java.util.TreeMap$SubMap$EntrySetView#TreeMap$SubMap$EntrySetView(java.util.TreeMap$SubMap)
    // starting method java.util.TreeMap$SubMap$EntrySetView#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#size()
    // starting method java.util.TreeMap$SubMap$EntrySetView#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#isEmpty()
    // starting method java.util.TreeMap$SubMap$EntrySetView#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#contains(java.lang.Object)
    // starting method java.util.TreeMap$SubMap$EntrySetView#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#remove(java.lang.Object)
    // starting method java.util.TreeMap$SubMap$EntrySetView#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#iterator()
    // starting method java.util.TreeMap$SubMap$EntrySetView#TreeMap$SubMap$EntrySetView(java.util.TreeMap$SubMap, java.util.TreeMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMap$EntrySetView(java.util.TreeMap$SubMap, java.util.TreeMap$1)");
    method.setSimpleName("TreeMap$SubMap$EntrySetView");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap$EntrySetView#TreeMap$SubMap$EntrySetView(java.util.TreeMap$SubMap, java.util.TreeMap$1)

// finishing type java.util.TreeMap$SubMap$EntrySetView
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.TreeMap$SubMap#serialVersionUID 

// ignoring field java.util.TreeMap$SubMap#fromStart 

// ignoring field java.util.TreeMap$SubMap#toEnd 

// ignoring field java.util.TreeMap$SubMap#fromKey 

// ignoring field java.util.TreeMap$SubMap#toKey 

// ignoring field java.util.TreeMap$SubMap#entrySet 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$SubMap#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$SubMap#this$0


    // starting method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMap(java.util.TreeMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("TreeMap$SubMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, java.lang.Object, boolean)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMap(java.util.TreeMap, java.lang.Object, boolean)");
    method.setSimpleName("TreeMap$SubMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, java.lang.Object, boolean)
    // starting method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, boolean, java.lang.Object, boolean, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMap(java.util.TreeMap, boolean, java.lang.Object, boolean, java.lang.Object)");
    method.setSimpleName("TreeMap$SubMap");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#TreeMap$SubMap(java.util.TreeMap, boolean, java.lang.Object, boolean, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#isEmpty()
    // starting method java.util.TreeMap$SubMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#containsKey(java.lang.Object)
    // starting method java.util.TreeMap$SubMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#get(java.lang.Object)
    // starting method java.util.TreeMap$SubMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#comparator()
    // starting method java.util.TreeMap$SubMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#firstKey()
    // starting method java.util.TreeMap$SubMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#lastKey()
    // starting method java.util.TreeMap$SubMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#entrySet()
    // starting method java.util.TreeMap$SubMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#headMap(java.lang.Object)
    // starting method java.util.TreeMap$SubMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#tailMap(java.lang.Object)
    // ignoring method java.util.TreeMap$SubMap#inRange(java.lang.Object)
    // ignoring method java.util.TreeMap$SubMap#inRange2(java.lang.Object)
    // starting method java.util.TreeMap$SubMap#access$1700(java.util.TreeMap$SubMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1700(java.util.TreeMap$SubMap, java.lang.Object)");
    method.setSimpleName("access$1700");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$1700(java.util.TreeMap$SubMap, java.lang.Object)
    // starting method java.util.TreeMap$SubMap#access$1800(java.util.TreeMap$SubMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1800(java.util.TreeMap$SubMap)");
    method.setSimpleName("access$1800");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$1800(java.util.TreeMap$SubMap)
    // starting method java.util.TreeMap$SubMap#access$1900(java.util.TreeMap$SubMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1900(java.util.TreeMap$SubMap)");
    method.setSimpleName("access$1900");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$1900(java.util.TreeMap$SubMap)
    // starting method java.util.TreeMap$SubMap#access$2000(java.util.TreeMap$SubMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$2000(java.util.TreeMap$SubMap)");
    method.setSimpleName("access$2000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$2000(java.util.TreeMap$SubMap)
    // starting method java.util.TreeMap$SubMap#access$2100(java.util.TreeMap$SubMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$2100(java.util.TreeMap$SubMap)");
    method.setSimpleName("access$2100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMap#access$2100(java.util.TreeMap$SubMap)

// finishing type java.util.TreeMap$SubMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$SubMapEntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TreeMap$PrivateEntryIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.TreeMap$SubMapEntryIterator#firstExcludedKey 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$SubMapEntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$SubMapEntryIterator#this$0


    // starting method java.util.TreeMap$SubMapEntryIterator#TreeMap$SubMapEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$SubMapEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry, java.util.TreeMap$Entry)");
    method.setSimpleName("TreeMap$SubMapEntryIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMapEntryIterator#TreeMap$SubMapEntryIterator(java.util.TreeMap, java.util.TreeMap$Entry, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap$SubMapEntryIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMapEntryIterator#hasNext()
    // starting method java.util.TreeMap$SubMapEntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMapEntryIterator#next()
    // starting method java.util.TreeMap$SubMapEntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$SubMapEntryIterator#next()

// finishing type java.util.TreeMap$SubMapEntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","TreeMap$PrivateEntryIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.TreeMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.TreeMap$ValueIterator#this$0


    // ignoring method java.util.TreeMap$ValueIterator#TreeMap$ValueIterator(java.util.TreeMap)
    // starting method java.util.TreeMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$ValueIterator#next()
    // starting method java.util.TreeMap$ValueIterator#TreeMap$ValueIterator(java.util.TreeMap, java.util.TreeMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap$ValueIterator(java.util.TreeMap, java.util.TreeMap$1)");
    method.setSimpleName("TreeMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap$ValueIterator#TreeMap$ValueIterator(java.util.TreeMap, java.util.TreeMap$1)

// finishing type java.util.TreeMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedMap 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedMap");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedMap 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.TreeMap#comparator 

// ignoring field java.util.TreeMap#root 

// ignoring field java.util.TreeMap#size 

// ignoring field java.util.TreeMap#modCount 

// ignoring field java.util.TreeMap#entrySet 

// ignoring field java.util.TreeMap#RED 

// ignoring field java.util.TreeMap#BLACK 

// ignoring field java.util.TreeMap#serialVersionUID 


    // ignoring method java.util.TreeMap#incrementSize()
    // ignoring method java.util.TreeMap#decrementSize()
    // starting method java.util.TreeMap#TreeMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap()");
    method.setSimpleName("TreeMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#TreeMap()
    // starting method java.util.TreeMap#TreeMap(java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap(java.util.Comparator)");
    method.setSimpleName("TreeMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#TreeMap(java.util.Comparator)
    // starting method java.util.TreeMap#TreeMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap(java.util.Map)");
    method.setSimpleName("TreeMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#TreeMap(java.util.Map)
    // starting method java.util.TreeMap#TreeMap(java.util.SortedMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeMap(java.util.SortedMap)");
    method.setSimpleName("TreeMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#TreeMap(java.util.SortedMap)
    // starting method java.util.TreeMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#size()
    // starting method java.util.TreeMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#containsKey(java.lang.Object)
    // starting method java.util.TreeMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#containsValue(java.lang.Object)
    // ignoring method java.util.TreeMap#valueSearchNull(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#valueSearchNonNull(java.util.TreeMap$Entry, java.lang.Object)
    // starting method java.util.TreeMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#get(java.lang.Object)
    // starting method java.util.TreeMap#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#comparator()
    // starting method java.util.TreeMap#firstKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstKey()");
    method.setSimpleName("firstKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#firstKey()
    // starting method java.util.TreeMap#lastKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastKey()");
    method.setSimpleName("lastKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#lastKey()
    // starting method java.util.TreeMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#putAll(java.util.Map)
    // ignoring method java.util.TreeMap#getEntry(java.lang.Object)
    // ignoring method java.util.TreeMap#getCeilEntry(java.lang.Object)
    // ignoring method java.util.TreeMap#getPrecedingEntry(java.lang.Object)
    // ignoring method java.util.TreeMap#key(java.util.TreeMap$Entry)
    // starting method java.util.TreeMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#remove(java.lang.Object)
    // starting method java.util.TreeMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#clear()
    // starting method java.util.TreeMap#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#clone()
    // starting method java.util.TreeMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#keySet()
    // starting method java.util.TreeMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#values()
    // starting method java.util.TreeMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#entrySet()
    // starting method java.util.TreeMap#subMap(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subMap(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#subMap(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap#headMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headMap(java.lang.Object)");
    method.setSimpleName("headMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#headMap(java.lang.Object)
    // starting method java.util.TreeMap#tailMap(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailMap(java.lang.Object)");
    method.setSimpleName("tailMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedMap");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#tailMap(java.lang.Object)
    // ignoring method java.util.TreeMap#compare(java.lang.Object, java.lang.Object)
    // ignoring method java.util.TreeMap#valEquals(java.lang.Object, java.lang.Object)
    // ignoring method java.util.TreeMap#firstEntry()
    // ignoring method java.util.TreeMap#lastEntry()
    // ignoring method java.util.TreeMap#successor(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#colorOf(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#parentOf(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#setColor(java.util.TreeMap$Entry, boolean)
    // ignoring method java.util.TreeMap#leftOf(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#rightOf(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#rotateLeft(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#rotateRight(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#fixAfterInsertion(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#deleteEntry(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#fixAfterDeletion(java.util.TreeMap$Entry)
    // ignoring method java.util.TreeMap#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.TreeMap#readObject(java.io.ObjectInputStream)
    // starting method java.util.TreeMap#readTreeSet(int, java.io.ObjectInputStream, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"readTreeSet(int, java.io.ObjectInputStream, java.lang.Object)");
    method.setSimpleName("readTreeSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","ClassNotFoundException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.lang.ClassNotFoundException
    
    // finishing method java.util.TreeMap#readTreeSet(int, java.io.ObjectInputStream, java.lang.Object)
    // starting method java.util.TreeMap#addAllForTreeSet(java.util.SortedSet, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAllForTreeSet(java.util.SortedSet, java.lang.Object)");
    method.setSimpleName("addAllForTreeSet");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#addAllForTreeSet(java.util.SortedSet, java.lang.Object)
    // ignoring method java.util.TreeMap#buildFromSorted(int, java.util.Iterator, java.io.ObjectInputStream, java.lang.Object)
    // ignoring method java.util.TreeMap#buildFromSorted(int, int, int, int, java.util.Iterator, java.io.ObjectInputStream, java.lang.Object)
    // ignoring method java.util.TreeMap#computeRedLevel(int)
    // starting method java.util.TreeMap#access$100(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.TreeMap)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$100(java.util.TreeMap)
    // starting method java.util.TreeMap#access$300(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.util.TreeMap)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$300(java.util.TreeMap)
    // starting method java.util.TreeMap#access$400(java.util.TreeMap, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.TreeMap, java.util.TreeMap$Entry)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$400(java.util.TreeMap, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap#access$500(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$500(java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$500");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$500(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap#access$600(java.util.TreeMap, java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$600(java.util.TreeMap, java.util.TreeMap$Entry)");
    method.setSimpleName("access$600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$600(java.util.TreeMap, java.util.TreeMap$Entry)
    // starting method java.util.TreeMap#access$800(java.util.TreeMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$800(java.util.TreeMap, java.lang.Object)");
    method.setSimpleName("access$800");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$800(java.util.TreeMap, java.lang.Object)
    // starting method java.util.TreeMap#access$900(java.util.TreeMap, java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$900(java.util.TreeMap, java.lang.Object, java.lang.Object)");
    method.setSimpleName("access$900");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$900(java.util.TreeMap, java.lang.Object, java.lang.Object)
    // starting method java.util.TreeMap#access$1000(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1000(java.util.TreeMap)");
    method.setSimpleName("access$1000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1000(java.util.TreeMap)
    // starting method java.util.TreeMap#access$1100(java.util.TreeMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1100(java.util.TreeMap, java.lang.Object)");
    method.setSimpleName("access$1100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1100(java.util.TreeMap, java.lang.Object)
    // starting method java.util.TreeMap#access$1200(java.util.TreeMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1200(java.util.TreeMap$Entry)");
    method.setSimpleName("access$1200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1200(java.util.TreeMap$Entry)
    // starting method java.util.TreeMap#access$1300(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1300(java.util.TreeMap)");
    method.setSimpleName("access$1300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1300(java.util.TreeMap)
    // starting method java.util.TreeMap#access$1400(java.util.TreeMap, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1400(java.util.TreeMap, java.lang.Object)");
    method.setSimpleName("access$1400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","TreeMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1400(java.util.TreeMap, java.lang.Object)
    // starting method java.util.TreeMap#access$1600(java.util.TreeMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$1600(java.util.TreeMap)");
    method.setSimpleName("access$1600");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeMap#access$1600(java.util.TreeMap)

// finishing type java.util.TreeMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "TreeSet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface SortedSet 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","SortedSet");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface SortedSet 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

// ignoring field java.util.TreeSet#m 

// ignoring field java.util.TreeSet#keySet 

// ignoring field java.util.TreeSet#PRESENT 

// ignoring field java.util.TreeSet#serialVersionUID 


    // ignoring method java.util.TreeSet#TreeSet(java.util.SortedMap)
    // starting method java.util.TreeSet#TreeSet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeSet()");
    method.setSimpleName("TreeSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#TreeSet()
    // starting method java.util.TreeSet#TreeSet(java.util.Comparator)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeSet(java.util.Comparator)");
    method.setSimpleName("TreeSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#TreeSet(java.util.Comparator)
    // starting method java.util.TreeSet#TreeSet(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeSet(java.util.Collection)");
    method.setSimpleName("TreeSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#TreeSet(java.util.Collection)
    // starting method java.util.TreeSet#TreeSet(java.util.SortedSet)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"TreeSet(java.util.SortedSet)");
    method.setSimpleName("TreeSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#TreeSet(java.util.SortedSet)
    // starting method java.util.TreeSet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#iterator()
    // starting method java.util.TreeSet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#size()
    // starting method java.util.TreeSet#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#isEmpty()
    // starting method java.util.TreeSet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#contains(java.lang.Object)
    // starting method java.util.TreeSet#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#add(java.lang.Object)
    // starting method java.util.TreeSet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#remove(java.lang.Object)
    // starting method java.util.TreeSet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#clear()
    // starting method java.util.TreeSet#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#addAll(java.util.Collection)
    // starting method java.util.TreeSet#subSet(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subSet(java.lang.Object, java.lang.Object)");
    method.setSimpleName("subSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#subSet(java.lang.Object, java.lang.Object)
    // starting method java.util.TreeSet#headSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"headSet(java.lang.Object)");
    method.setSimpleName("headSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#headSet(java.lang.Object)
    // starting method java.util.TreeSet#tailSet(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"tailSet(java.lang.Object)");
    method.setSimpleName("tailSet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","SortedSet");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#tailSet(java.lang.Object)
    // starting method java.util.TreeSet#comparator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"comparator()");
    method.setSimpleName("comparator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Comparator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#comparator()
    // starting method java.util.TreeSet#first()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"first()");
    method.setSimpleName("first");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#first()
    // starting method java.util.TreeSet#last()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"last()");
    method.setSimpleName("last");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#last()
    // starting method java.util.TreeSet#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.TreeSet#clone()
    // ignoring method java.util.TreeSet#writeObject(java.io.ObjectOutputStream)
    // ignoring method java.util.TreeSet#readObject(java.io.ObjectInputStream)

// finishing type java.util.TreeSet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "UnknownFormatConversionException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.UnknownFormatConversionException#serialVersionUID 

// ignoring field java.util.UnknownFormatConversionException#s 


    // starting method java.util.UnknownFormatConversionException#UnknownFormatConversionException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"UnknownFormatConversionException(java.lang.String)");
    method.setSimpleName("UnknownFormatConversionException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatConversionException#UnknownFormatConversionException(java.lang.String)
    // starting method java.util.UnknownFormatConversionException#getConversion()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getConversion()");
    method.setSimpleName("getConversion");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatConversionException#getConversion()
    // starting method java.util.UnknownFormatConversionException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatConversionException#getMessage()

// finishing type java.util.UnknownFormatConversionException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "UnknownFormatFlagsException");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","IllegalFormatException");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.UnknownFormatFlagsException#serialVersionUID 

// ignoring field java.util.UnknownFormatFlagsException#flags 


    // starting method java.util.UnknownFormatFlagsException#UnknownFormatFlagsException(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"UnknownFormatFlagsException(java.lang.String)");
    method.setSimpleName("UnknownFormatFlagsException");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatFlagsException#UnknownFormatFlagsException(java.lang.String)
    // starting method java.util.UnknownFormatFlagsException#getFlags()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getFlags()");
    method.setSimpleName("getFlags");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatFlagsException#getFlags()
    // starting method java.util.UnknownFormatFlagsException#getMessage()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMessage()");
    method.setSimpleName("getMessage");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UnknownFormatFlagsException#getMessage()

// finishing type java.util.UnknownFormatFlagsException
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "UUID");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 
    // starting interface Comparable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Comparable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Comparable 

// ignoring field java.util.UUID#serialVersionUID 

// ignoring field java.util.UUID#mostSigBits 

// ignoring field java.util.UUID#leastSigBits 

// ignoring field java.util.UUID#version 

// ignoring field java.util.UUID#variant 

// ignoring field java.util.UUID#timestamp 

// ignoring field java.util.UUID#sequence 

// ignoring field java.util.UUID#node 

// ignoring field java.util.UUID#hashCode 

// ignoring field java.util.UUID#numberGenerator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.UUID#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.UUID#$assertionsDisabled


    // ignoring method java.util.UUID#UUID(byte[])
    // starting method java.util.UUID#UUID(long, long)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"UUID(long, long)");
    method.setSimpleName("UUID");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#UUID(long, long)
    // starting method java.util.UUID#randomUUID()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"randomUUID()");
    method.setSimpleName("randomUUID");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","UUID");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#randomUUID()
    // starting method java.util.UUID#nameUUIDFromBytes(byte[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nameUUIDFromBytes(byte[])");
    method.setSimpleName("nameUUIDFromBytes");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","UUID");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#nameUUIDFromBytes(byte[])
    // starting method java.util.UUID#fromString(java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fromString(java.lang.String)");
    method.setSimpleName("fromString");
    helper.setMethodData(method,9);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","UUID");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#fromString(java.lang.String)
    // starting method java.util.UUID#getLeastSignificantBits()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLeastSignificantBits()");
    method.setSimpleName("getLeastSignificantBits");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#getLeastSignificantBits()
    // starting method java.util.UUID#getMostSignificantBits()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getMostSignificantBits()");
    method.setSimpleName("getMostSignificantBits");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#getMostSignificantBits()
    // starting method java.util.UUID#version()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"version()");
    method.setSimpleName("version");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#version()
    // starting method java.util.UUID#variant()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"variant()");
    method.setSimpleName("variant");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#variant()
    // starting method java.util.UUID#timestamp()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"timestamp()");
    method.setSimpleName("timestamp");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#timestamp()
    // starting method java.util.UUID#clockSequence()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clockSequence()");
    method.setSimpleName("clockSequence");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#clockSequence()
    // starting method java.util.UUID#node()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"node()");
    method.setSimpleName("node");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "long");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#node()
    // starting method java.util.UUID#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#toString()
    // ignoring method java.util.UUID#digits(long, int)
    // starting method java.util.UUID#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#hashCode()
    // starting method java.util.UUID#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#equals(java.lang.Object)
    // starting method java.util.UUID#compareTo(java.util.UUID)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.util.UUID)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#compareTo(java.util.UUID)
    // ignoring method java.util.UUID#readObject(java.io.ObjectInputStream)
    // starting method java.util.UUID#compareTo(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"compareTo(java.lang.Object)");
    method.setSimpleName("compareTo");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.UUID#compareTo(java.lang.Object)

// finishing type java.util.UUID
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Vector$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Enumeration 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Enumeration");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Enumeration 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector$1#count
	field = newType.addNode(JavaDataField.class,"count"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.Vector$1#count

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector$1#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Vector");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.Vector$1#this$0


    // starting method java.util.Vector$1#Vector$1(java.util.Vector)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector$1(java.util.Vector)");
    method.setSimpleName("Vector$1");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector$1#Vector$1(java.util.Vector)
    // starting method java.util.Vector$1#hasMoreElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasMoreElements()");
    method.setSimpleName("hasMoreElements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector$1#hasMoreElements()
    // starting method java.util.Vector$1#nextElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextElement()");
    method.setSimpleName("nextElement");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector$1#nextElement()

// finishing type java.util.Vector$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "Vector");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractList");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface List 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","List");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface List 
    // starting interface RandomAccess 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","RandomAccess");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface RandomAccess 
    // starting interface Cloneable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Cloneable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Cloneable 
    // starting interface Serializable 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.io","Serializable");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Serializable 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector#elementData
	field = newType.addNode(JavaDataField.class,"elementData"); 
    //field needs to be processed: ArrayTypeReference
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Vector#elementData

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector#elementCount
	field = newType.addNode(JavaDataField.class,"elementCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Vector#elementCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.Vector#capacityIncrement
	field = newType.addNode(JavaDataField.class,"capacityIncrement"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 4, isArray, arrayDimensions);
    // finishing field java.util.Vector#capacityIncrement

// ignoring field java.util.Vector#serialVersionUID 


    // starting method java.util.Vector#Vector(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector(int, int)");
    method.setSimpleName("Vector");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#Vector(int, int)
    // starting method java.util.Vector#Vector(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector(int)");
    method.setSimpleName("Vector");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#Vector(int)
    // starting method java.util.Vector#Vector()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector()");
    method.setSimpleName("Vector");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#Vector()
    // starting method java.util.Vector#Vector(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"Vector(java.util.Collection)");
    method.setSimpleName("Vector");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#Vector(java.util.Collection)
    // starting method java.util.Vector#copyInto(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"copyInto(java.lang.Object[])");
    method.setSimpleName("copyInto");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#copyInto(java.lang.Object[])
    // starting method java.util.Vector#trimToSize()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"trimToSize()");
    method.setSimpleName("trimToSize");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#trimToSize()
    // starting method java.util.Vector#ensureCapacity(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"ensureCapacity(int)");
    method.setSimpleName("ensureCapacity");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#ensureCapacity(int)
    // ignoring method java.util.Vector#ensureCapacityHelper(int)
    // starting method java.util.Vector#setSize(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setSize(int)");
    method.setSimpleName("setSize");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#setSize(int)
    // starting method java.util.Vector#capacity()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"capacity()");
    method.setSimpleName("capacity");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#capacity()
    // starting method java.util.Vector#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#size()
    // starting method java.util.Vector#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#isEmpty()
    // starting method java.util.Vector#elements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elements()");
    method.setSimpleName("elements");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Enumeration");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#elements()
    // starting method java.util.Vector#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#contains(java.lang.Object)
    // starting method java.util.Vector#indexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#indexOf(java.lang.Object)
    // starting method java.util.Vector#indexOf(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexOf(java.lang.Object, int)");
    method.setSimpleName("indexOf");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#indexOf(java.lang.Object, int)
    // starting method java.util.Vector#lastIndexOf(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#lastIndexOf(java.lang.Object)
    // starting method java.util.Vector#lastIndexOf(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastIndexOf(java.lang.Object, int)");
    method.setSimpleName("lastIndexOf");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#lastIndexOf(java.lang.Object, int)
    // starting method java.util.Vector#elementAt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"elementAt(int)");
    method.setSimpleName("elementAt");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#elementAt(int)
    // starting method java.util.Vector#firstElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"firstElement()");
    method.setSimpleName("firstElement");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#firstElement()
    // starting method java.util.Vector#lastElement()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"lastElement()");
    method.setSimpleName("lastElement");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#lastElement()
    // starting method java.util.Vector#setElementAt(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setElementAt(java.lang.Object, int)");
    method.setSimpleName("setElementAt");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#setElementAt(java.lang.Object, int)
    // starting method java.util.Vector#removeElementAt(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeElementAt(int)");
    method.setSimpleName("removeElementAt");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeElementAt(int)
    // starting method java.util.Vector#insertElementAt(java.lang.Object, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"insertElementAt(java.lang.Object, int)");
    method.setSimpleName("insertElementAt");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#insertElementAt(java.lang.Object, int)
    // starting method java.util.Vector#addElement(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addElement(java.lang.Object)");
    method.setSimpleName("addElement");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#addElement(java.lang.Object)
    // starting method java.util.Vector#removeElement(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeElement(java.lang.Object)");
    method.setSimpleName("removeElement");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeElement(java.lang.Object)
    // starting method java.util.Vector#removeAllElements()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAllElements()");
    method.setSimpleName("removeAllElements");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeAllElements()
    // starting method java.util.Vector#clone()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clone()");
    method.setSimpleName("clone");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#clone()
    // starting method java.util.Vector#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#toArray()
    // starting method java.util.Vector#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#toArray(java.lang.Object[])
    // starting method java.util.Vector#get(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(int)");
    method.setSimpleName("get");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#get(int)
    // starting method java.util.Vector#set(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"set(int, java.lang.Object)");
    method.setSimpleName("set");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#set(int, java.lang.Object)
    // starting method java.util.Vector#add(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#add(java.lang.Object)
    // starting method java.util.Vector#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#remove(java.lang.Object)
    // starting method java.util.Vector#add(int, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"add(int, java.lang.Object)");
    method.setSimpleName("add");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#add(int, java.lang.Object)
    // starting method java.util.Vector#remove(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(int)");
    method.setSimpleName("remove");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#remove(int)
    // starting method java.util.Vector#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#clear()
    // starting method java.util.Vector#containsAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsAll(java.util.Collection)");
    method.setSimpleName("containsAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#containsAll(java.util.Collection)
    // starting method java.util.Vector#addAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#addAll(java.util.Collection)
    // starting method java.util.Vector#removeAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeAll(java.util.Collection)");
    method.setSimpleName("removeAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeAll(java.util.Collection)
    // starting method java.util.Vector#retainAll(java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"retainAll(java.util.Collection)");
    method.setSimpleName("retainAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#retainAll(java.util.Collection)
    // starting method java.util.Vector#addAll(int, java.util.Collection)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"addAll(int, java.util.Collection)");
    method.setSimpleName("addAll");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#addAll(int, java.util.Collection)
    // starting method java.util.Vector#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#equals(java.lang.Object)
    // starting method java.util.Vector#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#hashCode()
    // starting method java.util.Vector#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#toString()
    // starting method java.util.Vector#subList(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"subList(int, int)");
    method.setSimpleName("subList");
    helper.setMethodData(method,33);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","List");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#subList(int, int)
    // starting method java.util.Vector#removeRange(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeRange(int, int)");
    method.setSimpleName("removeRange");
    helper.setMethodData(method,36);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.Vector#removeRange(int, int)
    // ignoring method java.util.Vector#writeObject(java.io.ObjectOutputStream)

// finishing type java.util.Vector
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.WeakHashMap$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$Entry");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang.ref","WeakReference");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map$Entry 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map$Entry");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map$Entry 

// ignoring field java.util.WeakHashMap$Entry#value 

// ignoring field java.util.WeakHashMap$Entry#hash 

// ignoring field java.util.WeakHashMap$Entry#next 


    // starting method java.util.WeakHashMap$Entry#WeakHashMap$Entry(java.lang.Object, java.lang.Object, java.lang.ref.ReferenceQueue, int, java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$Entry(java.lang.Object, java.lang.Object, java.lang.ref.ReferenceQueue, int, java.util.WeakHashMap$Entry)");
    method.setSimpleName("WeakHashMap$Entry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#WeakHashMap$Entry(java.lang.Object, java.lang.Object, java.lang.ref.ReferenceQueue, int, java.util.WeakHashMap$Entry)
    // starting method java.util.WeakHashMap$Entry#getKey()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getKey()");
    method.setSimpleName("getKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#getKey()
    // starting method java.util.WeakHashMap$Entry#getValue()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getValue()");
    method.setSimpleName("getValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#getValue()
    // starting method java.util.WeakHashMap$Entry#setValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"setValue(java.lang.Object)");
    method.setSimpleName("setValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#setValue(java.lang.Object)
    // starting method java.util.WeakHashMap$Entry#equals(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"equals(java.lang.Object)");
    method.setSimpleName("equals");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#equals(java.lang.Object)
    // starting method java.util.WeakHashMap$Entry#hashCode()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hashCode()");
    method.setSimpleName("hashCode");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#hashCode()
    // starting method java.util.WeakHashMap$Entry#toString()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toString()");
    method.setSimpleName("toString");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","String");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#toString()
    // starting method java.util.WeakHashMap$Entry#access$000(java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$000(java.util.WeakHashMap$Entry)");
    method.setSimpleName("access$000");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$000(java.util.WeakHashMap$Entry)
    // starting method java.util.WeakHashMap$Entry#access$100(java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$100(java.util.WeakHashMap$Entry)");
    method.setSimpleName("access$100");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$100(java.util.WeakHashMap$Entry)
    // starting method java.util.WeakHashMap$Entry#access$102(java.util.WeakHashMap$Entry, java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$102(java.util.WeakHashMap$Entry, java.util.WeakHashMap$Entry)");
    method.setSimpleName("access$102");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$102(java.util.WeakHashMap$Entry, java.util.WeakHashMap$Entry)
    // starting method java.util.WeakHashMap$Entry#access$202(java.util.WeakHashMap$Entry, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$202(java.util.WeakHashMap$Entry, java.lang.Object)");
    method.setSimpleName("access$202");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$202(java.util.WeakHashMap$Entry, java.lang.Object)
    // starting method java.util.WeakHashMap$Entry#access$200(java.util.WeakHashMap$Entry)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$200(java.util.WeakHashMap$Entry)");
    method.setSimpleName("access$200");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Entry#access$200(java.util.WeakHashMap$Entry)

// finishing type java.util.WeakHashMap$Entry
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$EntryIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","WeakHashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$EntryIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$EntryIterator#this$0


    // ignoring method java.util.WeakHashMap$EntryIterator#WeakHashMap$EntryIterator(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Map$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntryIterator#next()
    // starting method java.util.WeakHashMap$EntryIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,4161);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntryIterator#next()
    // starting method java.util.WeakHashMap$EntryIterator#WeakHashMap$EntryIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$EntryIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$EntryIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntryIterator#WeakHashMap$EntryIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$EntryIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$EntrySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$EntrySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$EntrySet#this$0


    // ignoring method java.util.WeakHashMap$EntrySet#WeakHashMap$EntrySet(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$EntrySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#iterator()
    // starting method java.util.WeakHashMap$EntrySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#contains(java.lang.Object)
    // starting method java.util.WeakHashMap$EntrySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#remove(java.lang.Object)
    // starting method java.util.WeakHashMap$EntrySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#size()
    // starting method java.util.WeakHashMap$EntrySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#clear()
    // starting method java.util.WeakHashMap$EntrySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#toArray()
    // starting method java.util.WeakHashMap$EntrySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#toArray(java.lang.Object[])
    // starting method java.util.WeakHashMap$EntrySet#WeakHashMap$EntrySet(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$EntrySet(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$EntrySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$EntrySet#WeakHashMap$EntrySet(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$EntrySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$HashIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Iterator 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Iterator");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Iterator 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#index
	field = newType.addNode(JavaDataField.class,"index"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#index

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#entry
	field = newType.addNode(JavaDataField.class,"entry"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#entry

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#lastReturned
	field = newType.addNode(JavaDataField.class,"lastReturned"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#lastReturned

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#expectedModCount
	field = newType.addNode(JavaDataField.class,"expectedModCount"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","int");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#expectedModCount

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#nextKey
	field = newType.addNode(JavaDataField.class,"nextKey"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#nextKey

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#currentKey
	field = newType.addNode(JavaDataField.class,"currentKey"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    helper.insertFieldData(field, fieldType, 0, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#currentKey

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$HashIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$HashIterator#this$0


    // starting method java.util.WeakHashMap$HashIterator#WeakHashMap$HashIterator(java.util.WeakHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$HashIterator(java.util.WeakHashMap)");
    method.setSimpleName("WeakHashMap$HashIterator");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$HashIterator#WeakHashMap$HashIterator(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$HashIterator#hasNext()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"hasNext()");
    method.setSimpleName("hasNext");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$HashIterator#hasNext()
    // starting method java.util.WeakHashMap$HashIterator#nextEntry()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"nextEntry()");
    method.setSimpleName("nextEntry");
    helper.setMethodData(method,4);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$HashIterator#nextEntry()
    // starting method java.util.WeakHashMap$HashIterator#remove()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove()");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$HashIterator#remove()

// finishing type java.util.WeakHashMap$HashIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$KeyIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","WeakHashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$KeyIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$KeyIterator#this$0


    // ignoring method java.util.WeakHashMap$KeyIterator#WeakHashMap$KeyIterator(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$KeyIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeyIterator#next()
    // starting method java.util.WeakHashMap$KeyIterator#WeakHashMap$KeyIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$KeyIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$KeyIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeyIterator#WeakHashMap$KeyIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$KeyIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$KeySet");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractSet");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$KeySet#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$KeySet#this$0


    // ignoring method java.util.WeakHashMap$KeySet#WeakHashMap$KeySet(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$KeySet#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#iterator()
    // starting method java.util.WeakHashMap$KeySet#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#size()
    // starting method java.util.WeakHashMap$KeySet#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#contains(java.lang.Object)
    // starting method java.util.WeakHashMap$KeySet#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#remove(java.lang.Object)
    // starting method java.util.WeakHashMap$KeySet#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#clear()
    // starting method java.util.WeakHashMap$KeySet#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#toArray()
    // starting method java.util.WeakHashMap$KeySet#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#toArray(java.lang.Object[])
    // starting method java.util.WeakHashMap$KeySet#WeakHashMap$KeySet(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$KeySet(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$KeySet");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$KeySet#WeakHashMap$KeySet(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$KeySet
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$ValueIterator");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","WeakHashMap$HashIterator");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$ValueIterator#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$ValueIterator#this$0


    // ignoring method java.util.WeakHashMap$ValueIterator#WeakHashMap$ValueIterator(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$ValueIterator#next()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"next()");
    method.setSimpleName("next");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$ValueIterator#next()
    // starting method java.util.WeakHashMap$ValueIterator#WeakHashMap$ValueIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$ValueIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$ValueIterator");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$ValueIterator#WeakHashMap$ValueIterator(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$ValueIterator
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap$Values");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractCollection");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.WeakHashMap$Values#this$0
	field = newType.addNode(JavaDataField.class,"this$0"); 
	fieldType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap");
    helper.insertFieldData(field, fieldType, 4112, isArray, arrayDimensions);
    // finishing field java.util.WeakHashMap$Values#this$0


    // ignoring method java.util.WeakHashMap$Values#WeakHashMap$Values(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap$Values#iterator()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"iterator()");
    method.setSimpleName("iterator");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Iterator");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#iterator()
    // starting method java.util.WeakHashMap$Values#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#size()
    // starting method java.util.WeakHashMap$Values#contains(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"contains(java.lang.Object)");
    method.setSimpleName("contains");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#contains(java.lang.Object)
    // starting method java.util.WeakHashMap$Values#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#clear()
    // starting method java.util.WeakHashMap$Values#toArray()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray()");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#toArray()
    // starting method java.util.WeakHashMap$Values#toArray(java.lang.Object[])
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"toArray(java.lang.Object[])");
    method.setSimpleName("toArray");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#toArray(java.lang.Object[])
    // starting method java.util.WeakHashMap$Values#WeakHashMap$Values(java.util.WeakHashMap, java.util.WeakHashMap$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap$Values(java.util.WeakHashMap, java.util.WeakHashMap$1)");
    method.setSimpleName("WeakHashMap$Values");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap$Values#WeakHashMap$Values(java.util.WeakHashMap, java.util.WeakHashMap$1)

// finishing type java.util.WeakHashMap$Values
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "WeakHashMap");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","AbstractMap");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface Map 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util","Map");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface Map 

// ignoring field java.util.WeakHashMap#DEFAULT_INITIAL_CAPACITY 

// ignoring field java.util.WeakHashMap#MAXIMUM_CAPACITY 

// ignoring field java.util.WeakHashMap#DEFAULT_LOAD_FACTOR 

// ignoring field java.util.WeakHashMap#table 

// ignoring field java.util.WeakHashMap#size 

// ignoring field java.util.WeakHashMap#threshold 

// ignoring field java.util.WeakHashMap#loadFactor 

// ignoring field java.util.WeakHashMap#queue 

// ignoring field java.util.WeakHashMap#modCount 

// ignoring field java.util.WeakHashMap#NULL_KEY 

// ignoring field java.util.WeakHashMap#entrySet 


    // starting method java.util.WeakHashMap#WeakHashMap(int, float)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap(int, float)");
    method.setSimpleName("WeakHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#WeakHashMap(int, float)
    // starting method java.util.WeakHashMap#WeakHashMap(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap(int)");
    method.setSimpleName("WeakHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#WeakHashMap(int)
    // starting method java.util.WeakHashMap#WeakHashMap()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap()");
    method.setSimpleName("WeakHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#WeakHashMap()
    // starting method java.util.WeakHashMap#WeakHashMap(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"WeakHashMap(java.util.Map)");
    method.setSimpleName("WeakHashMap");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#WeakHashMap(java.util.Map)
    // ignoring method java.util.WeakHashMap#maskNull(java.lang.Object)
    // ignoring method java.util.WeakHashMap#unmaskNull(java.lang.Object)
    // starting method java.util.WeakHashMap#eq(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"eq(java.lang.Object, java.lang.Object)");
    method.setSimpleName("eq");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#eq(java.lang.Object, java.lang.Object)
    // starting method java.util.WeakHashMap#indexFor(int, int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"indexFor(int, int)");
    method.setSimpleName("indexFor");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#indexFor(int, int)
    // ignoring method java.util.WeakHashMap#expungeStaleEntries()
    // ignoring method java.util.WeakHashMap#getTable()
    // starting method java.util.WeakHashMap#size()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"size()");
    method.setSimpleName("size");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#size()
    // starting method java.util.WeakHashMap#isEmpty()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"isEmpty()");
    method.setSimpleName("isEmpty");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#isEmpty()
    // starting method java.util.WeakHashMap#get(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"get(java.lang.Object)");
    method.setSimpleName("get");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#get(java.lang.Object)
    // starting method java.util.WeakHashMap#containsKey(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsKey(java.lang.Object)");
    method.setSimpleName("containsKey");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#containsKey(java.lang.Object)
    // starting method java.util.WeakHashMap#getEntry(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getEntry(java.lang.Object)");
    method.setSimpleName("getEntry");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#getEntry(java.lang.Object)
    // starting method java.util.WeakHashMap#put(java.lang.Object, java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"put(java.lang.Object, java.lang.Object)");
    method.setSimpleName("put");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#put(java.lang.Object, java.lang.Object)
    // starting method java.util.WeakHashMap#resize(int)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"resize(int)");
    method.setSimpleName("resize");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#resize(int)
    // ignoring method java.util.WeakHashMap#transfer(java.util.WeakHashMap$Entry[], java.util.WeakHashMap$Entry[])
    // starting method java.util.WeakHashMap#putAll(java.util.Map)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"putAll(java.util.Map)");
    method.setSimpleName("putAll");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#putAll(java.util.Map)
    // starting method java.util.WeakHashMap#remove(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"remove(java.lang.Object)");
    method.setSimpleName("remove");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#remove(java.lang.Object)
    // starting method java.util.WeakHashMap#removeMapping(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"removeMapping(java.lang.Object)");
    method.setSimpleName("removeMapping");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","WeakHashMap$Entry");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#removeMapping(java.lang.Object)
    // starting method java.util.WeakHashMap#clear()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"clear()");
    method.setSimpleName("clear");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#clear()
    // starting method java.util.WeakHashMap#containsValue(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"containsValue(java.lang.Object)");
    method.setSimpleName("containsValue");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "boolean");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#containsValue(java.lang.Object)
    // ignoring method java.util.WeakHashMap#containsNullValue()
    // starting method java.util.WeakHashMap#keySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"keySet()");
    method.setSimpleName("keySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#keySet()
    // starting method java.util.WeakHashMap#values()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"values()");
    method.setSimpleName("values");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Collection");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#values()
    // starting method java.util.WeakHashMap#entrySet()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"entrySet()");
    method.setSimpleName("entrySet");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.util","Set");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#entrySet()
    // starting method java.util.WeakHashMap#access$300(java.lang.Object)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$300(java.lang.Object)");
    method.setSimpleName("access$300");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "java.lang","Object");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#access$300(java.lang.Object)
    // starting method java.util.WeakHashMap#access$400(java.util.WeakHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$400(java.util.WeakHashMap)");
    method.setSimpleName("access$400");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "int");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#access$400(java.util.WeakHashMap)
    // starting method java.util.WeakHashMap#access$500(java.util.WeakHashMap)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"access$500(java.util.WeakHashMap)");
    method.setSimpleName("access$500");
    helper.setMethodData(method,4104);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    //method needs to be processed: ArrayTypeReference
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.WeakHashMap#access$500(java.util.WeakHashMap)

// finishing type java.util.WeakHashMap
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$1");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);



// finishing type java.util.XMLUtils$1
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$EH");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface ErrorHandler 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"org.xml.sax","ErrorHandler");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface ErrorHandler 


    // ignoring method java.util.XMLUtils$EH#XMLUtils$EH()
    // starting method java.util.XMLUtils$EH#error(org.xml.sax.SAXParseException)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"error(org.xml.sax.SAXParseException)");
    method.setSimpleName("error");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
    
    // finishing method java.util.XMLUtils$EH#error(org.xml.sax.SAXParseException)
    // starting method java.util.XMLUtils$EH#fatalError(org.xml.sax.SAXParseException)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"fatalError(org.xml.sax.SAXParseException)");
    method.setSimpleName("fatalError");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
    
    // finishing method java.util.XMLUtils$EH#fatalError(org.xml.sax.SAXParseException)
    // starting method java.util.XMLUtils$EH#warning(org.xml.sax.SAXParseException)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"warning(org.xml.sax.SAXParseException)");
    method.setSimpleName("warning");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
    
    // finishing method java.util.XMLUtils$EH#warning(org.xml.sax.SAXParseException)
    // starting method java.util.XMLUtils$EH#XMLUtils$EH(java.util.XMLUtils$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"XMLUtils$EH(java.util.XMLUtils$1)");
    method.setSimpleName("XMLUtils$EH");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.XMLUtils$EH#XMLUtils$EH(java.util.XMLUtils$1)

// finishing type java.util.XMLUtils$EH
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils$Resolver");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);
    // starting interface EntityResolver 
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"org.xml.sax","EntityResolver");
    implementsSuper = session.addLink(Implements.class, newType, newSuperType, false);
    // ending interface EntityResolver 


    // ignoring method java.util.XMLUtils$Resolver#XMLUtils$Resolver()
    // starting method java.util.XMLUtils$Resolver#resolveEntity(java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"resolveEntity(java.lang.String, java.lang.String)");
    method.setSimpleName("resolveEntity");
    helper.setMethodData(method,1);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","InputSource");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
    
    // finishing method java.util.XMLUtils$Resolver#resolveEntity(java.lang.String, java.lang.String)
    // starting method java.util.XMLUtils$Resolver#XMLUtils$Resolver(java.util.XMLUtils$1)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"XMLUtils$Resolver(java.util.XMLUtils$1)");
    method.setSimpleName("XMLUtils$Resolver");
    helper.setMethodData(method,4096);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.XMLUtils$Resolver#XMLUtils$Resolver(java.util.XMLUtils$1)

// finishing type java.util.XMLUtils$Resolver
// #########################################################

    newType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.util", "XMLUtils");
    newSuperType = helper.addAfterTypeProcessing(JavaTypeClass.class,"java.lang","Object");
    extendsSuper = session.addLink(Extends.class, newType, newSuperType, false);

// ignoring field java.util.XMLUtils#PROPS_DTD_URI 

// ignoring field java.util.XMLUtils#PROPS_DTD 

// ignoring field java.util.XMLUtils#EXTERNAL_XML_VERSION 

    isArray = false;
    arrayDimensions = 0;
    // starting field java.util.XMLUtils#$assertionsDisabled
	field = newType.addNode(JavaDataField.class,"$assertionsDisabled"); 
	fieldType = helper.addAfterTypeProcessing(JavaTypePrimitive.class, "","boolean");
    helper.insertFieldData(field, fieldType, 4120, isArray, arrayDimensions);
    // finishing field java.util.XMLUtils#$assertionsDisabled


    // starting method java.util.XMLUtils#XMLUtils()
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodConstructor.class,"XMLUtils()");
    method.setSimpleName("XMLUtils");
    helper.setMethodData(method,0);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.XMLUtils#XMLUtils()
    // starting method java.util.XMLUtils#load(java.util.Properties, java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"load(java.util.Properties, java.io.InputStream)");
    method.setSimpleName("load");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.util","InvalidPropertiesFormatException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.util.InvalidPropertiesFormatException
    
    // finishing method java.util.XMLUtils#load(java.util.Properties, java.io.InputStream)
    // starting method java.util.XMLUtils#getLoadingDoc(java.io.InputStream)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"getLoadingDoc(java.io.InputStream)");
    method.setSimpleName("getLoadingDoc");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaType.class, "org.w3c.dom","Document");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "org.xml.sax","SAXException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception org.xml.sax.SAXException
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.XMLUtils#getLoadingDoc(java.io.InputStream)
    // starting method java.util.XMLUtils#importProperties(java.util.Properties, org.w3c.dom.Element)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"importProperties(java.util.Properties, org.w3c.dom.Element)");
    method.setSimpleName("importProperties");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
    
    // finishing method java.util.XMLUtils#importProperties(java.util.Properties, org.w3c.dom.Element)
    // starting method java.util.XMLUtils#save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String)");
    method.setSimpleName("save");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.XMLUtils#save(java.util.Properties, java.io.OutputStream, java.lang.String, java.lang.String)
    // starting method java.util.XMLUtils#emitDocument(org.w3c.dom.Document, java.io.OutputStream, java.lang.String)
    isArray = false;
    arrayDimensions = 0;
    method = newType.addNode(JavaMethodMethod.class,"emitDocument(org.w3c.dom.Document, java.io.OutputStream, java.lang.String)");
    method.setSimpleName("emitDocument");
    helper.setMethodData(method,8);
    typeDeclaresMethod = session.addLink(TypeDeclares.class, newType, method, false);
    
    // starting method return 
    methodReturnTypeType = helper.addAfterTypeProcessing(JavaTypePrimitive.class,"", "void");
    methodReturnsType = session.addLink(MethodReturns.class, method, methodReturnTypeType, false);
    methodReturnsType.setArray(isArray);
    methodReturnsType.setArrayDimension(arrayDimensions);
        
    // finishing method return 
        newExceptionType = helper.addAfterTypeProcessing(JavaType.class, "java.io","IOException");
        methodThrowsType = session.addLink(MethodThrows.class, method, newExceptionType, false);
        // ending throws exception java.io.IOException
    
    // finishing method java.util.XMLUtils#emitDocument(org.w3c.dom.Document, java.io.OutputStream, java.lang.String)

// finishing type java.util.XMLUtils
// #########################################################

        